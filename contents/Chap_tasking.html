
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tasking &#8212; OpenMP Application Programming Interface Examples</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet">
  <link href="../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script>
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="&lt;no title&gt;" href="Chap_devices.html" />
    <link rel="prev" title="OpenMP Affinity" href="Chap_affinity.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">OpenMP Application Programming Interface Examples</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../intro.html">
   Welcome to OMP Jupyter Book
  </a>
 </li>
</ul>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_directives.html">
   OpenMP Directive Syntax
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_parallel_execution.html">
   Parallel Execution
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_affinity.html">
   OpenMP Affinity
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Tasking
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_SIMD.html">
   SIMD
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_synchronization.html">
   Synchronization
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_data_environment.html">
   Data Environment
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_memory_model.html">
   Memory Model
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_program_control.html">
   Program Control
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/contents/Chap_tasking.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
                onclick="printPdf(this)" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/passlab/Examples"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/passlab/Examples/issues/new?title=Issue%20on%20page%20%2Fcontents/Chap_tasking.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/passlab/Examples/main?urlpath=lab/tree/notebook/contents/Chap_tasking.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#task-and-taskwait-constructs">
   <code class="docutils literal notranslate">
    <span class="pre">
     task
    </span>
   </code>
   and
   <code class="docutils literal notranslate">
    <span class="pre">
     taskwait
    </span>
   </code>
   Constructs
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#task-priority">
   Task Priority
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#task-dependences">
   Task Dependences
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#flow-dependence">
     Flow Dependence
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#anti-dependence">
     Anti-dependence
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#output-dependence">
     Output Dependence
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#concurrent-execution-with-dependences">
     Concurrent Execution with Dependences
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#matrix-multiplication">
     Matrix multiplication
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#taskwait-with-dependences">
     <code class="docutils literal notranslate">
      <span class="pre">
       taskwait
      </span>
     </code>
     with Dependences
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#mutually-exclusive-execution-with-dependences">
     Mutually Exclusive Execution with Dependences
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#multidependences-using-iterators">
     Multidependences Using Iterators
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#dependence-for-undeferred-tasks">
     Dependence for Undeferred Tasks
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#task-detachment">
   Task Detachment
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#taskgroup-construct">
   <code class="docutils literal notranslate">
    <span class="pre">
     taskgroup
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#taskyield-construct">
   <code class="docutils literal notranslate">
    <span class="pre">
     taskyield
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#taskloop-construct">
   <code class="docutils literal notranslate">
    <span class="pre">
     taskloop
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#combined-parallel-masked-and-taskloop-constructs">
   Combined
   <code class="docutils literal notranslate">
    <span class="pre">
     parallel
    </span>
   </code>
   <code class="docutils literal notranslate">
    <span class="pre">
     masked
    </span>
   </code>
   and
   <code class="docutils literal notranslate">
    <span class="pre">
     taskloop
    </span>
   </code>
   Constructs
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Tasking</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#task-and-taskwait-constructs">
   <code class="docutils literal notranslate">
    <span class="pre">
     task
    </span>
   </code>
   and
   <code class="docutils literal notranslate">
    <span class="pre">
     taskwait
    </span>
   </code>
   Constructs
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#task-priority">
   Task Priority
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#task-dependences">
   Task Dependences
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#flow-dependence">
     Flow Dependence
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#anti-dependence">
     Anti-dependence
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#output-dependence">
     Output Dependence
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#concurrent-execution-with-dependences">
     Concurrent Execution with Dependences
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#matrix-multiplication">
     Matrix multiplication
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#taskwait-with-dependences">
     <code class="docutils literal notranslate">
      <span class="pre">
       taskwait
      </span>
     </code>
     with Dependences
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#mutually-exclusive-execution-with-dependences">
     Mutually Exclusive Execution with Dependences
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#multidependences-using-iterators">
     Multidependences Using Iterators
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#dependence-for-undeferred-tasks">
     Dependence for Undeferred Tasks
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#task-detachment">
   Task Detachment
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#taskgroup-construct">
   <code class="docutils literal notranslate">
    <span class="pre">
     taskgroup
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#taskyield-construct">
   <code class="docutils literal notranslate">
    <span class="pre">
     taskyield
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#taskloop-construct">
   <code class="docutils literal notranslate">
    <span class="pre">
     taskloop
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#combined-parallel-masked-and-taskloop-constructs">
   Combined
   <code class="docutils literal notranslate">
    <span class="pre">
     parallel
    </span>
   </code>
   <code class="docutils literal notranslate">
    <span class="pre">
     masked
    </span>
   </code>
   and
   <code class="docutils literal notranslate">
    <span class="pre">
     taskloop
    </span>
   </code>
   Constructs
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="tasking">
<h1>Tasking<a class="headerlink" href="#tasking" title="Permalink to this headline">¶</a></h1>
<p>{tasking}</p>
<p>Tasking constructs provide units of work to a thread for execution.   Worksharing constructs do this, too (e.g. <code class="docutils literal notranslate"><span class="pre">for</span></code>, <code class="docutils literal notranslate"><span class="pre">do</span></code>,  <code class="docutils literal notranslate"><span class="pre">sections</span></code>, and <code class="docutils literal notranslate"><span class="pre">singles</span></code> constructs);  but the work units are tightly controlled by an iteration limit and limited  scheduling, or a limited number of <code class="docutils literal notranslate"><span class="pre">sections</span></code> or <code class="docutils literal notranslate"><span class="pre">single</span></code> regions.  Worksharing was designed  with  <strong>“</strong> data parallel <strong>“</strong>  computing in mind.  Tasking was designed for   <strong>“</strong> task parallel <strong>“</strong>  computing and often involves non-locality or irregularity  in memory access.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">task</span></code> construct can be used to execute work chunks: in a while loop;  while traversing nodes in a list; at nodes in a tree graph;  or in a normal loop (with a <code class="docutils literal notranslate"><span class="pre">taskloop</span></code> construct).   Unlike the statically scheduled loop iterations of worksharing, a task is  often enqueued, and then dequeued for execution by any of the threads of the team within a parallel region. The generation of tasks can be from a single  generating thread (creating sibling tasks), or from multiple generators in a recursive graph tree traversals.  A <code class="docutils literal notranslate"><span class="pre">taskloop</span></code> construct bundles iterations of an associated loop into tasks, and provides  similar controls found in the <code class="docutils literal notranslate"><span class="pre">task</span></code> construct.</p>
<p>Sibling tasks are synchronized by the <code class="docutils literal notranslate"><span class="pre">taskwait</span></code> construct, and tasks and their descendent tasks can be synchronized by containing them in a <code class="docutils literal notranslate"><span class="pre">taskgroup</span></code> region.  Ordered execution is accomplished by specifying dependences with a <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause. Also, priorities can be specified as hints to the scheduler through a <code class="docutils literal notranslate"><span class="pre">priority</span></code> clause.</p>
<p>Various clauses can be used to manage and optimize task generation, as well as reduce the overhead of execution and to relinquish  control of threads for work balance and forward progress.</p>
<p>Once a thread starts executing a task, it is the designated thread  for executing the task to completion, even though it may leave the execution at a scheduling point and return later.  The thread is tied to the task.  Scheduling points can be introduced with the <code class="docutils literal notranslate"><span class="pre">taskyield</span></code> construct.  With an <code class="docutils literal notranslate"><span class="pre">untied</span></code> clause any other thread is allowed to continue the task.  An <code class="docutils literal notranslate"><span class="pre">if</span></code> clause with an expression that evaluates to  <em>false</em>   results in an <strong>undeferred</strong> task, which instructs the runtime to suspend the generating task until the undeferred task completes its execution. By including the data environment of the generating task into the generated task with the  <code class="docutils literal notranslate"><span class="pre">mergeable</span></code> and <code class="docutils literal notranslate"><span class="pre">final</span></code> clauses, task generation overhead can be reduced.</p>
<p>A complete list of the tasking constructs and details of their clauses can be found in the  <em>Tasking Constructs</em>  chapter of the OpenMP Specifications, in the  <em>OpenMP Application Programming Interface</em>  section.</p>
<div class="section" id="task-and-taskwait-constructs">
<h2><code class="docutils literal notranslate"><span class="pre">task</span></code> and <code class="docutils literal notranslate"><span class="pre">taskwait</span></code> Constructs<a class="headerlink" href="#task-and-taskwait-constructs" title="Permalink to this headline">¶</a></h2>
<p><strong>constructs!task <code class="docutils literal notranslate"><span class="pre">task</span></code></strong> <strong>task construct <code class="docutils literal notranslate"><span class="pre">task</span></code> construct</strong> <strong>constructs!taskwait <code class="docutils literal notranslate"><span class="pre">taskwait</span></code></strong> <strong>taskwait construct <code class="docutils literal notranslate"><span class="pre">taskwait</span></code> construct</strong></p>
<p>The following example shows how to traverse a tree-like structure using explicit  tasks. Note that the <code class="docutils literal notranslate"><span class="pre">traverse</span></code> function should be called from within a  parallel region for the different specified tasks to be executed in parallel. Also  note that the tasks will be executed in no specified order because there are no  synchronization directives. Thus, assuming that the traversal will be done in post  order, as in the sequential code, is wrong.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: tasking.1
* type: C
* version: omp_3.0
*/

struct node {
  struct node *left;
  struct node *right;
};

extern void process(struct node *);

void traverse( struct node *p )
{
  if (p-&gt;left)
#pragma omp task   // p is firstprivate by default
      traverse(p-&gt;left);
  if (p-&gt;right)
#pragma omp task    // p is firstprivate by default
      traverse(p-&gt;right);
  process(p);
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: tasking.1
! type: F-free
! version:    omp_3.0

       RECURSIVE SUBROUTINE traverse ( P )
          TYPE Node
             TYPE(Node), POINTER :: left, right
          END TYPE Node
          TYPE(Node) :: P

          IF (associated(P%left)) THEN
             !$OMP TASK     ! P is firstprivate by default
                 CALL traverse(P%left)
             !$OMP END TASK
          ENDIF
          IF (associated(P%right)) THEN
             !$OMP TASK     ! P is firstprivate by default
                 CALL traverse(P%right)
             !$OMP END TASK
          ENDIF
          CALL process ( P )

       END SUBROUTINE

</pre></div>
</div>
</div>
</div>
<p>In the next example, we force a postorder traversal of the tree by adding a <code class="docutils literal notranslate"><span class="pre">taskwait</span></code>  directive. Now, we can safely assume that the left and right sons have been executed  before we process the current node.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: tasking.2
* type: C
* version: omp_3.0
*/
struct node {
  struct node *left;
  struct node *right;
};
extern void process(struct node *);
void postorder_traverse( struct node *p ) {
    if (p-&gt;left)
       #pragma omp task    // p is firstprivate by default
           postorder_traverse(p-&gt;left);
    if (p-&gt;right)
       #pragma omp task   // p is firstprivate by default
           postorder_traverse(p-&gt;right);
    #pragma omp taskwait
    process(p);
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: tasking.2
! type: F-free
! version:    omp_3.0
      RECURSIVE SUBROUTINE traverse ( P )
         TYPE Node
             TYPE(Node), POINTER :: left, right
         END TYPE Node
         TYPE(Node) :: P
         IF (associated(P%left)) THEN
             !$OMP TASK    ! P is firstprivate by default
                 CALL traverse(P%left)
             !$OMP END TASK
         ENDIF
         IF (associated(P%right)) THEN
             !$OMP TASK    ! P is firstprivate by default
                 CALL traverse(P%right)
             !$OMP END TASK
         ENDIF
         !$OMP TASKWAIT
         CALL process ( P )
      END SUBROUTINE

</pre></div>
</div>
</div>
</div>
<p>The following example demonstrates how to use the <code class="docutils literal notranslate"><span class="pre">task</span></code> construct to process  elements of a linked list in parallel. The thread executing the <code class="docutils literal notranslate"><span class="pre">single</span></code>  region generates all of the explicit tasks, which are then executed by the threads  in the current team. The pointer  <em>p</em>  is <code class="docutils literal notranslate"><span class="pre">firstprivate</span></code> by default  on the <code class="docutils literal notranslate"><span class="pre">task</span></code> construct so it is not necessary to specify it in a <code class="docutils literal notranslate"><span class="pre">firstprivate</span></code>  clause.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: tasking.3
* type: C
* version: omp_3.0
*/

typedef struct node node;
struct node {
      int data;
      node * next;
};

void process(node * p)
{
    /* do work here */
}

void increment_list_items(node * head)
{
    #pragma omp parallel
    {
        #pragma omp single
            {
               node * p = head;
               while (p) {
                    #pragma omp task
                     // p is firstprivate by default
                           process(p);
                     p = p-&gt;next;
                  }
            }
     }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: tasking.3
! type: F-free
! version:    omp_3.0

      MODULE LIST
          TYPE NODE
             INTEGER :: PAYLOAD
             TYPE (NODE), POINTER :: NEXT
          END TYPE NODE
      CONTAINS

          SUBROUTINE PROCESS(p)
             TYPE (NODE), POINTER :: P
                 ! do work here
          END SUBROUTINE

          SUBROUTINE INCREMENT_LIST_ITEMS (HEAD)

             TYPE (NODE), POINTER :: HEAD
             TYPE (NODE), POINTER :: P
             !$OMP PARALLEL PRIVATE(P)
                 !$OMP SINGLE
                     P =&gt; HEAD
                     DO
                        !$OMP TASK
                            ! P is firstprivate by default
                            CALL PROCESS(P)
                        !$OMP END TASK
                        P =&gt; P%NEXT
                        IF ( .NOT. ASSOCIATED (P) ) EXIT
                     END DO
                 !$OMP END SINGLE
             !$OMP END PARALLEL

          END SUBROUTINE

      END MODULE

</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">fib()</span></code> function should be called from within a <code class="docutils literal notranslate"><span class="pre">parallel</span></code>  region  for the different specified tasks to be executed in parallel. Also, only one thread  of the <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region should call <code class="docutils literal notranslate"><span class="pre">fib()</span></code> unless multiple concurrent  Fibonacci computations are desired.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: tasking.4
* type: C
* version: omp_3.0
*/
     int fib(int n) {
        int i, j;
        if (n&lt;2)
          return n;
        else {
           #pragma omp task shared(i)
              i=fib(n-1);
           #pragma omp task shared(j)
              j=fib(n-2);
           #pragma omp taskwait
              return i+j;
        }
     }

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: tasking.4
! type: F-fixed
! version: omp_3.0
      RECURSIVE INTEGER FUNCTION fib(n) RESULT(res)
      INTEGER n, i, j
      IF ( n .LT. 2) THEN
        res = n
      ELSE
!$OMP TASK SHARED(i)
        i = fib( n-1 )
!$OMP END TASK
!$OMP TASK SHARED(j)
        j = fib( n-2 )
!$OMP END TASK
!$OMP TASKWAIT
        res = i+j
      END IF
      END FUNCTION

</pre></div>
</div>
</div>
</div>
<p>Note: There are more efficient algorithms for computing Fibonacci numbers. This  classic recursion algorithm is for illustrative purposes.</p>
<p>The following example demonstrates a way to generate a large number of tasks with  one thread and execute them with the threads in the team. While generating these  tasks, the implementation may reach its limit on unassigned tasks.  If it does,  the implementation is allowed to cause the thread executing the task generating  loop to suspend its task at the task scheduling point in the <code class="docutils literal notranslate"><span class="pre">task</span></code> directive,  and start executing unassigned tasks.  Once the number of unassigned tasks is sufficiently  low, the thread may resume execution of the task generating loop.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: tasking.5
* type: C
* version: omp_3.0
*/
#define LARGE_NUMBER 10000000
double item[LARGE_NUMBER];
extern void process(double);

int main()
{
#pragma omp parallel
  {
    #pragma omp single
    {
      int i;
      for (i=0; i&lt;LARGE_NUMBER; i++)
             #pragma omp task    // i is firstprivate, item is shared
                  process(item[i]);
    }
  }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: tasking.5
! type: F-fixed
! version: omp_3.0
       real*8 item(10000000)
       integer i

!$omp parallel
!$omp single ! loop iteration variable i is private
       do i=1,10000000
!$omp task
         ! i is firstprivate, item is shared
          call process(item(i))
!$omp end task
       end do
!$omp end single
!$omp end parallel

       end

</pre></div>
</div>
</div>
</div>
<p><strong>task construct <code class="docutils literal notranslate"><span class="pre">task</span></code> construct!untied clause <code class="docutils literal notranslate"><span class="pre">untied</span></code> clause</strong> <strong>untied clause <code class="docutils literal notranslate"><span class="pre">untied</span></code> clause</strong> <strong>clauses!untied <code class="docutils literal notranslate"><span class="pre">untied</span></code></strong> <strong>task scheduling point</strong> The following example is the same as the previous one, except that the tasks are  generated in an untied task. While generating the tasks, the implementation may  reach its limit on unassigned tasks. If it does, the implementation is allowed  to cause the thread executing the task generating loop to suspend its task at the  task scheduling point in the <code class="docutils literal notranslate"><span class="pre">task</span></code> directive, and start executing unassigned  tasks.  If that thread begins execution of a task that takes a long time to complete,  the other threads may complete all the other tasks before it is finished.</p>
<p>In this case, since the loop is in an untied task, any other thread is eligible  to resume the task generating loop. In the previous examples, the other threads  would be forced to idle until the generating thread finishes its long task, since  the task generating loop was in a tied task.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: tasking.6
* type: C
* version: omp_3.0
*/
#define LARGE_NUMBER 10000000
double item[LARGE_NUMBER];
extern void process(double);
int main() {
#pragma omp parallel
  {
    #pragma omp single
    {
      int i;
      #pragma omp task untied
      // i is firstprivate, item is shared
      {
         for (i=0; i&lt;LARGE_NUMBER; i++)
             #pragma omp task
                  process(item[i]);
      }
    }
  }
  return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: tasking.6
! type: F-fixed
! version: omp_3.0
       real*8 item(10000000)
!$omp parallel
!$omp single
!$omp task untied
       ! loop iteration variable i is private
       do i=1,10000000
!$omp task ! i is firstprivate, item is shared
          call process(item(i))
!$omp end task
       end do
!$omp end task
!$omp end single
!$omp end parallel
       end

</pre></div>
</div>
</div>
</div>
<p>The following two examples demonstrate how the scheduling rules illustrated in  Section 2.11.3 of the OpenMP 4.0 specification affect the usage of  <code class="docutils literal notranslate"><span class="pre">threadprivate</span></code> variables in tasks. A <code class="docutils literal notranslate"><span class="pre">threadprivate</span></code>  variable can be modified by another task that is executed by the same thread. Thus,  the value of a <code class="docutils literal notranslate"><span class="pre">threadprivate</span></code> variable cannot be assumed to be unchanged  across a task scheduling point. In untied tasks, task scheduling points may be  added in any place by the implementation.</p>
<p>A task switch may occur at a task scheduling point. A single thread may execute  both of the task regions that modify <code class="docutils literal notranslate"><span class="pre">tp</span></code>. The parts of these task regions  in which <code class="docutils literal notranslate"><span class="pre">tp</span></code> is modified may be executed in any order so the resulting  value of <code class="docutils literal notranslate"><span class="pre">var</span></code> can be either 1 or 2.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: tasking.7
* type: C
* version: omp_3.0
*/

int tp;
#pragma omp threadprivate(tp)
int var;
void work()
{
#pragma omp task
    {
        /* do work here */
#pragma omp task
        {
            tp = 1;
            /* do work here */
#pragma omp task
            {
                /* no modification of tp */
            }
            var = tp; //value of tp can be 1 or 2
        }
        tp = 2;
    }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: tasking.7
! type: F-fixed
! version: omp_3.0
      module example
      integer tp
!$omp threadprivate(tp)
      integer var
      contains
      subroutine work
!$omp task
         ! do work here
!$omp task
         tp = 1
         ! do work here
!$omp task
           ! no modification of tp
!$omp end task
         var = tp    ! value of var can be 1 or 2
!$omp end task
        tp = 2
!$omp end task
      end subroutine
      end module

</pre></div>
</div>
</div>
</div>
<p>In this example, scheduling constraints prohibit a thread in the team from executing  a new task that modifies <code class="docutils literal notranslate"><span class="pre">tp</span></code>  while another such task region tied to the  same thread is suspended. Therefore, the value written will persist across the  task scheduling point.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: tasking.8
* type: C
* version: omp_3.0
*/

int tp;
#pragma omp threadprivate(tp)
int var;
void work()
{
#pragma omp parallel
    {
        /* do work here */
#pragma omp task
        {
            tp++;
            /* do work here */
#pragma omp task
            {
                /* do work here but don&#39;t modify tp */
            }
            var = tp; //Value does not change after write above
        }
    }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: tasking.8
! type: F-fixed
! version: omp_3.0
      module example
      integer tp
!$omp threadprivate(tp)
      integer var
      contains
      subroutine work
!$omp parallel
         ! do work here
!$omp task
         tp = tp + 1
         ! do work here
!$omp task
           ! do work here but don&#39;t modify tp
!$omp end task
         var = tp    ! value does not change after write above
!$omp end task
!$omp end parallel
      end subroutine
      end module

</pre></div>
</div>
</div>
</div>
<p>The following two examples demonstrate how the scheduling rules illustrated in  Section 2.11.3 of the OpenMP 4.0 specification affect the usage of locks  and critical sections in tasks.  If a lock is held  across a task scheduling point, no attempt should be made to acquire the same lock  in any code that may be interleaved.  Otherwise, a deadlock is possible.</p>
<p>In the example below, suppose the thread executing task 1 defers task 2.  When  it encounters the task scheduling point at task 3, it could suspend task 1 and  begin task 2 which will result in a deadlock when it tries to enter critical region  1.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: tasking.9
* type: C
* version: omp_3.0
*/
void work()
{
   #pragma omp task
   { //Task 1
       #pragma omp task
       { //Task 2
            #pragma omp critical //Critical region 1
            {/*do work here */ }
       }
       #pragma omp critical //Critical Region 2
       {
           //Capture data for the following task
           #pragma omp task
           { /* do work here */ } //Task 3
       }
   }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: tasking.9
! type: F-fixed
! version: omp_3.0
       module example
       contains
       subroutine work
!$omp task
       ! Task 1
!$omp task
       ! Task 2
!$omp critical
       ! Critical region 1
       ! do work here
!$omp end critical
!$omp end task
!$omp critical
       ! Critical region 2
       ! Capture data for the following task
!$omp task
       !Task 3
       ! do work here
!$omp end task
!$omp end critical
!$omp end task
      end subroutine
      end module

</pre></div>
</div>
</div>
</div>
<p>In the following example, <code class="docutils literal notranslate"><span class="pre">lock</span></code> is held across a task scheduling point.   However, according to the scheduling restrictions, the executing thread can’t  begin executing one of the non-descendant tasks that also acquires <code class="docutils literal notranslate"><span class="pre">lock</span></code> before  the task region is complete.  Therefore, no deadlock is possible.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: tasking.10
* type: C
* version: omp_3.0
*/
#include &lt;omp.h&gt;
void work() {
    omp_lock_t lock;
    omp_init_lock(&amp;lock);
#pragma omp parallel
    {
        int i;
#pragma omp for
        for (i = 0; i &lt; 100; i++) {
#pragma omp task
            {
 // lock is shared by default in the task
 omp_set_lock(&amp;lock);
                // Capture data for the following task
#pragma omp task
 // Task Scheduling Point 1
                { /* do work here */ }
                omp_unset_lock(&amp;lock);
            }
        }
    }
    omp_destroy_lock(&amp;lock);
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: tasking.10
! type: F-free
! version:    omp_3.0
      module example
      include &#39;omp_lib.h&#39;
      integer (kind=omp_lock_kind) lock
      integer i

      contains

      subroutine work
      call omp_init_lock(lock)
!$omp parallel
     !$omp do
      do i=1,100
         !$omp task
              ! Outer task
              call omp_set_lock(lock)    ! lock is shared by
                                         ! default in the task
                     ! Capture data for the following task
                     !$omp task     ! Task Scheduling Point 1
                              ! do work here
                     !$omp end task
               call omp_unset_lock(lock)
         !$omp end task
      end do
!$omp end parallel
      call omp_destroy_lock(lock)
      end subroutine

      end module

</pre></div>
</div>
</div>
</div>
<p><strong>task construct <code class="docutils literal notranslate"><span class="pre">task</span></code> construct!mergeable clause <code class="docutils literal notranslate"><span class="pre">mergeable</span></code> clause</strong> <strong>clauses!mergeable <code class="docutils literal notranslate"><span class="pre">mergeable</span></code></strong> <strong>mergeable clause <code class="docutils literal notranslate"><span class="pre">mergeable</span></code> clause</strong> The following examples illustrate the use of the <code class="docutils literal notranslate"><span class="pre">mergeable</span></code> clause in the  <code class="docutils literal notranslate"><span class="pre">task</span></code> construct. In this first example, the <code class="docutils literal notranslate"><span class="pre">task</span></code> construct has  been annotated with the <code class="docutils literal notranslate"><span class="pre">mergeable</span></code>  clause. The addition of this clause  allows the implementation to reuse the data environment (including the ICVs) of  the parent task for the task inside <code class="docutils literal notranslate"><span class="pre">foo</span></code> if the task is included or undeferred.  Thus, the result of the execution may differ depending on whether the task is merged  or not. Therefore the mergeable clause needs to be used with caution. In this example,  the use of the mergeable clause is safe. As <code class="docutils literal notranslate"><span class="pre">x</span></code> is a shared variable the  outcome does not depend on whether or not the task is merged (that is, the task  will always increment the same variable and will always compute the same value  for <code class="docutils literal notranslate"><span class="pre">x</span></code>).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: tasking.11
* type: C
* version: omp_3.1
*/
#include &lt;stdio.h&gt;
void foo ( )
{
   int x = 2;
   #pragma omp task shared(x) mergeable
   {
      x++;
   }
   #pragma omp taskwait
   printf(&quot;%d\n&quot;,x);  // prints 3
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: tasking.11
! type: F-free
! version:    omp_3.1
subroutine foo()
  integer :: x
  x = 2
!$omp task shared(x) mergeable
  x = x + 1
!$omp end task
!$omp taskwait
  print *, x     ! prints 3
end subroutine

</pre></div>
</div>
</div>
</div>
<p>This second example shows an incorrect use of the <code class="docutils literal notranslate"><span class="pre">mergeable</span></code> clause. In  this example, the created task will access different instances of the variable  <code class="docutils literal notranslate"><span class="pre">x</span></code> if the task is not merged, as <code class="docutils literal notranslate"><span class="pre">x</span></code> is <code class="docutils literal notranslate"><span class="pre">firstprivate</span></code>, but  it will access the same variable <code class="docutils literal notranslate"><span class="pre">x</span></code> if the task is merged. As a result,  the behavior of the program is unspecified, and it can print two different values  for <code class="docutils literal notranslate"><span class="pre">x</span></code> depending on the decisions taken by the implementation.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: tasking.12
* type: C
* version: omp_3.1
*/
#include &lt;stdio.h&gt;
void foo ( )
{
   int x = 2;
   #pragma omp task mergeable
   {
      x++;
   }
   #pragma omp taskwait
   printf(&quot;%d\n&quot;,x);  // prints 2 or 3
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: tasking.12
! type: F-free
! version:    omp_3.1
subroutine foo()
  integer :: x
  x = 2
!$omp task mergeable
  x = x + 1
!$omp end task
!$omp taskwait
  print *, x   ! prints 2 or 3
end subroutine

</pre></div>
</div>
</div>
</div>
<p><strong>task construct <code class="docutils literal notranslate"><span class="pre">task</span></code> construct!final clause <code class="docutils literal notranslate"><span class="pre">final</span></code> clause</strong> <strong>clauses!final <code class="docutils literal notranslate"><span class="pre">final</span></code></strong> <strong>final clause <code class="docutils literal notranslate"><span class="pre">final</span></code> clause</strong> <strong>routines!omp_in_final <code class="docutils literal notranslate"><span class="pre">omp_in_final</span></code></strong> <strong>omp_in_final routine <code class="docutils literal notranslate"><span class="pre">omp_in_final</span></code> routine</strong> The following example shows the use of the <code class="docutils literal notranslate"><span class="pre">final</span></code> clause and the <code class="docutils literal notranslate"><span class="pre">omp_in_final</span></code>  API call in a recursive binary search program. To reduce overhead, once a certain  depth of recursion is reached the program uses the <code class="docutils literal notranslate"><span class="pre">final</span></code> clause to create  only included tasks, which allow additional optimizations.</p>
<p>The use of the <code class="docutils literal notranslate"><span class="pre">omp_in_final</span></code> API call allows programmers to optimize  their code by specifying which parts of the program are not necessary when a task  can create only included tasks (that is, the code is inside a <code class="docutils literal notranslate"><span class="pre">final</span></code> task).  In this example, the use of a different state variable is not necessary so once  the program reaches the part of the computation that is finalized and copying from  the parent state to the new state is eliminated. The allocation of <code class="docutils literal notranslate"><span class="pre">new_state</span></code>  in the stack could also be avoided but it would make this example less clear. The  <code class="docutils literal notranslate"><span class="pre">final</span></code> clause is most effective when used in conjunction with the <code class="docutils literal notranslate"><span class="pre">mergeable</span></code>  clause since all tasks created in a <code class="docutils literal notranslate"><span class="pre">final</span></code> task region are included tasks  that can be merged if the <code class="docutils literal notranslate"><span class="pre">mergeable</span></code> clause is present.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: tasking.13
* type: C
* version: omp_3.1
*/
#include &lt;string.h&gt;
#include &lt;omp.h&gt;
#define LIMIT  3 /* arbitrary limit on recursion depth */
void check_solution(char *);
void bin_search (int pos, int n, char *state)
{
   if ( pos == n ) {
      check_solution(state);
      return;
   }
   #pragma omp task final( pos &gt; LIMIT ) mergeable
   {
      char new_state[n];
      if (!omp_in_final() ) {
        memcpy(new_state, state, pos );
        state = new_state;
      }
      state[pos] = 0;
      bin_search(pos+1, n, state );
   }
   #pragma omp task final( pos &gt; LIMIT ) mergeable
   {
      char new_state[n];
      if (! omp_in_final() ) {
        memcpy(new_state, state, pos );
        state = new_state;
      }
      state[pos] = 1;
      bin_search(pos+1, n, state );
   }
   #pragma omp taskwait
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: tasking.13
! type: F-free
! version:    omp_3.1
recursive subroutine bin_search(pos, n, state)
  use omp_lib
  integer :: pos, n
  character, pointer :: state(:)
  character, target, dimension(n) :: new_state1, new_state2
  integer, parameter :: LIMIT = 3
  if (pos .eq. n) then
    call check_solution(state)
    return
  endif
!$omp task final(pos &gt; LIMIT) mergeable
  if (.not. omp_in_final()) then
    new_state1(1:pos) = state(1:pos)
    state =&gt; new_state1
  endif
  state(pos+1) = &#39;z&#39;
  call bin_search(pos+1, n, state)
!$omp end task
!$omp task final(pos &gt; LIMIT) mergeable
  if (.not. omp_in_final()) then
    new_state2(1:pos) = state(1:pos)
    state =&gt; new_state2
  endif
  state(pos+1) = &#39;y&#39;
  call bin_search(pos+1, n, state)
!$omp end task
!$omp taskwait
end subroutine

</pre></div>
</div>
</div>
</div>
<p><strong>task construct <code class="docutils literal notranslate"><span class="pre">task</span></code> construct!if clause <code class="docutils literal notranslate"><span class="pre">if</span></code> clause</strong> <strong>clauses!if <code class="docutils literal notranslate"><span class="pre">if</span></code></strong> <strong>if clause <code class="docutils literal notranslate"><span class="pre">if</span></code> clause</strong> The following example illustrates the difference between the <code class="docutils literal notranslate"><span class="pre">if</span></code>  and the  <code class="docutils literal notranslate"><span class="pre">final</span></code> clauses. The <code class="docutils literal notranslate"><span class="pre">if</span></code> clause has a local effect. In the first  nest of tasks, the one that has the <code class="docutils literal notranslate"><span class="pre">if</span></code>  clause will be undeferred but  the task nested inside that task will not be affected by the <code class="docutils literal notranslate"><span class="pre">if</span></code> clause  and will be created as usual. Alternatively, the <code class="docutils literal notranslate"><span class="pre">final</span></code> clause affects  all <code class="docutils literal notranslate"><span class="pre">task</span></code> constructs in the <code class="docutils literal notranslate"><span class="pre">final</span></code> task region but not the <code class="docutils literal notranslate"><span class="pre">final</span></code>  task itself. In the second nest of tasks, the nested tasks will be created as included  tasks. Note also that the conditions for the <code class="docutils literal notranslate"><span class="pre">if</span></code> and <code class="docutils literal notranslate"><span class="pre">final</span></code> clauses  are usually the opposite.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: tasking.14
* type: C
* version: omp_3.1
*/
void bar(void);

void foo ( )
{
   int i;
   #pragma omp task if(0)  // This task is undeferred
   {
      #pragma omp task     // This task is a regular task
      for (i = 0; i &lt; 3; i++) {
          #pragma omp task     // This task is a regular task
          bar();
      }
   }
   #pragma omp task final(1) // This task is a regular task
   {
      #pragma omp task  // This task is included
      for (i = 0; i &lt; 3; i++) {
          #pragma omp task     // This task is also included
          bar();
      }
   }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: tasking.14
! type: F-free
! version:    omp_3.1
subroutine foo()
integer i
!$omp task if(.FALSE.) ! This task is undeferred
!$omp task             ! This task is a regular task
  do i = 1, 3
    !$omp task             ! This task is a regular task
      call bar()
    !$omp end task
  enddo
!$omp end task
!$omp end task
!$omp task final(.TRUE.) ! This task is a regular task
!$omp task               ! This task is included
  do i = 1, 3
    !$omp task               ! This task is also included
     call bar()
    !$omp end task
  enddo
!$omp end task
!$omp end task
end subroutine

</pre></div>
</div>
</div>
</div>
<p>../../tasking/tasking.tex</p>
</div>
<div class="section" id="task-priority">
<h2>Task Priority<a class="headerlink" href="#task-priority" title="Permalink to this headline">¶</a></h2>
<p><strong>task construct <code class="docutils literal notranslate"><span class="pre">task</span></code> construct!priority clause <code class="docutils literal notranslate"><span class="pre">priority</span></code> clause</strong> <strong>priority clause <code class="docutils literal notranslate"><span class="pre">priority</span></code> clause</strong> <strong>clauses!priority <code class="docutils literal notranslate"><span class="pre">priority</span></code></strong></p>
<p>In this example we compute arrays in a matrix through a  <em>compute_array</em>  routine. Each task has a priority value equal to the value of the loop variable  <em>i</em>  at the moment of its creation. A higher priority on a task means that a task is a candidate to run sooner.</p>
<p>The creation of tasks occurs in ascending order (according to the iteration space of the loop) but a hint, by means of the <code class="docutils literal notranslate"><span class="pre">priority</span></code> clause, is provided to reverse the execution order.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name:       task_priority.1
* type:       C
* version:    omp_4.5
*/
void compute_array (float *node, int M);

void compute_matrix (float *array, int N, int M)
{
   int i;
   #pragma omp parallel private(i)
   #pragma omp single
   {
      for (i=0;i&lt;N; i++) {
         #pragma omp task priority(i)
         compute_array(&amp;array[i*M], M);
      }
   }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: task_priority.1
! type: F-free
! version:    omp_4.5
subroutine compute_matrix(matrix, M, N)
   implicit none
   integer :: M, N
   real :: matrix(M, N)
   integer :: i
   interface
      subroutine compute_array(node, M)
      implicit none
      integer :: M
      real :: node(M)
      end subroutine
   end interface
   !$omp parallel private(i)
   !$omp single
   do i=1,N
      !$omp task priority(i)
      call compute_array(matrix(:, i), M)
      !$omp end task
   enddo
   !$omp end single
   !$omp end parallel
end subroutine compute_matrix

</pre></div>
</div>
</div>
</div>
<p>../../tasking/task_priority.tex</p>
</div>
<div class="section" id="task-dependences">
<h2>Task Dependences<a class="headerlink" href="#task-dependences" title="Permalink to this headline">¶</a></h2>
<p><strong>dependences!task dependences</strong></p>
<div class="section" id="flow-dependence">
<h3>Flow Dependence<a class="headerlink" href="#flow-dependence" title="Permalink to this headline">¶</a></h3>
<p><strong>task dependences!flow dependence</strong> <strong>task construct <code class="docutils literal notranslate"><span class="pre">task</span></code> construct!depend clause <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause</strong> <strong>task construct <code class="docutils literal notranslate"><span class="pre">task</span></code> construct</strong> <strong>constructs!task <code class="docutils literal notranslate"><span class="pre">task</span></code></strong> <strong>depend clause <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause</strong> <strong>clauses!depend <code class="docutils literal notranslate"><span class="pre">depend</span></code></strong></p>
<p>This example shows a simple flow dependence using a <code class="docutils literal notranslate"><span class="pre">depend</span></code>  clause on the <code class="docutils literal notranslate"><span class="pre">task</span></code> construct.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: task_dep.1
* type: C
* version: omp_4.0
*/
#include &lt;stdio.h&gt;
int main() {
   int x = 1;
   #pragma omp parallel
   #pragma omp single
   {
      #pragma omp task shared(x) depend(out: x)
         x = 2;
      #pragma omp task shared(x) depend(in: x)
         printf(&quot;x = %d\n&quot;, x);
   }
   return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: task_dep.1
! type: F-free
! version:    omp_4.0
program example
   integer :: x
   x = 1
   !$omp parallel
   !$omp single
      !$omp task shared(x) depend(out: x)
         x = 2
      !$omp end task
      !$omp task shared(x) depend(in: x)
         print*, &quot;x = &quot;, x
      !$omp end task
   !$omp end single
   !$omp end parallel
end program

</pre></div>
</div>
</div>
</div>
<p>The program will always print  <strong>“</strong> x = 2 <strong>“</strong> , because the <code class="docutils literal notranslate"><span class="pre">depend</span></code>  clauses enforce the ordering of the tasks. If the <code class="docutils literal notranslate"><span class="pre">depend</span></code> clauses had been  omitted, then the tasks could execute in any order and the program and the program  would have a race condition.</p>
</div>
<div class="section" id="anti-dependence">
<h3>Anti-dependence<a class="headerlink" href="#anti-dependence" title="Permalink to this headline">¶</a></h3>
<p><strong>task dependences!anti dependence</strong></p>
<p>This example shows an anti-dependence using the <code class="docutils literal notranslate"><span class="pre">depend</span></code>  clause on the <code class="docutils literal notranslate"><span class="pre">task</span></code> construct.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: task_dep.2
* type: C
* version: omp_4.0
*/
#include &lt;stdio.h&gt;
int main()
{
   int x = 1;
   #pragma omp parallel
   #pragma omp single
   {
      #pragma omp task shared(x) depend(in: x)
         printf(&quot;x = %d\n&quot;, x);
      #pragma omp task shared(x) depend(out: x)
         x = 2;
   }
   return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: task_dep.2
! type: F-free
! version:    omp_4.0
program example
   integer :: x
   x = 1
   !$omp parallel
   !$omp single
      !$omp task shared(x) depend(in: x)
         print*, &quot;x = &quot;, x
      !$omp end task
      !$omp task shared(x) depend(out: x)
         x = 2
      !$omp end task
   !$omp end single
   !$omp end parallel
end program

</pre></div>
</div>
</div>
</div>
<p>The program will always print  <strong>“</strong> x = 1 <strong>“</strong> , because the <code class="docutils literal notranslate"><span class="pre">depend</span></code>  clauses enforce the ordering of the tasks. If the <code class="docutils literal notranslate"><span class="pre">depend</span></code> clauses had been  omitted, then the tasks could execute in any order and the program would have a  race condition.</p>
</div>
<div class="section" id="output-dependence">
<h3>Output Dependence<a class="headerlink" href="#output-dependence" title="Permalink to this headline">¶</a></h3>
<p><strong>task dependences!output dependence</strong></p>
<p>This example shows an output dependence using the <code class="docutils literal notranslate"><span class="pre">depend</span></code>  clause on the <code class="docutils literal notranslate"><span class="pre">task</span></code> construct.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: task_dep.3
* type: C
* version: omp_4.0
*/
#include &lt;stdio.h&gt;
int main() {
   int x;
   #pragma omp parallel
   #pragma omp single
   {
      #pragma omp task shared(x) depend(out: x)
         x = 1;
      #pragma omp task shared(x) depend(out: x)
         x = 2;
      #pragma omp taskwait
      printf(&quot;x = %d\n&quot;, x);
   }
   return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: task_dep.3
! type: F-free
! version:    omp_4.0
program example
   integer :: x
   !$omp parallel
   !$omp single
      !$omp task shared(x) depend(out: x)
         x = 1
      !$omp end task
      !$omp task shared(x) depend(out: x)
         x = 2
      !$omp end task
      !$omp taskwait
      print*, &quot;x = &quot;, x
   !$omp end single
   !$omp end parallel
end program

</pre></div>
</div>
</div>
</div>
<p>The program will always print  <strong>“</strong> x = 2 <strong>“</strong> , because the <code class="docutils literal notranslate"><span class="pre">depend</span></code>  clauses enforce the ordering of the tasks. If the <code class="docutils literal notranslate"><span class="pre">depend</span></code> clauses had been  omitted, then the tasks could execute in any order and the program would have a  race condition.</p>
</div>
<div class="section" id="concurrent-execution-with-dependences">
<h3>Concurrent Execution with Dependences<a class="headerlink" href="#concurrent-execution-with-dependences" title="Permalink to this headline">¶</a></h3>
<p><strong>task dependences!concurrent execution with</strong></p>
<p>In this example we show potentially concurrent execution of tasks using multiple  flow dependences expressed using the <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause on the <code class="docutils literal notranslate"><span class="pre">task</span></code>  construct.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: task_dep.4
* type: C
* version: omp_4.0
*/
#include &lt;stdio.h&gt;
int main() {
   int x = 1;
   #pragma omp parallel
   #pragma omp single
   {
      #pragma omp task shared(x) depend(out: x)
         x = 2;
      #pragma omp task shared(x) depend(in: x)
         printf(&quot;x + 1 = %d. &quot;, x+1);
      #pragma omp task shared(x) depend(in: x)
         printf(&quot;x + 2 = %d\n&quot;, x+2);
   }
   return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: task_dep.4
! type: F-free
! version:    omp_4.0

program example
   integer :: x

   x = 1

   !$omp parallel
   !$omp single

      !$omp task shared(x) depend(out: x)
         x = 2
      !$omp end task

      !$omp task shared(x) depend(in: x)
         print*, &quot;x + 1 = &quot;, x+1, &quot;.&quot;
      !$omp end task

      !$omp task shared(x) depend(in: x)
         print*, &quot;x + 2 = &quot;, x+2, &quot;.&quot;
      !$omp end task

   !$omp end single
   !$omp end parallel
end program

</pre></div>
</div>
</div>
</div>
<p>The last two tasks are dependent on the first task. However, there is no dependence  between the last two tasks, which may execute in any order (or concurrently if  more than one thread is available). Thus, the possible outputs are  <strong>“</strong> x  + 1 = 3. x + 2 = 4.  <strong>“</strong>  and  <strong>“</strong> x + 2 = 4. x + 1 = 3.  <strong>“</strong> .  If the <code class="docutils literal notranslate"><span class="pre">depend</span></code> clauses had been omitted, then all of the tasks could execute  in any order and the program would have a race condition.</p>
</div>
<div class="section" id="matrix-multiplication">
<h3>Matrix multiplication<a class="headerlink" href="#matrix-multiplication" title="Permalink to this headline">¶</a></h3>
<p><strong>task dependences!matrix multiplication</strong></p>
<p>This example shows a task-based blocked matrix multiplication. Matrices are of  NxN elements, and the multiplication is implemented using blocks of BSxBS elements.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: task_dep.5
* type: C
* version: omp_4.0
*/
// Assume BS divides N perfectly
void matmul_depend(int N, int BS, float A[N][N], float B[N][N], float
C[N][N] )
{
   int i, j, k, ii, jj, kk;
   for (i = 0; i &lt; N; i+=BS) {
      for (j = 0; j &lt; N; j+=BS) {
         for (k = 0; k &lt; N; k+=BS) {
// Note 1: i, j, k, A, B, C are firstprivate by default
// Note 2: A, B and C are just pointers
#pragma omp task private(ii, jj, kk) \
            depend ( in: A[i:BS][k:BS], B[k:BS][j:BS] ) \
            depend ( inout: C[i:BS][j:BS] )
            for (ii = i; ii &lt; i+BS; ii++ )
               for (jj = j; jj &lt; j+BS; jj++ )
                  for (kk = k; kk &lt; k+BS; kk++ )
                     C[ii][jj] = C[ii][jj] + A[ii][kk] * B[kk][jj];
         }
      }
   }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: task_dep.5
! type: F-free
! version:    omp_4.0
! Assume BS divides N perfectly
subroutine matmul_depend (N, BS, A, B, C)
   implicit none
   integer :: N, BS, BM
   real, dimension(N, N) :: A, B, C
   integer :: i, j, k, ii, jj, kk
   BM = BS - 1
   do i = 1, N, BS
      do j = 1, N, BS
         do k = 1, N, BS
!$omp task shared(A,B,C) private(ii,jj,kk) &amp;
!$omp depend ( in: A(i:i+BM, k:k+BM), B(k:k+BM, j:j+BM) ) &amp;
!$omp depend ( inout: C(i:i+BM, j:j+BM) )
!  I,J,K are firstprivate by default
            do ii = i, i+BM
               do jj = j, j+BM
                  do kk = k, k+BM
                     C(jj,ii) = C(jj,ii) + A(kk,ii) * B(jj,kk)
                  end do
               end do
            end do
!$omp end task
         end do
      end do
   end do
end subroutine

</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="taskwait-with-dependences">
<h3><code class="docutils literal notranslate"><span class="pre">taskwait</span></code> with Dependences<a class="headerlink" href="#taskwait-with-dependences" title="Permalink to this headline">¶</a></h3>
<p><strong>task dependences!taskwait construct with <code class="docutils literal notranslate"><span class="pre">taskwait</span></code> construct with</strong> <strong>taskwait construct <code class="docutils literal notranslate"><span class="pre">taskwait</span></code> construct</strong> <strong>constructs!taskwait <code class="docutils literal notranslate"><span class="pre">taskwait</span></code></strong> <strong>taskwait construct <code class="docutils literal notranslate"><span class="pre">taskwait</span></code> construct!depend clause <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause</strong> <strong>depend clause <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause</strong> <strong>clauses!depend <code class="docutils literal notranslate"><span class="pre">depend</span></code></strong></p>
<p>In this subsection three examples illustrate how the <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause can be applied to a <code class="docutils literal notranslate"><span class="pre">taskwait</span></code> construct to make the generating task wait for specific child tasks to complete. This is an OpenMP 5.0 feature.  In the same manner that dependences can order executions among child tasks with <code class="docutils literal notranslate"><span class="pre">depend</span></code> clauses on <code class="docutils literal notranslate"><span class="pre">task</span></code> constructs, the generating task can be scheduled to wait on child tasks at a <code class="docutils literal notranslate"><span class="pre">taskwait</span></code> before it can proceed.</p>
<p>Note: Since the <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause on a <code class="docutils literal notranslate"><span class="pre">taskwait</span></code> construct relaxes the default synchronization behavior (waiting for all children to finish), it is important to realize that child tasks that are not predecessor tasks, as determined by the <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause of the <code class="docutils literal notranslate"><span class="pre">taskwait</span></code> construct, may be running concurrently while the generating task is executing after the taskwait.</p>
<p>In the first example the generating task waits at the <code class="docutils literal notranslate"><span class="pre">taskwait</span></code> construct for the completion of the first child task because a dependence on the first task is produced by  <em>x</em>  with an <code class="docutils literal notranslate"><span class="pre">in</span></code> dependence type within the <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause of the <code class="docutils literal notranslate"><span class="pre">taskwait</span></code> construct. Immediately after the first <code class="docutils literal notranslate"><span class="pre">taskwait</span></code> construct it is safe to access the  <em>x</em>  variable by the generating task, as shown in the print statement. There is no completion restraint on the second child task. Hence, immediately after the first <code class="docutils literal notranslate"><span class="pre">taskwait</span></code> it is unsafe to access the  <em>y</em>  variable since the second child task may still be executing. The second <code class="docutils literal notranslate"><span class="pre">taskwait</span></code> ensures that the second child task has completed; hence it is safe to access the  <em>y</em>  variable in the following print statement.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: task_dep.6
* type: C
* version: omp_5.0
*/
#include&lt;stdio.h&gt;

void foo()
{
    int x = 0, y = 2;

    #pragma omp task depend(inout: x) shared(x)
    x++;                                        // 1st child task

    #pragma omp task shared(y)
    y--;                                        // 2nd child task

    #pragma omp taskwait depend(in: x)          // 1st taskwait

    printf(&quot;x=%d\n&quot;,x);

    // Second task may not be finished.
    // Accessing y here will create a race condition.

    #pragma omp taskwait                        // 2nd taskwait

    printf(&quot;y=%d\n&quot;,y);
}

int main()
{
    #pragma omp parallel
    #pragma omp single
    foo();

    return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: task_dep.6
! type: F-free
! version: omp_5.0
subroutine foo()
    implicit none
    integer :: x, y

    x = 0
    y = 2

    !$omp task depend(inout: x) shared(x)
        x = x + 1                         !! 1st child task
    !$omp end task

    !$omp task shared(y)
        y = y - 1                         !! 2nd child task
    !$omp end task

    !$omp taskwait depend(in: x)          !! 1st taskwait

    print*, &quot;x=&quot;, x

    !! Second task may not be finished.
    !! Accessing y here will create a race condition.

    !$omp taskwait                        !! 2nd taskwait

    print*, &quot;y=&quot;, y

end subroutine foo

program p
    implicit none
    !$omp parallel
    !$omp single
       call foo()
    !$omp end single
    !$omp end parallel
end program p

</pre></div>
</div>
</div>
</div>
<p>In this example the first two tasks are serialized, because a dependence on the first child is produced by  <em>x</em>  with the <code class="docutils literal notranslate"><span class="pre">in</span></code> dependence type in the <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause of the second task. However, the generating task at the first <code class="docutils literal notranslate"><span class="pre">taskwait</span></code> waits only on the first child task to complete, because a dependence on only the first child task is produced by  <em>x</em>  with an <code class="docutils literal notranslate"><span class="pre">in</span></code> dependence type within the <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause of the <code class="docutils literal notranslate"><span class="pre">taskwait</span></code> construct. The second <code class="docutils literal notranslate"><span class="pre">taskwait</span></code> (without a <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause) is included to guarantee completion of the second task before  <em>y</em>  is accessed. (While unnecessary, the <code class="docutils literal notranslate"><span class="pre">depend(inout:</span></code> <code class="docutils literal notranslate"><span class="pre">y)</span></code> clause on the  2nd child task is included to illustrate how the child task dependences can be completely annotated in a data-flow model.)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: task_dep.7
* type: C
* version: omp_5.0
*/
#include&lt;stdio.h&gt;

void foo()
{
    int x = 0, y = 2;

    #pragma omp task depend(inout: x) shared(x)
    x++;                                          // 1st child task

    #pragma omp task depend(in: x) depend(inout: y) shared(x, y)
    y -= x;                                       // 2nd child task

    #pragma omp taskwait depend(in: x)            // 1st taskwait

    printf(&quot;x=%d\n&quot;,x);

    // Second task may not be finished.
    // Accessing y here would create a race condition.

    #pragma omp taskwait                          // 2nd taskwait

    printf(&quot;y=%d\n&quot;,y);

}

int main()
{
    #pragma omp parallel
    #pragma omp single
    foo();

    return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: task_dep.7
! type: F-free
! version: omp_5.0
subroutine foo()
implicit none
integer :: x, y

    x = 0
    y = 2

    !$omp task depend(inout: x) shared(x)
        x = x + 1                         !! 1st child task
    !$omp end task

    !$omp task depend(in: x) depend(inout: y) shared(x, y)
        y = y - x                         !! 2nd child task
    !$omp end task

    !$omp taskwait depend(in: x)          !! 1st taskwait

    print*, &quot;x=&quot;, x

    !! Second task may not be finished.
    !! Accessing y here would create a race condition.

    !$omp taskwait                        !! 2nd taskwait

    print*, &quot;y=&quot;, y

end subroutine foo

program p
implicit none
    !$omp parallel
    !$omp single
       call foo()
    !$omp end single
    !$omp end parallel
end program p

</pre></div>
</div>
</div>
</div>
<p>This example is similar to the previous one, except the generating task is directed to also wait for completion of the second task.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause of the <code class="docutils literal notranslate"><span class="pre">taskwait</span></code> construct now includes an <code class="docutils literal notranslate"><span class="pre">in</span></code> dependence type for  <em>y</em> .  Hence the generating task must now wait on completion of any child task having  <em>y</em>  with an <code class="docutils literal notranslate"><span class="pre">out</span></code> (here <code class="docutils literal notranslate"><span class="pre">inout</span></code>) dependence type in its <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause. So, the <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause of the <code class="docutils literal notranslate"><span class="pre">taskwait</span></code> construct now constrains the second task to complete at the <code class="docutils literal notranslate"><span class="pre">taskwait</span></code>, too. (This change makes the second <code class="docutils literal notranslate"><span class="pre">taskwait</span></code> of the previous example unnecessary– it has been removed in this example.)</p>
<p>Note: While a taskwait construct ensures that all child tasks have completed; a depend clause on a taskwait construct only waits for specific child tasks (prescribed by the dependence type and list items in the <code class="docutils literal notranslate"><span class="pre">taskwait</span></code>’s <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause). This and the previous example illustrate the need to carefully determine the dependence type of variables in the <code class="docutils literal notranslate"><span class="pre">taskwait</span></code> <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause when selecting child tasks that the generating task must wait on, so that its execution after the taskwait does not produce race conditions on variables accessed by non-completed child tasks.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: task_dep.8
* type: C
* version: omp_5.0
*/
#include&lt;stdio.h&gt;

void foo()
{
    int x = 0, y = 2;

    #pragma omp task depend(inout: x) shared(x)
    x++;                                          // 1st child task

    #pragma omp task depend(in: x) depend(inout: y) shared(x, y)
    y -= x;                                       // 2st child task

    #pragma omp taskwait depend(in: x,y)

    printf(&quot;x=%d\n&quot;,x);
    printf(&quot;y=%d\n&quot;,y);

}

int main()
{
    #pragma omp parallel
    #pragma omp single
    foo();

    return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: task_dep.8
! type: F-free
! version: omp_5.0
subroutine foo()
implicit nonE
integer :: x, y

    x = 0
    y = 2

    !$omp task depend(inout: x) shared(x)
        x = x + 1                         !! 1st child task
    !$omp end task

    !$omp task depend(in: x) depend(inout: y) shared(x, y)
        y = y - x                         !! 2nd child task
    !$omp end task

    !$omp taskwait depend(in: x,y)

    print*, &quot;x=&quot;, x
    print*, &quot;y=&quot;, y

end subroutine foo

program p
implicit none
    !$omp parallel
    !$omp single
       call foo()
    !$omp end single
    !$omp end parallel
end program p

</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="mutually-exclusive-execution-with-dependences">
<h3>Mutually Exclusive Execution with Dependences<a class="headerlink" href="#mutually-exclusive-execution-with-dependences" title="Permalink to this headline">¶</a></h3>
<p><strong>task dependences!mutually exclusive execution</strong></p>
<p>In this example we show a series of tasks, including mutually exclusive tasks, expressing dependences using the <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause on the <code class="docutils literal notranslate"><span class="pre">task</span></code> construct.</p>
<p>The program will always print 6. Tasks T1, T2 and T3 will be scheduled first, in any order. Task T4 will be scheduled after tasks T1 and T2 are completed. T5 will be scheduled after tasks T1 and T3 are completed. Due to the <code class="docutils literal notranslate"><span class="pre">mutexinoutset</span></code> dependence type on <code class="docutils literal notranslate"><span class="pre">c</span></code>, T4 and T5 may be scheduled in any order with respect to each other, but not at the same time. Tasks T6 will be scheduled after both T4 and T5 are completed.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: task_dep.9
* type: C
* version: omp_5.0
*/
#include &lt;stdio.h&gt;
int main()
{
   int a, b, c, d;
   #pragma omp parallel
   #pragma omp single
   {
      #pragma omp task depend(out: c)
         c = 1;   /* Task T1 */
      #pragma omp task depend(out: a)
         a = 2;   /* Task T2 */
      #pragma omp task depend(out: b)
         b = 3;   /* Task T3 */
      #pragma omp task depend(in: a) depend(mutexinoutset: c)
         c += a;  /* Task T4 */
      #pragma omp task depend(in: b) depend(mutexinoutset: c)
         c += b;  /* Task T5 */
      #pragma omp task depend(in: c)
         d = c;   /* Task T6 */
   }
   printf(&quot;%d\n&quot;, d);
   return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: task_dep.9
! type: F-free
! version:    omp_5.0
program example
   integer :: a, b, c, d
   !$omp parallel
   !$omp single
      !$omp task depend(out: c)
      c = 1      ! Task T1
      !$omp end task
      !$omp task depend(out: a)
      a = 2      ! Task T2
      !$omp end task
      !$omp task depend(out: b)
      b = 3      ! Task T3
      !$omp end task
      !$omp task depend(in: a) depend(mutexinoutset: c)
      c = c + a  ! Task T4
      !$omp end task
      !$omp task depend(in: b) depend(mutexinoutset: c)
      c = c + b  ! Task T5
      !$omp end task
      !$omp task depend(in: c)
      d = c      ! Task T6
      !$omp end task
   !$omp end single
   !$omp end parallel
   print *, d
end program

</pre></div>
</div>
</div>
</div>
<p>The following example demonstrates a situation where the <code class="docutils literal notranslate"><span class="pre">mutexinoutset</span></code> dependence type is advantageous. If <code class="docutils literal notranslate"><span class="pre">shortTaskB</span></code> completes before <code class="docutils literal notranslate"><span class="pre">longTaskA</span></code>, the runtime can take advantage of this by scheduling <code class="docutils literal notranslate"><span class="pre">longTaskBC</span></code> before <code class="docutils literal notranslate"><span class="pre">shortTaskAC</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: task_dep.10
* type: C
* version: omp_5.0
*/
extern int longTaskA(), shortTaskB();
extern int shortTaskAC(int,int), longTaskBC(int,int);
void foo (void)
{
  int a, b, c;
  c = 0;
  #pragma omp parallel
  #pragma omp single
  {
     #pragma omp task depend(out: a)
        a = longTaskA();
     #pragma omp task depend(out: b)
        b = shortTaskB();
     #pragma omp task depend(in: a) depend(mutexinoutset: c)
        c = shortTaskAC(a,c);
     #pragma omp task depend(in: b) depend(mutexinoutset: c)
        c = longTaskBC(b,c);
  }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: task_dep.10
! type: F-free
! version:    omp_5.0
subroutine foo
   integer :: a,b,c
   c = 0
   !$omp parallel
   !$omp single
      !$omp task depend(out: a)
         a = longTaskA()
      !$omp end task
      !$omp task depend(out: b)
         b = shortTaskB()
      !$omp end task
      !$omp task depend(in: a) depend(mutexinoutset: c)
         c = shortTaskAC(a,c)
      !$omp end task
      !$omp task depend(in: b) depend(mutexinoutset: c)
         c = longTaskBC(b,c)
      !$omp end task
   !$omp end single
   !$omp end parallel
end subroutine foo

</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="multidependences-using-iterators">
<h3>Multidependences Using Iterators<a class="headerlink" href="#multidependences-using-iterators" title="Permalink to this headline">¶</a></h3>
<p><strong>task dependences!using iterators</strong> <strong>depend clause <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause!iterator modifier <code class="docutils literal notranslate"><span class="pre">iterator</span></code> modifier</strong> <strong>iterator modifier <code class="docutils literal notranslate"><span class="pre">iterator</span></code> modifier</strong></p>
<p>The following example uses an iterator to define a dynamic number of dependences.</p>
<p>In the <code class="docutils literal notranslate"><span class="pre">single</span></code> construct of a parallel region a loop generates n tasks and each task has an <code class="docutils literal notranslate"><span class="pre">out</span></code> dependence specified through an element of the  <em>v</em>  array.  This is followed by a single task that defines an <code class="docutils literal notranslate"><span class="pre">in</span></code> dependence on each element of the array.  This is accomplished by using the <code class="docutils literal notranslate"><span class="pre">iterator</span></code> modifier in the <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause, supporting a dynamic number of dependences ( <em>n</em>  here).</p>
<p>The task for the  <em>print_all_elements</em>  function is not executed until all dependences prescribed (or registered) by the iterator are fulfilled; that is, after all the tasks generated by the loop have completed.</p>
<p>Note, one cannot simply use an array section in the <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause of the second task construct because this would violate the <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause restriction:</p>
<p>“List items used in <code class="docutils literal notranslate"><span class="pre">depend</span></code> clauses of the same task or sibling tasks must indicate identical storage locations or disjoint storage locations”.</p>
<p>In this case each of the loop tasks use a single disjoint (different storage) element in their <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause; however, the array-section storage area prescribed in the commented directive is neither identical nor disjoint to the storage prescribed by the elements of the loop tasks.  The iterator overcomes this restriction by effectively creating n disjoint storage areas.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name:       task_dep.11
* type:       C
* version: omp_5.0
*/
#include&lt;stdio.h&gt;

void set_an_element(int *p, int val) {
    *p = val;
}

void print_all_elements(int *v, int n) {
    int i;
    for (i = 0; i &lt; n; ++i) {
        printf(&quot;%d, &quot;, v[i]);
    }
    printf(&quot;\n&quot;);
}

void parallel_computation(int n) {
    int v[n];
    #pragma omp parallel
    #pragma omp single
    {
        int i;
        for (i = 0; i &lt; n; ++i)
            #pragma omp task depend(out: v[i])
            set_an_element(&amp;v[i], i);

        #pragma omp task depend(iterator(it = 0:n), in: v[it])
     // The following violates array-section restriction:
     // #pragma omp task depend(in: v[0:n])
        print_all_elements(v, n);
    }
}


</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: task_dep.11
! type: F-free
! version:    omp_5.0
subroutine set_an_element(e, val)
    implicit none
    integer :: e, val

    e = val

end subroutine

subroutine print_all_elements(v, n)
    implicit none
    integer :: n, v(n)

    print *, v

end subroutine

subroutine parallel_computation(n)
    implicit none
    integer :: n
    integer :: i, v(n)

    !$omp parallel
    !$omp single
        do i=1, n
            !$omp task depend(out: v(i))
                 call set_an_element(v(i), i)
            !$omp end task
        enddo

        !$omp task depend(iterator(it = 1:n), in: v(it))
       !!$omp task depend(in: v(1:n)) Violates Array section restriction.
            call print_all_elements(v, n)
        !$omp end task

    !$omp end single
    !$omp end parallel
end subroutine

</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="dependence-for-undeferred-tasks">
<h3>Dependence for Undeferred Tasks<a class="headerlink" href="#dependence-for-undeferred-tasks" title="Permalink to this headline">¶</a></h3>
<p><strong>task dependences!undeferred tasks</strong></p>
<p>In the following example, we show that even if a task is undeferred as specified by an <code class="docutils literal notranslate"><span class="pre">if</span></code> clause that evaluates to  <em>false</em> , task dependences are still honored.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">depend</span></code> clauses of the first and second explicit tasks specify that the first task is completed before the second task.</p>
<p>The second explicit task has an <code class="docutils literal notranslate"><span class="pre">if</span></code> clause that evaluates to  <em>false</em> . This means that the execution of the generating task (the implicit task of the <code class="docutils literal notranslate"><span class="pre">single</span></code> region) must be suspended until the second explicit task is completed. But, because of the dependence, the first explicit task must complete first, then the second explicit task can execute and complete, and only then  the generating task can resume to the print statement. Thus, the program will always print ” <strong>x = 2</strong> “.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: task_dep.12
* type: C
* version: omp_4.0
*/
#include &lt;stdio.h&gt;
int main (int argc, char *argv[])
{
  int x = 0;
  #pragma omp parallel
  #pragma omp single
  {
    /* first explicit task */
    #pragma omp task shared(x) depend(out: x)
      x = 1;

    /* second explicit task */
    #pragma omp task shared(x) depend(inout: x) if(0)
      x = 2;

    /* statement executed by parent implicit task
       prints: x = 2 */
    printf(&quot;x = %d\n&quot;, x);
  }
  return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: task_dep.12
! type: F-free
! version: omp_4.0
program example
   integer :: x
   x = 0
   !$omp parallel
   !$omp single
     !... first explicit task
      !$omp task shared(x) depend(out: x)
         x = 1
      !$omp end task

     !... second explicit task
      !$omp task shared(x) depend(inout: x) if(.false.)
         x = 2
      !$omp end task

     !... statement executed by parent implicit task
     ! prints: x = 2
      print*, &quot;x = &quot;, x
   !$omp end single
   !$omp end parallel
end program

</pre></div>
</div>
</div>
</div>
<p>In OpenMP 5.1 the <code class="docutils literal notranslate"><span class="pre">omp_all_memory</span></code>  <em>reserved locator</em>  was introduced to specify storage of all objects in memory. In the following example, it is used in Task 4 as a convenient way to specify that the locator (list item) denotes the storage of all objects (locations) in memory, and  will therefore match the  <em>a</em>  and  <em>d</em>  locators of Task 2, Task 3 and Task 6. The dependences guarantee the ordered execution of Tasks 2 and 3 before 4, and Task 4 before Task 6. Since there are no dependences imposed on Task 1 and Task 5, they can be scheduled to execute at any time, with no ordering.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name:       task_dep.13
* type:       C
* version:    omp_5.1
*/
#include &lt;stdio.h&gt;

int main(){
   int a=1, d=1;

   #pragma omp parallel masked num_threads(5)
   {
      #pragma omp task                               // Task 1
      { printf(&quot;T1\n&quot;); }

      #pragma omp task depend(out: a)                // Task 2
      { a++;
        printf(&quot;T2 a=%i\n&quot;, a); }

      #pragma omp task depend(out: d)                // Task 3
      { d++;
        printf(&quot;T3 d=%i\n&quot;, d); }

      #pragma omp task depend(inout: omp_all_memory) // Task 4
      { a++; d++;
        printf(&quot;T4 a=%i d=%i\n&quot;,   a,d);}

      #pragma omp task                               // Task 5
      { printf(&quot;T5\n&quot;); }

      #pragma omp task depend(in: a,d)               // Task 6
      { a++; d++;
        printf(&quot;T6 a=%i d=%i\n&quot;, a,d); }
   }
}

/* OUTPUT: ordered {T2,T3 any order}, {T4}, {T6}
    T2 a=2
    T3 d=2
    T4 a=3 d=3
    T6 a=4 d=4

  OUTPUT: unordered (can appear interspersed in ordered output)
    T1
    T5
*/

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: task_dep.13
! type: F-free
! version: omp_5.1
program main
  integer :: a=1, d=1

  !$omp parallel masked  num_threads(5)

    !$omp task                                 !! Task 1
       write(*,&#39;(&quot;T1&quot;)&#39;)
    !$omp end task

    !$omp task depend(out: a)                  !! Task 2
       a=a+1
       write(*,&#39;(&quot;T2 a=&quot;,i1)&#39;) a
    !$omp end task

    !$omp task depend(out: d)                  !! Task 3
       d=d+1
       write(*,&#39;(&quot;T3 d=&quot;,i1)&#39;) d
    !$omp end task


    !$omp task depend(inout: omp_all_memory)   !! Task 4
       a=a+1; d=d+1
       write(*,&#39;(&quot;T4 a=&quot;,i1,&quot; d=&quot;,i1)&#39;) a, d
    !$omp end task

    !$omp task                                 !! Task 5
       write(*,&#39;(&quot;T5&quot;)&#39;)
    !$omp end task

    !$omp task depend(in: a,d)                 !! Task 6
       a=a+1; d=d+1
       write(*,&#39;(&quot;T6 a=&quot;,i1,&quot; d=&quot;,i1)&#39;) a, d
    !$omp end task

  !$omp end parallel masked

end program

! OUTPUT: ordered  {T2,T3 any order}, {T4}, {T6}
! T2 a=2
! T3 d=2
! T4 a=3 d=3
! T6 a=4 d=4
! OUTPUT: unordered (can appear interspersed in ordered output)
! T1
! T5

</pre></div>
</div>
</div>
</div>
<p>../../tasking/task_dep.tex</p>
</div>
</div>
<div class="section" id="task-detachment">
<h2>Task Detachment<a class="headerlink" href="#task-detachment" title="Permalink to this headline">¶</a></h2>
<p><strong>task construct <code class="docutils literal notranslate"><span class="pre">task</span></code> construct!detach clause <code class="docutils literal notranslate"><span class="pre">detach</span></code> clause</strong> <strong>detach clause <code class="docutils literal notranslate"><span class="pre">detach</span></code> clause</strong> <strong>clauses!detach <code class="docutils literal notranslate"><span class="pre">detach</span></code></strong> <strong>routines!omp_fulfill_event <code class="docutils literal notranslate"><span class="pre">omp_fulfill_event</span></code></strong> <strong>omp_fulfill_event routine <code class="docutils literal notranslate"><span class="pre">omp_fulfill_event</span></code> routine</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">detach</span></code> clause on a <code class="docutils literal notranslate"><span class="pre">task</span></code> construct provides a mechanism for an asynchronous routine to be called within a task block, and for the routine’s callback to signal completion to the OpenMP runtime, through an  event fulfillment, triggered by a call to the <code class="docutils literal notranslate"><span class="pre">omp_fulfill_event</span></code> routine. When a <code class="docutils literal notranslate"><span class="pre">detach</span></code> clause is used on a task construct, completion of the <strong>detachable</strong> task occurs when the task’s structured block is completed AND an  <em>allow-completion</em>  event is fulfilled by a call to the <code class="docutils literal notranslate"><span class="pre">omp_fulfill_event</span></code>  routine with the  <em>event-handle</em>  argument.</p>
<p>The first example illustrates the basic components used in a detachable task. The second example is a program that executes asynchronous IO, and illustrates  methods that are also inherent in asynchronous messaging within MPI and asynchronous commands in  streams within GPU codes. Interfaces to asynchronous operations found in IO, MPI and GPU parallel computing platforms and their programming models are not standardized.</p>
<hr class="docutils" />
<p>The first example creates a detachable task that executes the asynchronous  <em>async_work</em>  routine, passing the  <em>omp_fulfill_event</em>  function and the (firstprivate) event handle to the function. Here, the <code class="docutils literal notranslate"><span class="pre">omp_fulfill_event</span></code> function is the “callback’’ function to be executed at the end of the  <em>async_work</em>  function’s asynchronous operations, with the associated data,  <em>event</em> .</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name:       task_detach.1
* type:       C
* version:    omp_5.0
*/
#include &lt;omp.h&gt;

void async_work(void (*)(void*), void*);
void work();

int main() {
  int async=1;
  #pragma omp parallel
  #pragma omp masked
  {

    omp_event_handle_t event;
    #pragma omp task detach(event)
    {
      if(async) {
        async_work( (void (*)(void*)) omp_fulfill_event, (void*) event );
      } else {
        work();
        omp_fulfill_event(event);
      }
    }
                  // Other work
    #pragma omp taskwait
  }
  return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: task_detach.1
! type: F-free
! version:    omp_5.0
program main
  use omp_lib
  implicit none

  external :: async_work, work

  logical :: async=.true.
  integer(omp_event_handle_kind) :: event

  !$omp parallel
  !$omp masked

    !$omp task detach(event)

      if(async) then
        call async_work(omp_fulfill_event, event)
      else
        call work()
        call omp_fulfill_event(event)
      endif

    !$omp end task
                  !! Other work

    !$omp taskwait

  !$omp end masked
  !$omp end parallel

end program

</pre></div>
</div>
</div>
</div>
<p>In the following example, text data is written asynchronously to the file  <em>async_data</em> , using POSIX asynchronous IO (aio). An aio “control block’’,  <em>cb</em> , is set up to send a signal when IO is complete, and the  <em>sigaction</em>  function registers the signal action, a callback to  <em>callback_aioSigHandler</em> .</p>
<p>The first task (TASK1) starts the asynchronous IO and runs as a detachable task. The second and third tasks (TASK2 and TASK3) perform synchronous IO to stdout with print statements. The difference between the two types of tasks is that the thread for TASK1 is freed for  other execution within the parallel region, while the threads for TASK2 and TASK3 wait on the (synchronous) IO to complete, and cannot perform other work while the  operating system is performing the synchronous IO.  The <code class="docutils literal notranslate"><span class="pre">if</span></code> clause ensures that the detachable task is launched  and the call to the  <em>aio_write</em>  function returns before TASK2 and TASK3 are generated (while the async IO occurs in the “background’’ and eventually executes the callback function).  The barrier at the end of the parallel region ensures that the detachable task has completed.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name:       task_detach.2
* type:       C
* version:    omp_5.0
*/

// use -lrt on loader line
#include  &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include  &lt;fcntl.h&gt;
#include    &lt;aio.h&gt;
#include  &lt;errno.h&gt;
#include &lt;signal.h&gt;

#include    &lt;omp.h&gt;

#define IO_SIGNAL SIGUSR1        // Signal used to notify I/O completion

                                 // Handler for I/O completion signal
static void callback_aioSigHandler(int sig, siginfo_t *si,
                                   void *ucontext) {
   if (si-&gt;si_code == SI_ASYNCIO){
      printf( &quot;OUT: I/O completion signal received.\n&quot;);
      omp_fulfill_event( (omp_event_handle_t)(si-&gt;si_value.sival_ptr) );
   }
}

void work(int i){ printf(&quot;OUT: Executing work(%d)\n&quot;, i);}

int main() {
   // Write &quot;Written Asynchronously.&quot; to file data, using POSIX
   // asynchronous IO. Error checking not included for clarity
   // and simplicity.

   char      data[] = &quot;Written Asynchronously.&quot;;

   struct     aiocb cb;
   struct sigaction sa;

   omp_event_handle_t event;

   int fd = open(  &quot;async_data&quot;, O_CREAT|O_RDWR|O_TRUNC,0664);

   // Setup async io (aio) control block (cb)
   cb.aio_nbytes  = sizeof(data)-1;
   cb.aio_fildes  = fd;
   cb.aio_buf     = data;
   cb.aio_reqprio = 0;
   cb.aio_offset  = 0;
   cb.aio_sigevent.sigev_notify = SIGEV_SIGNAL;
   cb.aio_sigevent.sigev_signo  = IO_SIGNAL;

   // Setup Signal Handler  Callback
   sigemptyset(&amp;sa.sa_mask);
   sa.sa_flags = SA_RESTART | SA_SIGINFO;
   sa.sa_sigaction = callback_aioSigHandler;   //callback
   sigaction(IO_SIGNAL, &amp;sa, NULL);

   #pragma omp parallel num_threads(2)
   #pragma omp masked
   {

      #pragma omp task detach(event) if(0)               // TASK1
      {
         cb.aio_sigevent.sigev_value.sival_ptr = (void *) event;
         aio_write(&amp;cb);
      }

      #pragma omp task                                   // TASK2
         work(1);
      #pragma omp task                                   // TASK3
         work(2);

   } // Parallel region barrier ensures completion of detachable task.

   // Making sure the aio operation completed.
   // With OpenMP detachable task the condition will always be false:
   while(aio_error(&amp;cb) == EINPROGRESS) {
   printf(&quot; INPROGRESS\n&quot;);} //Safeguard

   close(fd);
   return 0;
}
/* Any Order:
OUT: I/O completion signal received.
OUT: Executing work(1)
OUT: Executing work(2)
*/

</pre></div>
</div>
</div>
</div>
<p>../../tasking/task_detach.tex</p>
</div>
<div class="section" id="taskgroup-construct">
<h2><code class="docutils literal notranslate"><span class="pre">taskgroup</span></code> Construct<a class="headerlink" href="#taskgroup-construct" title="Permalink to this headline">¶</a></h2>
<p><strong>constructs!taskgroup <code class="docutils literal notranslate"><span class="pre">taskgroup</span></code></strong> <strong>taskgroup construct <code class="docutils literal notranslate"><span class="pre">taskgroup</span></code> construct</strong></p>
<p>In this example, tasks are grouped and synchronized using the <code class="docutils literal notranslate"><span class="pre">taskgroup</span></code>  construct.</p>
<p>Initially, one task (the task executing the <code class="docutils literal notranslate"><span class="pre">start_background_work()</span></code>  call) is created in the <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region, and later a parallel tree traversal  is started (the task executing the root of the recursive <code class="docutils literal notranslate"><span class="pre">compute_tree()</span></code>  calls). While synchronizing tasks at the end of each tree traversal, using the  <code class="docutils literal notranslate"><span class="pre">taskgroup</span></code> construct ensures that the formerly started background task  does not participate in the synchronization and is left free to execute in parallel.  This is opposed to the behavior of the <code class="docutils literal notranslate"><span class="pre">taskwait</span></code> construct, which would  include the background tasks in the synchronization.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: taskgroup.1
* type: C
* version: omp_4.0
*/
extern void start_background_work(void);
extern void check_step(void);
extern void print_results(void);
struct tree_node
{
   struct tree_node *left;
   struct tree_node *right;
};
typedef struct tree_node* tree_type;
extern void init_tree(tree_type);
#define max_steps 100
void compute_something(tree_type tree)
{
   // some computation
}
void compute_tree(tree_type tree)
{
   if (tree-&gt;left)
   {
     #pragma omp task
       compute_tree(tree-&gt;left);
   }
   if (tree-&gt;right)
   {
     #pragma omp task
       compute_tree(tree-&gt;right);
   }
   #pragma omp task
   compute_something(tree);
}
int main()
{
  int i;
  tree_type tree;
  init_tree(tree);
  #pragma omp parallel
  #pragma omp single
  {
    #pragma omp task
      start_background_work();
    for (i = 0; i &lt; max_steps; i++)
    {
        #pragma omp taskgroup
        {
           #pragma omp task
             compute_tree(tree);
        } // wait on tree traversal in this step
        check_step();
    }
  } // only now is background work required to be complete
  print_results();
  return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: taskgroup.1
! type: F-free
! version:    omp_4.0
module tree_type_mod
  integer, parameter :: max_steps=100
  type tree_type
    type(tree_type), pointer :: left, right
  end type
  contains
    subroutine compute_something(tree)
      type(tree_type), pointer :: tree
! some computation
    end subroutine
    recursive subroutine compute_tree(tree)
      type(tree_type), pointer :: tree
      if (associated(tree%left)) then
!$omp task
        call compute_tree(tree%left)
!$omp end task
      endif
      if (associated(tree%right)) then
!$omp task
        call compute_tree(tree%right)
!$omp end task
      endif
!$omp task
      call compute_something(tree)
!$omp end task
    end subroutine
end module
program main
  use tree_type_mod
  type(tree_type), pointer :: tree
  call init_tree(tree);
!$omp parallel
!$omp single
!$omp task
  call start_background_work()
!$omp end task
  do i=1, max_steps
!$omp taskgroup
!$omp task
    call compute_tree(tree)
!$omp end task
!$omp end taskgroup ! wait on tree traversal in this step
    call check_step()
  enddo
!$omp end single
!$omp end parallel    ! only now is background work required to be complete
  call print_results()
end program

</pre></div>
</div>
</div>
</div>
<p>../../tasking/taskgroup.tex</p>
</div>
<div class="section" id="taskyield-construct">
<h2><code class="docutils literal notranslate"><span class="pre">taskyield</span></code> Construct<a class="headerlink" href="#taskyield-construct" title="Permalink to this headline">¶</a></h2>
<p><strong>constructs!taskyield <code class="docutils literal notranslate"><span class="pre">taskyield</span></code></strong> <strong>taskyield construct <code class="docutils literal notranslate"><span class="pre">taskyield</span></code> construct</strong></p>
<p>The following example illustrates the use of the <code class="docutils literal notranslate"><span class="pre">taskyield</span></code>  directive.  The tasks in the example compute something useful and then do some computation  that must be done in a critical region. By using <code class="docutils literal notranslate"><span class="pre">taskyield</span></code> when a task  cannot get access to the <code class="docutils literal notranslate"><span class="pre">critical</span></code> region the implementation can suspend  the current task and schedule some other task that can do something useful.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: taskyield.1
* type: C
* version: omp_3.1
*/
#include &lt;omp.h&gt;

void something_useful ( void );
void something_critical ( void );
void foo ( omp_lock_t * lock, int n )
{
   int i;

   for ( i = 0; i &lt; n; i++ )
      #pragma omp task
      {
          something_useful();
          while ( !omp_test_lock(lock) ) {
             #pragma omp taskyield
          }
          something_critical();
          omp_unset_lock(lock);
      }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: taskyield.1
! type: F-free
! version:    omp_3.1
subroutine foo ( lock, n )
   use omp_lib
   integer (kind=omp_lock_kind) :: lock
   integer n
   integer i

   do i = 1, n
     !$omp task
       call something_useful()
       do while ( .not. omp_test_lock(lock) )
         !$omp taskyield
       end do
       call something_critical()
       call omp_unset_lock(lock)
     !$omp end task
   end do

end subroutine

</pre></div>
</div>
</div>
</div>
<p>../../tasking/taskyield.tex</p>
</div>
<div class="section" id="taskloop-construct">
<h2><code class="docutils literal notranslate"><span class="pre">taskloop</span></code> Construct<a class="headerlink" href="#taskloop-construct" title="Permalink to this headline">¶</a></h2>
<p><strong>constructs!taskloop <code class="docutils literal notranslate"><span class="pre">taskloop</span></code></strong> <strong>taskloop construct <code class="docutils literal notranslate"><span class="pre">taskloop</span></code> construct</strong> <strong>taskloop construct <code class="docutils literal notranslate"><span class="pre">taskloop</span></code> construct!grainsize clause <code class="docutils literal notranslate"><span class="pre">grainsize</span></code> clause</strong> <strong>taskloop construct <code class="docutils literal notranslate"><span class="pre">taskloop</span></code> construct!nogroup clause <code class="docutils literal notranslate"><span class="pre">nogroup</span></code> clause</strong> <strong>clauses!grainsize <code class="docutils literal notranslate"><span class="pre">grainsize</span></code></strong> <strong>grainsize clause <code class="docutils literal notranslate"><span class="pre">grainsize</span></code> clause</strong> <strong>clauses!nogroup <code class="docutils literal notranslate"><span class="pre">nogroup</span></code></strong> <strong>nogroup clause <code class="docutils literal notranslate"><span class="pre">nogroup</span></code> clause</strong></p>
<p>The following example illustrates how to execute a long running task concurrently with tasks created with a <code class="docutils literal notranslate"><span class="pre">taskloop</span></code> directive for a loop having unbalanced amounts of work for its iterations.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">grainsize</span></code> clause specifies that each task is to execute at least 500 iterations of the loop.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">nogroup</span></code> clause removes the implicit taskgroup of the <code class="docutils literal notranslate"><span class="pre">taskloop</span></code> construct; the explicit <code class="docutils literal notranslate"><span class="pre">taskgroup</span></code> construct in the example ensures that the function is not exited before the long-running task and the loops have finished execution.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: taskloop.1
* type: C
* version: omp_4.5
*/
void long_running_task(void);
void loop_body(int i, int j);

void parallel_work(void) {
   int i, j;
#pragma omp taskgroup
   {
#pragma omp task
      long_running_task(); // can execute concurrently

#pragma omp taskloop private(j) grainsize(500) nogroup
      for (i = 0; i &lt; 10000; i++) { // can execute concurrently
         for (j = 0; j &lt; i; j++) {
            loop_body(i, j);
         }
      }
   }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: taskloop.1
! type: F-free
! version:    omp_4.5
subroutine parallel_work
   integer i
   integer j
!$omp taskgroup

!$omp task
   call long_running_task()
!$omp end task

!$omp taskloop private(j) grainsize(500) nogroup
   do i=1,10000
      do j=1,i
         call loop_body(i, j)
      end do
   end do
!$omp end taskloop

!$omp end taskgroup
end subroutine

</pre></div>
</div>
</div>
</div>
<p>Because a <code class="docutils literal notranslate"><span class="pre">taskloop</span></code> construct encloses a loop, it is often incorrectly  perceived as a worksharing construct (when it is directly nested in  a <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region).</p>
<p>While a worksharing construct distributes the loop iterations across all threads in a team, the entire loop of a <code class="docutils literal notranslate"><span class="pre">taskloop</span></code> construct is executed by every thread of the team.</p>
<p>In the example below the first taskloop occurs closely nested within  a <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region and the entire loop is executed by each of the  <em>T</em>  threads;  hence the reduction sum is executed  <em>T</em> * <em>N</em>  times.</p>
<p>The loop of the second taskloop is within a <code class="docutils literal notranslate"><span class="pre">single</span></code> region and is executed by a single thread so that only  <em>N</em>  reduction sums occur.  (The other  <em>N</em> -1 threads of the <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region will participate in executing the  tasks. This is the common use case for the <code class="docutils literal notranslate"><span class="pre">taskloop</span></code> construct.)</p>
<p>In the example, the code thus prints <code class="docutils literal notranslate"><span class="pre">x1</span> <span class="pre">=</span> <span class="pre">16384</span></code> ( <em>T</em> * <em>N</em> ) and  <code class="docutils literal notranslate"><span class="pre">x2</span> <span class="pre">=</span> <span class="pre">1024</span></code> ( <em>N</em> ).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name:   taskloop.2
* type:   C
* version: omp_4.5
*/
#include &lt;stdio.h&gt;

#define T 16
#define N 1024

void parallel_work() {
    int x1 = 0, x2 = 0;

    #pragma omp parallel shared(x1,x2) num_threads(T)
    {
        #pragma omp taskloop
        for (int i = 0; i &lt; N; ++i) {
            #pragma omp atomic
            x1++;          // executed T*N times
        }

        #pragma omp single
        #pragma omp taskloop
        for (int i = 0; i &lt; N; ++i) {
            #pragma omp atomic
            x2++;          // executed N times
        }
    }

    printf(&quot;x1 = %d, x2 = %d\n&quot;, x1, x2);
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name:   taskloop.2
! type:   F-free
! version: omp_4.5
subroutine parallel_work
    implicit none
    integer :: x1, x2
    integer :: i
    integer, parameter :: T = 16
    integer, parameter :: N = 1024

    x1 = 0
    x2 = 0
    !$omp parallel shared(x1,x2) num_threads(T)
    !$omp taskloop
    do i = 1,N
        !$omp atomic
        x1 = x1 + 1     ! executed T*N times
        !$omp end atomic
    end do
    !$omp end taskloop

    !$omp single
    !$omp taskloop
    do i = 1,N
        !$omp atomic
        x2 = x2 + 1     ! executed N times
        !$omp end atomic
    end do
    !$omp end taskloop
    !$omp end single
    !$omp end parallel

    write (*,&#39;(A,I0,A,I0)&#39;) &#39;x1 = &#39;, x1, &#39;, x2 = &#39;,x2
end subroutine

</pre></div>
</div>
</div>
</div>
<p>../../tasking/taskloop.tex</p>
</div>
<div class="section" id="combined-parallel-masked-and-taskloop-constructs">
<h2>Combined <code class="docutils literal notranslate"><span class="pre">parallel</span></code> <code class="docutils literal notranslate"><span class="pre">masked</span></code> and <code class="docutils literal notranslate"><span class="pre">taskloop</span></code> Constructs<a class="headerlink" href="#combined-parallel-masked-and-taskloop-constructs" title="Permalink to this headline">¶</a></h2>
<p><strong>combined constructs!parallel masked taskloop <code class="docutils literal notranslate"><span class="pre">parallel</span></code> <code class="docutils literal notranslate"><span class="pre">masked</span></code> <code class="docutils literal notranslate"><span class="pre">taskloop</span></code></strong> <strong>combined constructs!parallel masked taskloop simd <code class="docutils literal notranslate"><span class="pre">parallel</span></code> <code class="docutils literal notranslate"><span class="pre">masked</span></code> <code class="docutils literal notranslate"><span class="pre">taskloop</span></code> <code class="docutils literal notranslate"><span class="pre">simd</span></code></strong> <strong>constructs!parallel <code class="docutils literal notranslate"><span class="pre">parallel</span></code></strong> <strong>constructs!masked <code class="docutils literal notranslate"><span class="pre">masked</span></code></strong> <strong>constructs!taskloop <code class="docutils literal notranslate"><span class="pre">taskloop</span></code></strong> <strong>constructs!simd <code class="docutils literal notranslate"><span class="pre">simd</span></code></strong> <strong>parallel construct <code class="docutils literal notranslate"><span class="pre">parallel</span></code> construct</strong> <strong>masked construct <code class="docutils literal notranslate"><span class="pre">masked</span></code> construct</strong> <strong>taskloop construct <code class="docutils literal notranslate"><span class="pre">taskloop</span></code> construct</strong> <strong>simd construct <code class="docutils literal notranslate"><span class="pre">simd</span></code> construct</strong></p>
<p>Just as the <code class="docutils literal notranslate"><span class="pre">for</span></code> and <code class="docutils literal notranslate"><span class="pre">do</span></code> constructs were combined with the <code class="docutils literal notranslate"><span class="pre">parallel</span></code> construct for convenience, so too, the combined <code class="docutils literal notranslate"><span class="pre">parallel</span></code> <code class="docutils literal notranslate"><span class="pre">masked</span></code> <code class="docutils literal notranslate"><span class="pre">taskloop</span></code> and  <code class="docutils literal notranslate"><span class="pre">parallel</span></code> <code class="docutils literal notranslate"><span class="pre">masked</span></code> <code class="docutils literal notranslate"><span class="pre">taskloop</span></code> <code class="docutils literal notranslate"><span class="pre">simd</span></code> constructs have been created for convenience when using the <code class="docutils literal notranslate"><span class="pre">taskloop</span></code> construct.</p>
<p>In the following example the first <code class="docutils literal notranslate"><span class="pre">taskloop</span></code> construct is enclosed by the usual <code class="docutils literal notranslate"><span class="pre">parallel</span></code> and <code class="docutils literal notranslate"><span class="pre">masked</span></code> constructs to form a team of threads, and a single task generator (primary thread) for the <code class="docutils literal notranslate"><span class="pre">taskloop</span></code> construct.</p>
<p>The same OpenMP operations for the first taskloop are accomplished by the second taskloop with the <code class="docutils literal notranslate"><span class="pre">parallel</span></code> <code class="docutils literal notranslate"><span class="pre">masked</span></code> <code class="docutils literal notranslate"><span class="pre">taskloop</span></code>  combined construct.  The third taskloop uses the combined <code class="docutils literal notranslate"><span class="pre">parallel</span></code> <code class="docutils literal notranslate"><span class="pre">masked</span></code> <code class="docutils literal notranslate"><span class="pre">taskloop</span></code> <code class="docutils literal notranslate"><span class="pre">simd</span></code>  construct to accomplish the same behavior as closely nested <code class="docutils literal notranslate"><span class="pre">parallel</span> <span class="pre">masked</span></code>, and <code class="docutils literal notranslate"><span class="pre">taskloop</span> <span class="pre">simd</span></code> constructs.</p>
<p>As with any combined construct the clauses of the components may be used with appropriate restrictions. The combination of the <code class="docutils literal notranslate"><span class="pre">parallel</span></code> <code class="docutils literal notranslate"><span class="pre">masked</span></code> construct with the <code class="docutils literal notranslate"><span class="pre">taskloop</span></code> or <code class="docutils literal notranslate"><span class="pre">taskloop</span></code> <code class="docutils literal notranslate"><span class="pre">simd</span></code> construct produces no additional  restrictions.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: parallel_masked_taskloop.1
* type: C
* version: omp_5.1
*/
#include &lt;stdio.h&gt;
#define N 100

int main()
{
   int i, a[N],b[N],c[N];

   for(int i=0; i&lt;N; i++){ b[i]=i; c[i]=i; }  //init

   #pragma omp parallel
   #pragma omp masked
   #pragma omp taskloop                      // taskloop 1
   for(i=0;i&lt;N;i++){ a[i] = b[i] + c[i]; }

   #pragma omp parallel masked taskloop      // taskloop 2
   for(i=0;i&lt;N;i++){ b[i] = a[i] + c[i]; }

   #pragma omp parallel masked taskloop simd // taskloop 3
   for(i=0;i&lt;N;i++){ c[i] = a[i] + b[i]; }

   printf(&quot; %d %d\n&quot;,c[0],c[N-1]);  // 0 and 495
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name:       parallel_masked_taskloop.1
! type:       F-free
! version:    omp_5.1
program main

   integer, parameter :: N=100
   integer :: i, a(N),b(N),c(N)

   do i=1,N                            !! initialize
      b(i) = i
      c(i) = i
   enddo

   !$omp parallel
   !$omp masked
   !$omp taskloop                      !! taskloop 1
   do i=1,N
      a(i) = b(i) + c(i)
   enddo
   !$omp end taskloop
   !$omp end masked
   !$omp end parallel

   !$omp parallel masked taskloop      !! taskloop 2
   do i=1,N
      b(i) = a(i) + c(i)
   enddo
   !$omp end parallel masked taskloop

   !$omp parallel masked taskloop simd !! taskloop 3
   do i=1,N
      c(i) = a(i) + b(i)
   enddo
   !$omp end parallel masked taskloop simd

   print*,c(1),c(N)  !! 5 and 500

end program

</pre></div>
</div>
</div>
</div>
<p>../../tasking/parallel_masked_taskloop.tex</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "native"
        },
        kernelOptions: {
            kernelName: "native",
            path: "./contents"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'native'</script>

              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="Chap_affinity.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">OpenMP Affinity</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="Chap_devices.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">&lt;no title&gt;</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      By The OpenMP Community<br/>
    
        &copy; Copyright 2021.<br/>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>