
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Synchronization &#8212; OpenMP Application Programming Interface Examples</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet">
  <link href="../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script>
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Data Environment" href="Chap_data_environment.html" />
    <link rel="prev" title="&lt;no title&gt;" href="Chap_loop_transformations.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">OpenMP Application Programming Interface Examples</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../intro.html">
   Welcome to OMP Jupyter Book
  </a>
 </li>
</ul>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_directives.html">
   OpenMP Directive Syntax
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_parallel_execution.html">
   Parallel Execution
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_affinity.html">
   OpenMP Affinity
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_tasking.html">
   Tasking
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_SIMD.html">
   SIMD
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Synchronization
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_data_environment.html">
   Data Environment
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_memory_model.html">
   Memory Model
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_program_control.html">
   Program Control
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/contents/Chap_synchronization.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
                onclick="printPdf(this)" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/passlab/Examples"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/passlab/Examples/issues/new?title=Issue%20on%20page%20%2Fcontents/Chap_synchronization.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/passlab/Examples/main?urlpath=lab/tree/notebook/contents/Chap_synchronization.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#critical-construct">
   <code class="docutils literal notranslate">
    <span class="pre">
     critical
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#worksharing-constructs-inside-a-critical-construct">
   Worksharing Constructs Inside a
   <code class="docutils literal notranslate">
    <span class="pre">
     critical
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#binding-of-barrier-regions">
   Binding of
   <code class="docutils literal notranslate">
    <span class="pre">
     barrier
    </span>
   </code>
   Regions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#atomic-construct">
   <code class="docutils literal notranslate">
    <span class="pre">
     atomic
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#restrictions-on-the-atomic-construct">
   Restrictions on the
   <code class="docutils literal notranslate">
    <span class="pre">
     atomic
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#flush-construct-without-a-list">
   <code class="docutils literal notranslate">
    <span class="pre">
     flush
    </span>
   </code>
   Construct without a List
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#synchronization-based-on-acquire-release-semantics">
   Synchronization Based on Acquire/Release Semantics
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#ordered-clause-and-ordered-construct">
   <code class="docutils literal notranslate">
    <span class="pre">
     ordered
    </span>
   </code>
   Clause and
   <code class="docutils literal notranslate">
    <span class="pre">
     ordered
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#depobj-construct">
   <code class="docutils literal notranslate">
    <span class="pre">
     depobj
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#doacross-loop-nest">
   Doacross Loop Nest
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#lock-routines">
   Lock Routines
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#omp-init-lock-routine">
     <code class="docutils literal notranslate">
      <span class="pre">
       omp_init_lock
      </span>
     </code>
     Routine
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#omp-init-lock-with-hint-routine">
     <code class="docutils literal notranslate">
      <span class="pre">
       omp_init_lock_with_hint
      </span>
     </code>
     Routine
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#ownership-of-locks">
     Ownership of Locks
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#simple-lock-routines">
     Simple Lock Routines
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#nestable-lock-routines">
     Nestable Lock Routines
    </a>
   </li>
  </ul>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Synchronization</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#critical-construct">
   <code class="docutils literal notranslate">
    <span class="pre">
     critical
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#worksharing-constructs-inside-a-critical-construct">
   Worksharing Constructs Inside a
   <code class="docutils literal notranslate">
    <span class="pre">
     critical
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#binding-of-barrier-regions">
   Binding of
   <code class="docutils literal notranslate">
    <span class="pre">
     barrier
    </span>
   </code>
   Regions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#atomic-construct">
   <code class="docutils literal notranslate">
    <span class="pre">
     atomic
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#restrictions-on-the-atomic-construct">
   Restrictions on the
   <code class="docutils literal notranslate">
    <span class="pre">
     atomic
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#flush-construct-without-a-list">
   <code class="docutils literal notranslate">
    <span class="pre">
     flush
    </span>
   </code>
   Construct without a List
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#synchronization-based-on-acquire-release-semantics">
   Synchronization Based on Acquire/Release Semantics
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#ordered-clause-and-ordered-construct">
   <code class="docutils literal notranslate">
    <span class="pre">
     ordered
    </span>
   </code>
   Clause and
   <code class="docutils literal notranslate">
    <span class="pre">
     ordered
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#depobj-construct">
   <code class="docutils literal notranslate">
    <span class="pre">
     depobj
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#doacross-loop-nest">
   Doacross Loop Nest
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#lock-routines">
   Lock Routines
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#omp-init-lock-routine">
     <code class="docutils literal notranslate">
      <span class="pre">
       omp_init_lock
      </span>
     </code>
     Routine
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#omp-init-lock-with-hint-routine">
     <code class="docutils literal notranslate">
      <span class="pre">
       omp_init_lock_with_hint
      </span>
     </code>
     Routine
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#ownership-of-locks">
     Ownership of Locks
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#simple-lock-routines">
     Simple Lock Routines
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#nestable-lock-routines">
     Nestable Lock Routines
    </a>
   </li>
  </ul>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="synchronization">
<h1>Synchronization<a class="headerlink" href="#synchronization" title="Permalink to this headline">¶</a></h1>
<p>{synchronization}</p>
<p>The <code class="docutils literal notranslate"><span class="pre">barrier</span></code> construct is a stand-alone directive that requires all threads of a team (within a contention group) to execute the barrier and complete execution of all tasks within the region, before continuing past the barrier.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">critical</span></code> construct is a directive that contains a structured block.  The construct allows only a single thread at a time to execute the structured block (region). Multiple critical regions may exist in a parallel region, and may act cooperatively (only one thread at a time in all <code class="docutils literal notranslate"><span class="pre">critical</span></code> regions), or separately (only one thread at a time in each <code class="docutils literal notranslate"><span class="pre">critical</span></code> regions when a unique name is supplied on each <code class="docutils literal notranslate"><span class="pre">critical</span></code> construct). An optional (lock) <code class="docutils literal notranslate"><span class="pre">hint</span></code> clause may be specified on a named <code class="docutils literal notranslate"><span class="pre">critical</span></code>  construct to provide the OpenMP runtime guidance in selection a locking  mechanism.</p>
<p>On a finer scale the <code class="docutils literal notranslate"><span class="pre">atomic</span></code> construct allows only a single thread at  a time to have atomic access to a storage location involving a single read,  write, update or capture statement, and a limited number of combinations  when specifying the <code class="docutils literal notranslate"><span class="pre">capture</span></code>  <em>atomic-clause</em>  clause.  The  <em>atomic-clause</em>  clause is required for some expression statements, but is not required for <code class="docutils literal notranslate"><span class="pre">update</span></code> statements. The  <em>memory-order</em>  clause can be used to specify the degree of memory ordering enforced by an <code class="docutils literal notranslate"><span class="pre">atomic</span></code> construct. From weakest to strongest, they are <code class="docutils literal notranslate"><span class="pre">relaxed</span></code> (the default), acquire and/or release clauses (specified with <code class="docutils literal notranslate"><span class="pre">acquire</span></code>, <code class="docutils literal notranslate"><span class="pre">release</span></code>, or <code class="docutils literal notranslate"><span class="pre">acq_rel</span></code>), and <code class="docutils literal notranslate"><span class="pre">seq_cst</span></code>.  Please see the details in the  <em>atomic Construct</em>  subsection of the  <em>Directives</em>  chapter in the OpenMP Specifications document.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ordered</span></code> construct either specifies a structured block in a loop,  simd, or loop SIMD region that will be executed in the order of the loop  iterations.  The ordered construct sequentializes and orders the execution  of ordered regions while allowing code outside the region to run in parallel.</p>
<p>Since OpenMP 4.5 the <code class="docutils literal notranslate"><span class="pre">ordered</span></code> construct can also be a stand-alone  directive that specifies cross-iteration dependences in a doacross loop nest.   The <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause uses a <code class="docutils literal notranslate"><span class="pre">sink</span></code>  <em>dependence-type</em> , along with an  iteration vector argument (vec) to indicate the iteration that satisfies the  dependence.  The <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause with a <code class="docutils literal notranslate"><span class="pre">source</span></code>  <em>dependence-type</em>  specifies dependence satisfaction.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">flush</span></code> directive is a stand-alone construct for enforcing consistency between a thread’s view of memory and the view of memory for other threads (see the Memory Model chapter of this document for more details). When the construct is used with an explicit variable list, a  <em>strong flush</em>  that forces a thread’s temporary view of memory to be consistent with the actual memory is applied to all listed variables. When the construct is used without an explicit variable list and without a  <em>memory-order</em>  clause, a strong flush is applied to all locally thread-visible data as defined by the base language, and additionally the construct provides both acquire and release memory ordering semantics.  When an explicit variable list is not present and a  <em>memory-order</em>  clause is present, the construct provides acquire and/or release memory ordering semantics according to the  <em>memory-order</em>  clause, but no strong flush is performed. A resulting strong flush that applies to a set of variables effectively ensures that no memory (load or store) operation for the affected variables may be reordered across the <code class="docutils literal notranslate"><span class="pre">flush</span></code> directive.</p>
<p>General-purpose routines provide mutual exclusion semantics through locks,  represented by lock variables.   The semantics allows a task to  <em>set</em> , and hence   <em>own</em>  a lock, until it is  <em>unset</em>  by the task that set it. A   <em>nestable</em>  lock can be set multiple times by a task, and is used when in code requires nested control of locks.  A  <em>simple lock</em>  can only be set once by the owning task. There are specific calls for the two types of locks, and the variable of a specific lock type cannot be used by the other lock type.</p>
<p>Any explicit task will observe the synchronization prescribed in a  <code class="docutils literal notranslate"><span class="pre">barrier</span></code> construct and an implied barrier.  Also, additional synchronizations  are available for tasks.  All children of a task will wait at a <code class="docutils literal notranslate"><span class="pre">taskwait</span></code> (for  their siblings to complete).  A <code class="docutils literal notranslate"><span class="pre">taskgroup</span></code> construct creates a region in which the current task is suspended at the end of the region until all sibling tasks,  and their descendants, have completed.  Scheduling constraints on task execution can be prescribed by the <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause to enforce dependence on previously generated tasks. More details on controlling task executions can be found in the  <em>Tasking</em>  Chapter in the OpenMP Specifications document.</p>
<div class="section" id="critical-construct">
<h2><code class="docutils literal notranslate"><span class="pre">critical</span></code> Construct<a class="headerlink" href="#critical-construct" title="Permalink to this headline">¶</a></h2>
<p><strong>constructs!critical <code class="docutils literal notranslate"><span class="pre">critical</span></code></strong> <strong>critical construct <code class="docutils literal notranslate"><span class="pre">critical</span></code> construct</strong> <strong>critical construct <code class="docutils literal notranslate"><span class="pre">critical</span></code> construct!hint clause <code class="docutils literal notranslate"><span class="pre">hint</span></code> clause</strong> <strong>clauses!hint <code class="docutils literal notranslate"><span class="pre">hint</span></code></strong> <strong>hint clause <code class="docutils literal notranslate"><span class="pre">hint</span></code> clause</strong></p>
<p>The following example includes several <code class="docutils literal notranslate"><span class="pre">critical</span></code> constructs. The example  illustrates a queuing model in which a task is dequeued and worked on. To guard  against multiple threads dequeuing the same task, the dequeuing operation must  be in a <code class="docutils literal notranslate"><span class="pre">critical</span></code> region. Because the two queues in this example are independent,  they are protected by <code class="docutils literal notranslate"><span class="pre">critical</span></code> constructs with different names,  <em>xaxis</em>   and  <em>yaxis</em> .</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: critical.1
* type: C
*/
int dequeue(float *a);
void work(int i, float *a);

void critical_example(float *x, float *y)
{
  int ix_next, iy_next;

  #pragma omp parallel shared(x, y) private(ix_next, iy_next)
  {
    #pragma omp critical (xaxis)
      ix_next = dequeue(x);
    work(ix_next, x);

    #pragma omp critical (yaxis)
      iy_next = dequeue(y);
    work(iy_next, y);
  }

}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: critical.1
! type: F-fixed
      SUBROUTINE CRITICAL_EXAMPLE(X, Y)

        REAL X(*), Y(*)
        INTEGER IX_NEXT, IY_NEXT

!$OMP PARALLEL SHARED(X, Y) PRIVATE(IX_NEXT, IY_NEXT)

!$OMP CRITICAL(XAXIS)
        CALL DEQUEUE(IX_NEXT, X)
!$OMP END CRITICAL(XAXIS)
        CALL WORK(IX_NEXT, X)

!$OMP CRITICAL(YAXIS)
        CALL DEQUEUE(IY_NEXT,Y)
!$OMP END CRITICAL(YAXIS)
        CALL WORK(IY_NEXT, Y)

!$OMP END PARALLEL

      END SUBROUTINE CRITICAL_EXAMPLE

</pre></div>
</div>
</div>
</div>
<p>The following example extends the previous example by adding the <code class="docutils literal notranslate"><span class="pre">hint</span></code> clause to the <code class="docutils literal notranslate"><span class="pre">critical</span></code> constructs.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: critical.2
* type: C
* version: omp_5.0
*/
#include &lt;omp.h&gt;

int dequeue(float *a);
void work(int i, float *a);

void critical_example(float *x, float *y)
{
  int ix_next, iy_next;

  #pragma omp parallel shared(x, y) private(ix_next, iy_next)
  {
    #pragma omp critical (xaxis) hint(omp_sync_hint_contended)
      ix_next = dequeue(x);
    work(ix_next, x);

    #pragma omp critical (yaxis) hint(omp_sync_hint_contended)
      iy_next = dequeue(y);
    work(iy_next, y);
  }

}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: critical.2
! type: F-fixed
! version: omp_5.0
      SUBROUTINE CRITICAL_EXAMPLE(X, Y)
        USE OMP_LIB        ! or INCLUDE &quot;omp_lib.h&quot;

        REAL X(*), Y(*)
        INTEGER IX_NEXT, IY_NEXT

!$OMP PARALLEL SHARED(X, Y) PRIVATE(IX_NEXT, IY_NEXT)

!$OMP CRITICAL(XAXIS) HINT(OMP_SYNC_HINT_CONTENDED)
        CALL DEQUEUE(IX_NEXT, X)
!$OMP END CRITICAL(XAXIS)
        CALL WORK(IX_NEXT, X)

!$OMP CRITICAL(YAXIS) HINT(OMP_SYNC_HINT_CONTENDED)
        CALL DEQUEUE(IY_NEXT,Y)
!$OMP END CRITICAL(YAXIS)
        CALL WORK(IY_NEXT, Y)

!$OMP END PARALLEL

      END SUBROUTINE CRITICAL_EXAMPLE

</pre></div>
</div>
</div>
</div>
<p>../../synchronization/critical.tex</p>
</div>
<div class="section" id="worksharing-constructs-inside-a-critical-construct">
<h2>Worksharing Constructs Inside a <code class="docutils literal notranslate"><span class="pre">critical</span></code> Construct<a class="headerlink" href="#worksharing-constructs-inside-a-critical-construct" title="Permalink to this headline">¶</a></h2>
<p><strong>constructs!worksharing</strong> <strong>constructs!critical <code class="docutils literal notranslate"><span class="pre">critical</span></code></strong> <strong>critical construct <code class="docutils literal notranslate"><span class="pre">critical</span></code> construct</strong></p>
<p>The following example demonstrates using a worksharing construct inside a <code class="docutils literal notranslate"><span class="pre">critical</span></code>  construct. This example is conforming because the worksharing <code class="docutils literal notranslate"><span class="pre">single</span></code>   region is not closely nested inside the <code class="docutils literal notranslate"><span class="pre">critical</span></code> region. A single thread  executes the one and only section in the <code class="docutils literal notranslate"><span class="pre">sections</span></code> region, and executes  the <code class="docutils literal notranslate"><span class="pre">critical</span></code> region. The same thread encounters the nested <code class="docutils literal notranslate"><span class="pre">parallel</span></code>  region, creates a new team of threads, and becomes the primary thread of the new team.  One of the threads in the new team enters the <code class="docutils literal notranslate"><span class="pre">single</span></code> region and increments  <code class="docutils literal notranslate"><span class="pre">i</span></code> by <code class="docutils literal notranslate"><span class="pre">1</span></code>. At the end of this example <code class="docutils literal notranslate"><span class="pre">i</span></code> is equal to <code class="docutils literal notranslate"><span class="pre">2</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: worksharing_critical.1
* type: C
*/
void critical_work()
{
  int i = 1;
  #pragma omp parallel sections
  {
    #pragma omp section
    {
      #pragma omp critical (name)
      {
        #pragma omp parallel
        {
          #pragma omp single
          {
            i++;
          }
        }
      }
    }
  }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: worksharing_critical.1
! type: F-fixed
      SUBROUTINE CRITICAL_WORK()

        INTEGER I
        I = 1

!$OMP   PARALLEL SECTIONS
!$OMP     SECTION
!$OMP       CRITICAL (NAME)
!$OMP         PARALLEL
!$OMP           SINGLE
                  I = I + 1
!$OMP           END SINGLE
!$OMP         END PARALLEL
!$OMP       END CRITICAL (NAME)
!$OMP   END PARALLEL SECTIONS
      END SUBROUTINE CRITICAL_WORK

</pre></div>
</div>
</div>
</div>
<p>../../synchronization/worksharing_critical.tex</p>
</div>
<div class="section" id="binding-of-barrier-regions">
<h2>Binding of <code class="docutils literal notranslate"><span class="pre">barrier</span></code> Regions<a class="headerlink" href="#binding-of-barrier-regions" title="Permalink to this headline">¶</a></h2>
<p><strong>binding!barrier regions <code class="docutils literal notranslate"><span class="pre">barrier</span></code> regions</strong></p>
<p>The binding rules call for a <code class="docutils literal notranslate"><span class="pre">barrier</span></code> region to bind to the closest enclosing  <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region.</p>
<p>In the following example, the call from the main program to  <em>sub2</em>  is conforming  because the <code class="docutils literal notranslate"><span class="pre">barrier</span></code> region (in  <em>sub3</em> ) binds to the <code class="docutils literal notranslate"><span class="pre">parallel</span></code>  region in  <em>sub2</em> . The call from the main program to  <em>sub1</em>  is conforming  because the <code class="docutils literal notranslate"><span class="pre">barrier</span></code> region binds to the <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region in subroutine   <em>sub2</em> .</p>
<p>The call from the main program to  <em>sub3</em>  is conforming because the <code class="docutils literal notranslate"><span class="pre">barrier</span></code>  region binds to the implicit inactive <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region enclosing the sequential  part. Also note that the <code class="docutils literal notranslate"><span class="pre">barrier</span></code> region in  <em>sub3</em>  when called from   <em>sub2</em>  only synchronizes the team of threads in the enclosing <code class="docutils literal notranslate"><span class="pre">parallel</span></code>  region and not all the threads created in  <em>sub1</em> .</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: barrier_regions.1
* type: C
*/
void work(int n) {}

void sub3(int n)
{
  work(n);
  #pragma omp barrier
  work(n);
}

void sub2(int k)
{
  #pragma omp parallel shared(k)
    sub3(k);
}

void sub1(int n)
{
  int i;
  #pragma omp parallel private(i) shared(n)
  {
    #pragma omp for
    for (i=0; i&lt;n; i++)
      sub2(i);
  }
}

int main()
{
  sub1(2);
  sub2(2);
  sub3(2);
  return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: barrier_regions.1
! type: F-fixed
      SUBROUTINE WORK(N)
        INTEGER N
      END SUBROUTINE WORK

      SUBROUTINE SUB3(N)
      INTEGER N
        CALL WORK(N)
!$OMP   BARRIER
        CALL WORK(N)
      END SUBROUTINE SUB3

      SUBROUTINE SUB2(K)
      INTEGER K
!$OMP   PARALLEL SHARED(K)
          CALL SUB3(K)
!$OMP   END PARALLEL
      END SUBROUTINE SUB2


      SUBROUTINE SUB1(N)
      INTEGER N
        INTEGER I
!$OMP   PARALLEL PRIVATE(I) SHARED(N)
!$OMP     DO
          DO I = 1, N
            CALL SUB2(I)
          END DO
!$OMP   END PARALLEL
      END SUBROUTINE SUB1

      PROGRAM EXAMPLE
        CALL SUB1(2)
        CALL SUB2(2)
        CALL SUB3(2)
      END PROGRAM EXAMPLE

</pre></div>
</div>
</div>
</div>
<p>../../synchronization/barrier_regions.tex</p>
</div>
<div class="section" id="atomic-construct">
<h2><code class="docutils literal notranslate"><span class="pre">atomic</span></code> Construct<a class="headerlink" href="#atomic-construct" title="Permalink to this headline">¶</a></h2>
<p><strong>constructs!atomic <code class="docutils literal notranslate"><span class="pre">atomic</span></code></strong> <strong>atomic construct <code class="docutils literal notranslate"><span class="pre">atomic</span></code> construct</strong> <strong>atomic construct <code class="docutils literal notranslate"><span class="pre">atomic</span></code> construct!update clause <code class="docutils literal notranslate"><span class="pre">update</span></code> clause</strong> <strong>clauses!update <code class="docutils literal notranslate"><span class="pre">update</span></code></strong> <strong>update clause <code class="docutils literal notranslate"><span class="pre">update</span></code> clause</strong></p>
<p>The following example avoids race conditions (simultaneous updates of an element  of  <em>x</em>  by multiple threads) by using the <code class="docutils literal notranslate"><span class="pre">atomic</span></code> construct .</p>
<p>The advantage of using the <code class="docutils literal notranslate"><span class="pre">atomic</span></code> construct in this example is that it  allows updates of two different elements of  <em>x</em>  to occur in parallel. If  a <code class="docutils literal notranslate"><span class="pre">critical</span></code> construct were used instead, then all updates to elements of   <em>x</em>  would be executed serially (though not in any guaranteed order).</p>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">atomic</span></code> directive applies only to the statement immediately  following it. As a result, elements of  <em>y</em>  are not updated atomically in  this example.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: atomic.1
* type: C
* version: omp_3.1
*/
float work1(int i)
{
  return 1.0 * i;
}

float work2(int i)
{
   return 2.0 * i;
}

void atomic_example(float *x, float *y, int *index, int n)
{
  int i;

  #pragma omp parallel for shared(x, y, index, n)
    for (i=0; i&lt;n; i++) {
      #pragma omp atomic update
      x[index[i]] += work1(i);
      y[i] += work2(i);
     }
}

int main()
{
  float x[1000];
  float y[10000];
  int index[10000];
  int i;

  for (i = 0; i &lt; 10000; i++) {
    index[i] = i % 1000;
    y[i]=0.0;
  }
  for (i = 0; i &lt; 1000; i++)
    x[i] = 0.0;
  atomic_example(x, y, index, 10000);
  return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: atomic.1
! type: F-fixed
! version: omp_3.1
      REAL FUNCTION WORK1(I)
        INTEGER I
        WORK1 = 1.0 * I
        RETURN
      END FUNCTION WORK1

      REAL FUNCTION WORK2(I)
        INTEGER I
        WORK2 = 2.0 * I
        RETURN
      END FUNCTION WORK2

      SUBROUTINE SUB(X, Y, INDEX, N)
        REAL X(*), Y(*)
        INTEGER INDEX(*), N

        INTEGER I

!$OMP   PARALLEL DO SHARED(X, Y, INDEX, N)
          DO I=1,N
!$OMP       ATOMIC UPDATE
              X(INDEX(I)) = X(INDEX(I)) + WORK1(I)
            Y(I) = Y(I) + WORK2(I)
          ENDDO

      END SUBROUTINE SUB

      PROGRAM ATOMIC_EXAMPLE
        REAL X(1000), Y(10000)
        INTEGER INDEX(10000)
        INTEGER I

        DO I=1,10000
          INDEX(I) = MOD(I, 1000) + 1
          Y(I) = 0.0
        ENDDO

        DO I = 1,1000
          X(I) = 0.0
        ENDDO

        CALL SUB(X, Y, INDEX, 10000)

      END PROGRAM ATOMIC_EXAMPLE

</pre></div>
</div>
</div>
</div>
<p><strong>atomic construct <code class="docutils literal notranslate"><span class="pre">atomic</span></code> construct!write clause <code class="docutils literal notranslate"><span class="pre">write</span></code> clause</strong> <strong>atomic construct <code class="docutils literal notranslate"><span class="pre">atomic</span></code> construct!read clause <code class="docutils literal notranslate"><span class="pre">read</span></code> clause</strong> <strong>write clause <code class="docutils literal notranslate"><span class="pre">write</span></code> clause</strong> <strong>clauses!write <code class="docutils literal notranslate"><span class="pre">write</span></code></strong> <strong>read clause <code class="docutils literal notranslate"><span class="pre">read</span></code> clause</strong> <strong>clauses!read <code class="docutils literal notranslate"><span class="pre">read</span></code></strong> The following example illustrates the <code class="docutils literal notranslate"><span class="pre">read</span></code> and <code class="docutils literal notranslate"><span class="pre">write</span></code>  clauses  for the <code class="docutils literal notranslate"><span class="pre">atomic</span></code> directive. These clauses ensure that the given variable  is read or written, respectively, as a whole. Otherwise, some other thread might  read or write part of the variable while the current thread was reading or writing  another part of the variable. Note that most hardware provides atomic reads and  writes for some set of properly aligned variables of specific sizes, but not necessarily  for all the variable types supported by the OpenMP API.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: atomic.2
* type: C
* version: omp_3.1
*/
int atomic_read(const int *p)
{
    int value;
/* Guarantee that the entire value of *p is read atomically. No part of
 * *p can change during the read operation.
 */
#pragma omp atomic read
     value = *p;
     return value;
}

void atomic_write(int *p, int value)
{
/* Guarantee that value is stored atomically into *p. No part of *p can
change
 * until after the entire write operation is completed.
 */
#pragma omp atomic write
    *p = value;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: atomic.2
! type: F-fixed
! version: omp_3.1
       function atomic_read(p)
       integer :: atomic_read
       integer, intent(in) :: p
! Guarantee that the entire value of p is read atomically. No part of
! p can change during the read operation.

!$omp atomic read
       atomic_read = p
       return
       end function atomic_read

       subroutine atomic_write(p, value)
       integer, intent(out) :: p
       integer, intent(in) :: value
! Guarantee that value is stored atomically into p. No part of p can change
! until after the entire write operation is completed.
!$omp atomic write
       p = value
       end subroutine atomic_write

</pre></div>
</div>
</div>
</div>
<p><strong>atomic construct <code class="docutils literal notranslate"><span class="pre">atomic</span></code> construct!capture clause <code class="docutils literal notranslate"><span class="pre">capture</span></code> clause</strong> <strong>capture clause <code class="docutils literal notranslate"><span class="pre">capture</span></code> clause</strong> <strong>clauses!capture <code class="docutils literal notranslate"><span class="pre">capture</span></code></strong> The following example illustrates the <code class="docutils literal notranslate"><span class="pre">capture</span></code> clause for the <code class="docutils literal notranslate"><span class="pre">atomic</span></code>  directive. In this case the value of a variable is captured, and then the variable  is incremented. These operations occur atomically. This example could  be implemented using the fetch-and-add instruction available on many kinds of hardware.  The example also shows a way to implement a spin lock using the <code class="docutils literal notranslate"><span class="pre">capture</span></code>   and <code class="docutils literal notranslate"><span class="pre">read</span></code> clauses.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: atomic.3
* type: C
* version: omp_3.1
*/
int fetch_and_add(int *p)
{
   /* Atomically read the value of *p and then increment it. The
      previous value is returned. This can be used to implement a
      simple lock as shown below.
    */
   int old;
#pragma omp atomic capture
   { old = *p; (*p)++; }
   return old;
}

/*
 * Use fetch_and_add to implement a lock
 */
struct locktype {
   int ticketnumber;
   int turn;
};
void do_locked_work(struct locktype *lock)
{
   int atomic_read(const int *p);
   void work();

   // Obtain the lock
   int myturn = fetch_and_add(&amp;lock-&gt;ticketnumber);
   while (atomic_read(&amp;lock-&gt;turn) != myturn)
      ;
   // Do some work. The flush is needed to ensure visibility of
   // variables not involved in atomic directives

   #pragma omp flush
   work();
   #pragma omp flush
   // Release the lock
   fetch_and_add(&amp;lock-&gt;turn);
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: atomic.3
! type: F-fixed
! version: omp_3.1
       function fetch_and_add(p)
       integer:: fetch_and_add
       integer, intent(inout) :: p

! Atomically read the value of p and then increment it. The previous value
! is returned. This can be used to implement a simple lock as shown below.
!$omp atomic capture
       fetch_and_add = p
       p = p + 1
!$omp end atomic
       end function fetch_and_add
       module m
       interface
         function fetch_and_add(p)
           integer :: fetch_and_add
           integer, intent(inout) :: p
         end function
         function atomic_read(p)
           integer :: atomic_read
           integer, intent(in) :: p
         end function
       end interface
       type locktype
          integer ticketnumber
          integer turn
       end type
       contains
       subroutine do_locked_work(lock)
       type(locktype), intent(inout) :: lock
       integer myturn
       integer junk
! obtain the lock
        myturn = fetch_and_add(lock%ticketnumber)
        do while (atomic_read(lock%turn) .ne. myturn)
          continue
        enddo
! Do some work. The flush is needed to ensure visibility of variables
! not involved in atomic directives
!$omp flush
       call work
!$omp flush
! Release the lock
       junk = fetch_and_add(lock%turn)
       end subroutine
       end module

</pre></div>
</div>
</div>
</div>
<p>../../synchronization/atomic.tex</p>
</div>
<div class="section" id="restrictions-on-the-atomic-construct">
<h2>Restrictions on the <code class="docutils literal notranslate"><span class="pre">atomic</span></code> Construct<a class="headerlink" href="#restrictions-on-the-atomic-construct" title="Permalink to this headline">¶</a></h2>
<p><strong>constructs!atomic <code class="docutils literal notranslate"><span class="pre">atomic</span></code></strong> <strong>atomic construct <code class="docutils literal notranslate"><span class="pre">atomic</span></code> construct</strong></p>
<p>The following non-conforming examples illustrate the restrictions on the <code class="docutils literal notranslate"><span class="pre">atomic</span></code>  construct.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: atomic_restrict.1
* type: C
* version: omp_3.1
*/
void atomic_wrong ()
{
 union {int n; float x;} u;

#pragma omp parallel
  {
#pragma omp atomic update
    u.n++;

#pragma omp atomic update
    u.x += 1.0;

/* Incorrect because the atomic constructs reference the same location
   through incompatible types */
  }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: atomic_restrict.1
! type: F-fixed
! version: omp_3.1
      SUBROUTINE ATOMIC_WRONG()
        INTEGER:: I
        REAL:: R
        EQUIVALENCE(I,R)

!$OMP   PARALLEL
!$OMP     ATOMIC UPDATE
            I = I + 1
!$OMP     ATOMIC UPDATE
            R = R + 1.0
! incorrect because I and R reference the same location
! but have different types
!$OMP   END PARALLEL
      END SUBROUTINE ATOMIC_WRONG

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: atomic_restrict.2
* type: C
* version: omp_3.1
*/
void atomic_wrong2 ()
{
 int  x;
 int *i;
 float   *r;

 i = &amp;x;
 r = (float *)&amp;x;

#pragma omp parallel
  {
#pragma omp atomic update
    *i += 1;

#pragma omp atomic update
    *r += 1.0;

/* Incorrect because the atomic constructs reference the same location
   through incompatible types */

  }
}

</pre></div>
</div>
</div>
</div>
<p>The following example is non-conforming because <code class="docutils literal notranslate"><span class="pre">I</span></code> and <code class="docutils literal notranslate"><span class="pre">R</span></code> reference  the same location but have different types.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: atomic_restrict.2
! type: F-fixed
! version: omp_3.1
      SUBROUTINE SUB()
        COMMON /BLK/ R
        REAL R

!$OMP   ATOMIC UPDATE
          R = R + 1.0
      END SUBROUTINE SUB

      SUBROUTINE ATOMIC_WRONG2()
        COMMON /BLK/ I
        INTEGER I

!$OMP   PARALLEL

!$OMP     ATOMIC UPDATE
            I = I + 1
          CALL SUB()
!$OMP   END PARALLEL
      END SUBROUTINE ATOMIC_WRONG2

</pre></div>
</div>
</div>
</div>
<p>Although the following example might work on some implementations, this is also  non-conforming:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: atomic_restrict.3
! type: F-fixed
! version: omp_3.1
      SUBROUTINE ATOMIC_WRONG3
        INTEGER:: I
        REAL:: R
        EQUIVALENCE(I,R)

!$OMP   PARALLEL
!$OMP     ATOMIC UPDATE
            I = I + 1
! incorrect because I and R reference the same location
! but have different types
!$OMP   END PARALLEL

!$OMP   PARALLEL
!$OMP     ATOMIC UPDATE
            R = R + 1.0
! incorrect because I and R reference the same location
! but have different types
!$OMP   END PARALLEL

      END SUBROUTINE ATOMIC_WRONG3

</pre></div>
</div>
</div>
</div>
<p>../../synchronization/atomic_restrict.tex</p>
</div>
<div class="section" id="flush-construct-without-a-list">
<h2><code class="docutils literal notranslate"><span class="pre">flush</span></code> Construct without a List<a class="headerlink" href="#flush-construct-without-a-list" title="Permalink to this headline">¶</a></h2>
<p><strong>constructs!flush <code class="docutils literal notranslate"><span class="pre">flush</span></code></strong> <strong>flush construct <code class="docutils literal notranslate"><span class="pre">flush</span></code> construct</strong> <strong>flushes!flush without a list</strong></p>
<p>The following example distinguishes the shared variables affected by a <code class="docutils literal notranslate"><span class="pre">flush</span></code>  construct with no list from the shared objects that are not affected:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: flush_nolist.1
* type: C
*/
int x, *p = &amp;x;

void f1(int *q)
{
  *q = 1;
  #pragma omp flush
  /* x, p, and *q are flushed */
  /* because they are shared and accessible */
  /* q is not flushed because it is not shared. */
}

void f2(int *q)
{
  #pragma omp barrier
  *q = 2;
  #pragma omp barrier

  /* a barrier implies a flush */
  /* x, p, and *q are flushed */
  /* because they are shared and accessible */
  /* q is not flushed because it is not shared. */
}

int g(int n)
{
  int i = 1, j, sum = 0;
  *p = 1;
  #pragma omp parallel reduction(+: sum) num_threads(10)
  {
    f1(&amp;j);

    /* i, n and sum were not flushed */
    /* because they were not accessible in f1 */
    /* j was flushed because it was accessible */
    sum += j;

    f2(&amp;j);

    /* i, n, and sum were not flushed */
    /* because they were not accessible in f2 */
    /* j was flushed because it was accessible */
    sum += i + j + *p + n;
  }
  return sum;
}

int main()
{
  int result = g(7);
  return result;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: flush_nolist.1
! type: F-fixed
      SUBROUTINE F1(Q)
        COMMON /DATA/ X, P
        INTEGER, TARGET  :: X
        INTEGER, POINTER :: P
        INTEGER Q

        Q = 1
!$OMP   FLUSH
        ! X, P and Q are flushed
        ! because they are shared and accessible
      END SUBROUTINE F1

      SUBROUTINE F2(Q)
        COMMON /DATA/ X, P
        INTEGER, TARGET  :: X
        INTEGER, POINTER :: P
        INTEGER Q

!$OMP   BARRIER
          Q = 2
!$OMP   BARRIER
          ! a barrier implies a flush
          ! X, P and Q are flushed
          ! because they are shared and accessible
      END SUBROUTINE F2

      INTEGER FUNCTION G(N)
        COMMON /DATA/ X, P
        INTEGER, TARGET  :: X
        INTEGER, POINTER :: P
        INTEGER N
        INTEGER I, J, SUM

        I = 1
        SUM = 0
        P = 1
!$OMP   PARALLEL REDUCTION(+: SUM) NUM_THREADS(10)
          CALL F1(J)
            ! I, N and SUM were not flushed
            !   because they were not accessible in F1
            ! J was flushed because it was accessible
          SUM = SUM + J

          CALL F2(J)
            ! I, N, and SUM were not flushed
            !   because they were not accessible in f2
            ! J was flushed because it was accessible
          SUM = SUM + I + J + P + N
!$OMP   END PARALLEL

        G = SUM
      END FUNCTION G

      PROGRAM FLUSH_NOLIST
        COMMON /DATA/ X, P
        INTEGER, TARGET  :: X
        INTEGER, POINTER :: P
        INTEGER RESULT, G

        P =&gt; X
        RESULT = G(7)
        PRINT *, RESULT
      END PROGRAM FLUSH_NOLIST

</pre></div>
</div>
</div>
</div>
<p>../../synchronization/flush_nolist.tex</p>
</div>
<div class="section" id="synchronization-based-on-acquire-release-semantics">
<h2>Synchronization Based on Acquire/Release Semantics<a class="headerlink" href="#synchronization-based-on-acquire-release-semantics" title="Permalink to this headline">¶</a></h2>
<p><strong>flushes!acquire</strong> <strong>flushes!release</strong> <strong>clauses!memory ordering clauses</strong> <strong>memory ordering clauses!acquire <code class="docutils literal notranslate"><span class="pre">acquire</span></code></strong> <strong>acquire clause <code class="docutils literal notranslate"><span class="pre">acquire</span></code> clause</strong> <strong>memory ordering clauses!release <code class="docutils literal notranslate"><span class="pre">release</span></code></strong> <strong>release clause <code class="docutils literal notranslate"><span class="pre">release</span></code> clause</strong> <strong>memory ordering clauses!acq_rel <code class="docutils literal notranslate"><span class="pre">acq_rel</span></code></strong> <strong>acq_rel clause <code class="docutils literal notranslate"><span class="pre">acq_rel</span></code> clause</strong> <strong>flush construct <code class="docutils literal notranslate"><span class="pre">flush</span></code> construct</strong> <strong>atomic construct <code class="docutils literal notranslate"><span class="pre">atomic</span></code> construct</strong> <strong>clauses!acquire <code class="docutils literal notranslate"><span class="pre">acquire</span></code></strong> <strong>clauses!release <code class="docutils literal notranslate"><span class="pre">release</span></code></strong> <strong>clauses!acq_rel <code class="docutils literal notranslate"><span class="pre">acq_rel</span></code></strong> As explained in the Memory Model chapter of this document, a flush operation may be an <strong>acquire flush</strong> and/or a <strong>release flush</strong>, and OpenMP 5.0 defines acquire/release semantics in terms of these fundamental flush operations.  For any synchronization between two threads that is specified by OpenMP, a release flush logically occurs at the source of the synchronization and an acquire flush logically occurs at the sink of the synchronization. OpenMP 5.0 added memory ordering clauses – <code class="docutils literal notranslate"><span class="pre">acquire</span></code>, <code class="docutils literal notranslate"><span class="pre">release</span></code>, and <code class="docutils literal notranslate"><span class="pre">acq_rel</span></code> – to the <code class="docutils literal notranslate"><span class="pre">flush</span></code> and <code class="docutils literal notranslate"><span class="pre">atomic</span></code> constructs for explicitly requesting acquire/release semantics.  Furthermore, implicit flushes for all OpenMP constructs and runtime routines that synchronize OpenMP threads in some manner were redefined in terms of synchronizing release and acquire flushes to avoid the requirement of strong memory fences (see the  <em>Flush Synchronization and Happens Before</em>  and  <em>Implicit Flushes</em>  sections of the OpenMP Specifications document).</p>
<p>The examples that follow in this section illustrate how acquire and release flushes may be employed, implicitly or explicitly, for synchronizing threads. A <code class="docutils literal notranslate"><span class="pre">flush</span></code> directive without a list and without any memory ordering clause can also function as both an acquire and release flush for facilitating thread synchronization.  Flushes implied on entry to, or exit from, an atomic operation (specified by an <code class="docutils literal notranslate"><span class="pre">atomic</span></code> construct) may function as an acquire flush or a release flush if a memory ordering clause appears on the construct. On entry to and exit from a <code class="docutils literal notranslate"><span class="pre">critical</span></code> construct there is now an implicit acquire flush and release flush, respectively.</p>
<p><strong>constructs!critical <code class="docutils literal notranslate"><span class="pre">critical</span></code></strong> <strong>critical construct <code class="docutils literal notranslate"><span class="pre">critical</span></code> construct</strong> <strong>flushes!implicit</strong> The first example illustrates how the release and acquire flushes implied by a <code class="docutils literal notranslate"><span class="pre">critical</span></code> region guarantee a value written by the first thread is visible to a read of the value on the second thread. Thread 0 writes to  <em>x</em>  and then executes a <code class="docutils literal notranslate"><span class="pre">critical</span></code> region in which it writes to  <em>y</em> ; the write to  <em>x</em>  happens before the execution of the <code class="docutils literal notranslate"><span class="pre">critical</span></code> region, consistent with the program order of the thread.  Meanwhile, thread 1 executes a <code class="docutils literal notranslate"><span class="pre">critical</span></code> region in a loop until it reads a non-zero value from  <em>y</em>  in the <code class="docutils literal notranslate"><span class="pre">critical</span></code> region, after which it prints the value of  <em>x</em> ; again, the execution of the <code class="docutils literal notranslate"><span class="pre">critical</span></code> regions happen before the read from  <em>x</em>  based on the program order of the thread. The <code class="docutils literal notranslate"><span class="pre">critical</span></code> regions executed by the two threads execute in a serial manner, with a pairwise synchronization from the exit of one <code class="docutils literal notranslate"><span class="pre">critical</span></code> region to the entry to the next <code class="docutils literal notranslate"><span class="pre">critical</span></code> region.  These pairwise synchronizations result from the implicit release flushes that occur on exit from <code class="docutils literal notranslate"><span class="pre">critical</span></code> regions and the implicit acquire flushes that occur on entry to <code class="docutils literal notranslate"><span class="pre">critical</span></code> regions; hence, the execution of each <code class="docutils literal notranslate"><span class="pre">critical</span></code> region in the sequence happens before the execution of the next <code class="docutils literal notranslate"><span class="pre">critical</span></code> region. A “happens before’’ order is therefore established between the assignment to  <em>x</em>  by thread 0 and the read from  <em>x</em>  by thread 1, and so thread 1 must see that  <em>x</em>  equals 10.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: acquire_release.1
* type: C
* version: omp_5.0
*/

#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;

int main()
{
   int x = 0, y = 0;
   #pragma omp parallel num_threads(2)
   {
      int thrd = omp_get_thread_num();
      if (thrd == 0) {
         x = 10;
         #pragma omp critical
         { y = 1; }
      } else {
         int tmp = 0;
         while (tmp == 0) {
           #pragma omp critical
           { tmp = y; }
         }
         printf(&quot;x = %d\n&quot;, x); // always &quot;x = 10&quot;
      }
   }
   return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: acquire_release.1
! type: F-free
! version: omp_5.0

program rel_acq_ex1
   use omp_lib
   integer :: x, y, thrd, tmp
   x = 0
   y = 0
   !$omp parallel num_threads(2) private(thrd, tmp)
      thrd = omp_get_thread_num()
      if (thrd == 0) then
         x = 10
         !$omp critical
         y = 1
         !$omp end critical
      else
         tmp = 0
         do while (tmp == 0)
            !$omp critical
            tmp = y
            !$omp end critical
         end do
         print *, &quot;x = &quot;, x  !! always &quot;x = 10&quot;
      end if
   !$omp end parallel
end program

</pre></div>
</div>
</div>
</div>
<p><strong>constructs!atomic <code class="docutils literal notranslate"><span class="pre">atomic</span></code></strong> <strong>atomic construct <code class="docutils literal notranslate"><span class="pre">atomic</span></code> construct</strong> <strong>atomic construct <code class="docutils literal notranslate"><span class="pre">atomic</span></code> construct!write clause <code class="docutils literal notranslate"><span class="pre">write</span></code> clause</strong> <strong>atomic construct <code class="docutils literal notranslate"><span class="pre">atomic</span></code> construct!read clause <code class="docutils literal notranslate"><span class="pre">read</span></code> clause</strong> <strong>atomic construct <code class="docutils literal notranslate"><span class="pre">atomic</span></code> construct!memory ordering clauses</strong> <strong>write clause <code class="docutils literal notranslate"><span class="pre">write</span></code> clause</strong> <strong>read clause <code class="docutils literal notranslate"><span class="pre">read</span></code> clause</strong> <strong>clauses!write <code class="docutils literal notranslate"><span class="pre">write</span></code></strong> <strong>clauses!read <code class="docutils literal notranslate"><span class="pre">read</span></code></strong> <strong>memory ordering clauses!seq_cst <code class="docutils literal notranslate"><span class="pre">seq_cst</span></code></strong> <strong>seq_cst clause <code class="docutils literal notranslate"><span class="pre">seq_cst</span></code> clause</strong> <strong>clauses!seq_cst <code class="docutils literal notranslate"><span class="pre">seq_cst</span></code></strong> In the second example, the <code class="docutils literal notranslate"><span class="pre">critical</span></code> constructs are exchanged with <code class="docutils literal notranslate"><span class="pre">atomic</span></code> constructs that have 	extit{explicit} memory ordering specified. When the atomic read operation on thread 1 reads a non-zero value from  <em>y</em> , this results in a release/acquire synchronization that in turn implies that the assignment to  <em>x</em>  on thread 0 happens before the read of  <em>x</em>  on thread 1. Therefore, thread 1 will print “x = 10’’.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: acquire_release.2
* type: C
* version: omp_5.0
*/

#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;

int main()
{
   int x = 0, y = 0;
   #pragma omp parallel num_threads(2)
   {
      int thrd = omp_get_thread_num();
       if (thrd == 0) {
          x = 10;
          #pragma omp atomic write release // or seq_cst
          y = 1;
       } else {
          int tmp = 0;
          while (tmp == 0) {
            #pragma omp atomic read acquire // or seq_cst
            tmp = y;
          }
          printf(&quot;x = %d\n&quot;, x); // always &quot;x = 10&quot;
       }
   }
   return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: acquire_release.2
! type: F-free
! version: omp_5.0

program rel_acq_ex2
   use omp_lib
   integer :: x, y, thrd, tmp
   x = 0
   y = 0
   !$omp parallel num_threads(2) private(thrd, tmp)
      thrd = omp_get_thread_num()
      if (thrd == 0) then
         x = 10
         !$omp atomic write release ! or seq_cst
          y = 1
         !$omp end atomic
      else
         tmp = 0
         do while (tmp == 0)
            !$omp atomic read acquire ! or seq_cst
            tmp = y
            !$omp end atomic
         end do
         print *, &quot;x = &quot;, x  !! always &quot;x = 10&quot;
      end if
   !$omp end parallel
end program

</pre></div>
</div>
</div>
</div>
<p><strong>constructs!atomic <code class="docutils literal notranslate"><span class="pre">atomic</span></code></strong> <strong>atomic construct <code class="docutils literal notranslate"><span class="pre">atomic</span></code> construct!relaxed atomic operations</strong> <strong>flush construct <code class="docutils literal notranslate"><span class="pre">flush</span></code> construct</strong> In the third example, <code class="docutils literal notranslate"><span class="pre">atomic</span></code> constructs that specify relaxed atomic operations are used with explicit <code class="docutils literal notranslate"><span class="pre">flush</span></code> directives to enforce memory ordering between the two threads. The explicit <code class="docutils literal notranslate"><span class="pre">flush</span></code> directive on thread 0 must specify a release flush and the explicit <code class="docutils literal notranslate"><span class="pre">flush</span></code> directive on thread 1 must specify an acquire flush to establish a release/acquire synchronization between the two threads. The <code class="docutils literal notranslate"><span class="pre">flush</span></code> and <code class="docutils literal notranslate"><span class="pre">atomic</span></code> constructs encountered by thread 0 can be replaced by the <code class="docutils literal notranslate"><span class="pre">atomic</span></code> construct used in Example 2 for thread 0, and similarly the <code class="docutils literal notranslate"><span class="pre">flush</span></code> and <code class="docutils literal notranslate"><span class="pre">atomic</span></code> constructs encountered by thread 1 can be replaced by the <code class="docutils literal notranslate"><span class="pre">atomic</span></code> construct used in Example 2 for thread 1.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: acquire_release.3
* type: C
* version: omp_5.0
*/

#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;

int main()
{
   int x = 0, y = 0;
   #pragma omp parallel num_threads(2)
   {
      int thrd = omp_get_thread_num();
      if (thrd == 0) {
         x = 10;
         #pragma omp flush // or with acq_rel or release clause
         #pragma omp atomic write // or with relaxed clause
         y = 1;
      } else {
         int tmp = 0;
         while (tmp == 0) {
           #pragma omp atomic read // or with relaxed clause
           tmp = y;
         }
         #pragma omp flush // or with acq_rel or acquire clause
         printf(&quot;x = %d\n&quot;, x);  // always &quot;x = 10&quot;
      }
   }
   return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: acquire_release.3
! type: F-free
! version: omp_5.0

program rel_acq_ex3
   use omp_lib
   integer :: x, y, thrd, tmp
   x = 0
   y = 0
   !$omp parallel num_threads(2) private(thrd, tmp)
      thrd = omp_get_thread_num()
      if (thrd == 0) then
         x = 10
         !$omp flush ! or with acq_rel or release clause
         !$omp atomic write
         y = 1
         !$omp end atomic
      else
         tmp = 0
         do while (tmp == 0)
            !$omp atomic read
            tmp = y
            !$omp end atomic
         end do
         !$omp flush ! or with acq_rel or acquire clause
         print *, &quot;x = &quot;, x  !! always &quot;x = 10&quot;
      end if
   !$omp end parallel
end program

</pre></div>
</div>
</div>
</div>
<p>Example 4 will fail to order the write to  <em>x</em>  on thread 0 before the read from  <em>x</em>  on thread 1. Importantly, the implicit release flush on exit from the <code class="docutils literal notranslate"><span class="pre">critical</span></code> region will not synchronize with the acquire flush that occurs on the atomic read operation performed by thread 1. This is because implicit release flushes that occur on a given construct may only synchronize with implicit acquire flushes on a compatible construct (and vice-versa) that internally makes use of the same synchronization variable. For a <code class="docutils literal notranslate"><span class="pre">critical</span></code> construct, this might correspond to a  <em>lock</em>  object that is used by a given implementation (for the synchronization semantics of other constructs due to implicit release and acquire flushes, refer to the  <em>Implicit Flushes</em>  section of the OpenMP Specifications document).  Either an explicit <code class="docutils literal notranslate"><span class="pre">flush</span></code> directive that provides a release flush (i.e., a flush without a list that does not have the <code class="docutils literal notranslate"><span class="pre">acquire</span></code> clause) must be specified between the <code class="docutils literal notranslate"><span class="pre">critical</span></code> construct and the atomic write, or an atomic operation that modifies  <em>y</em>  and provides release semantics must be specified.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: acquire_release_broke.4
* type: C
* version: omp_5.0
*/

#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;

int main()
{

// !!! THIS CODE WILL FAIL TO PRODUCE CONSISTENT RESULTS !!!!!!!
// !!! DO NOT PROGRAM SYNCHRONIZATION THIS WAY !!!!!!!

   int x = 0, y;
   #pragma omp parallel num_threads(2)
   {
      int thrd = omp_get_thread_num();
      if (thrd == 0) {
         #pragma omp critical
         { x = 10; }
         // an explicit flush directive that provides
         // release semantics is needed here
         // to complete the synchronization.
         #pragma omp atomic write
         y = 1;
      } else {
         int tmp = 0;
         while (tmp == 0) {
            #pragma omp atomic read acquire // or seq_cst
            tmp = y;
         }
         #pragma omp critical
         { printf(&quot;x = %d\n&quot;, x); }  // !! NOT ALWAYS 10
      }
   }
   return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: acquire_release_broke.4
! type: F-free
! version: omp_5.0

program rel_acq_ex4
   use omp_lib
   integer :: x, y, thrd
   integer :: tmp
   x = 0

!! !!! THIS CODE WILL FAIL TO PRODUCE CONSISTENT RESULTS !!!!!!!
!! !!! DO NOT PROGRAM SYNCHRONIZATION THIS WAY !!!!!!!

   !$omp parallel num_threads(2) private(thrd) private(tmp)
      thrd = omp_get_thread_num()
      if (thrd == 0) then
         !$omp critical
         x = 10
         !$omp end critical
         ! an explicit flush directive that provides
         ! release semantics is needed here to
         ! complete the synchronization.
         !$omp atomic write
         y = 1
         !$omp end atomic
      else
         tmp = 0
         do while(tmp == 0)
           !$omp atomic read acquire ! or seq_cst
           tmp = x
           !$omp end atomic
         end do
         !$omp critical
         print *, &quot;x = &quot;, x  !! !! NOT ALWAYS 10
         !$omp end critical
      end if
   !$omp end parallel
end program

</pre></div>
</div>
</div>
</div>
<p>../../synchronization/acquire_release.tex</p>
</div>
<div class="section" id="ordered-clause-and-ordered-construct">
<h2><code class="docutils literal notranslate"><span class="pre">ordered</span></code> Clause and <code class="docutils literal notranslate"><span class="pre">ordered</span></code> Construct<a class="headerlink" href="#ordered-clause-and-ordered-construct" title="Permalink to this headline">¶</a></h2>
<p><strong>clauses!ordered <code class="docutils literal notranslate"><span class="pre">ordered</span></code></strong> <strong>ordered clause <code class="docutils literal notranslate"><span class="pre">ordered</span></code> clause</strong> <strong>constructs!ordered <code class="docutils literal notranslate"><span class="pre">ordered</span></code></strong> <strong>ordered construct <code class="docutils literal notranslate"><span class="pre">ordered</span></code> construct</strong></p>
<p>Ordered constructs  are useful for sequentially ordering the output from work that  is done in parallel. The following program prints out the indices in sequential  order:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: ordered.1
* type: C
*/
#include &lt;stdio.h&gt;

void work(int k)
{
  #pragma omp ordered
    printf(&quot; %d\n&quot;, k);
}

void ordered_example(int lb, int ub, int stride)
{
  int i;

  #pragma omp parallel for ordered schedule(dynamic)
  for (i=lb; i&lt;ub; i+=stride)
    work(i);
}

int main()
{
  ordered_example(0, 100, 5);
  return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: ordered.1
! type: F-fixed
      SUBROUTINE WORK(K)
        INTEGER k

!$OMP ORDERED
        WRITE(*,*) K
!$OMP END ORDERED

      END SUBROUTINE WORK

      SUBROUTINE SUB(LB, UB, STRIDE)
        INTEGER LB, UB, STRIDE
        INTEGER I

!$OMP PARALLEL DO ORDERED SCHEDULE(DYNAMIC)
        DO I=LB,UB,STRIDE
          CALL WORK(I)
        END DO
!$OMP END PARALLEL DO

      END SUBROUTINE SUB

      PROGRAM ORDERED_EXAMPLE
        CALL SUB(1,100,5)
      END PROGRAM ORDERED_EXAMPLE

</pre></div>
</div>
</div>
</div>
<p>It is possible to have multiple <code class="docutils literal notranslate"><span class="pre">ordered</span></code> constructs within a loop region  with the <code class="docutils literal notranslate"><span class="pre">ordered</span></code> clause specified. The first example is non-conforming  because all iterations execute two <code class="docutils literal notranslate"><span class="pre">ordered</span></code> regions. An iteration of a  loop must not execute more than one <code class="docutils literal notranslate"><span class="pre">ordered</span></code> region:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: ordered.2
* type: C
*/
void work(int i) {}

void ordered_wrong(int n)
{
  int i;
  #pragma omp for ordered
  for (i=0; i&lt;n; i++) {
/* incorrect because an iteration may not execute more than one
   ordered region */
    #pragma omp ordered
      work(i);
    #pragma omp ordered
      work(i+1);
  }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: ordered.2
! type: F-fixed
      SUBROUTINE WORK(I)
      INTEGER I
      END SUBROUTINE WORK

      SUBROUTINE ORDERED_WRONG(N)
      INTEGER N

        INTEGER I
!$OMP   DO ORDERED
        DO I = 1, N
! incorrect because an iteration may not execute more than one
! ordered region
!$OMP     ORDERED
            CALL WORK(I)
!$OMP     END ORDERED

!$OMP     ORDERED
            CALL WORK(I+1)
!$OMP     END ORDERED
        END DO
      END SUBROUTINE ORDERED_WRONG

</pre></div>
</div>
</div>
</div>
<p>The following is a conforming example with more than one <code class="docutils literal notranslate"><span class="pre">ordered</span></code> construct.  Each iteration will execute only one <code class="docutils literal notranslate"><span class="pre">ordered</span></code> region:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: ordered.3
* type: C
*/
void work(int i) {}
void ordered_good(int n)
{
  int i;
#pragma omp for ordered
  for (i=0; i&lt;n; i++) {
    if (i &lt;= 10) {
      #pragma omp ordered
         work(i);
    }
    if (i &gt; 10) {
      #pragma omp ordered
        work(i+1);
    }
  }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: ordered.3
! type: F-fixed
      SUBROUTINE ORDERED_GOOD(N)
      INTEGER N

!$OMP   DO ORDERED
        DO I = 1,N
          IF (I &lt;= 10) THEN
!$OMP       ORDERED
              CALL WORK(I)
!$OMP       END ORDERED
          ENDIF

          IF (I &gt; 10) THEN
!$OMP       ORDERED
              CALL WORK(I+1)
!$OMP       END ORDERED
          ENDIF
        ENDDO
      END SUBROUTINE ORDERED_GOOD

</pre></div>
</div>
</div>
</div>
<p>../../synchronization/ordered.tex</p>
</div>
<div class="section" id="depobj-construct">
<h2><code class="docutils literal notranslate"><span class="pre">depobj</span></code> Construct<a class="headerlink" href="#depobj-construct" title="Permalink to this headline">¶</a></h2>
<p><strong>constructs!depobj <code class="docutils literal notranslate"><span class="pre">depobj</span></code></strong> <strong>depobj construct <code class="docutils literal notranslate"><span class="pre">depobj</span></code> construct</strong> <strong>depobj construct <code class="docutils literal notranslate"><span class="pre">depobj</span></code> construct!depend clause <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause</strong> <strong>depend clause <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause</strong> <strong>clauses!depend <code class="docutils literal notranslate"><span class="pre">depend</span></code></strong></p>
<p>The stand-alone <code class="docutils literal notranslate"><span class="pre">depobj</span></code> construct provides a mechanism  to create a  <em>depend object</em>  that expresses a dependence to be  used subsequently in the <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause of another construct. The dependence is created from a dependence type and a storage location, within a <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause of an <code class="docutils literal notranslate"><span class="pre">depobj</span></code> construct;  and it is stored in the depend object. The depend object is represented by a variable of type <code class="docutils literal notranslate"><span class="pre">omp_depend_t</span></code>  in C/C++ (by a scalar variable of integer kind <code class="docutils literal notranslate"><span class="pre">omp_depend_kind</span></code> in Fortran).</p>
<p><strong>depobj construct <code class="docutils literal notranslate"><span class="pre">depobj</span></code> construct!update clause <code class="docutils literal notranslate"><span class="pre">update</span></code> clause</strong> <strong>update clause <code class="docutils literal notranslate"><span class="pre">update</span></code> clause</strong> <strong>clauses!update <code class="docutils literal notranslate"><span class="pre">update</span></code></strong> <strong>depobj construct <code class="docutils literal notranslate"><span class="pre">depobj</span></code> construct!destroy clause <code class="docutils literal notranslate"><span class="pre">destroy</span></code> clause</strong> <strong>destroy clause <code class="docutils literal notranslate"><span class="pre">destroy</span></code> clause</strong> <strong>clauses!destroy <code class="docutils literal notranslate"><span class="pre">destroy</span></code></strong> In the example below the stand-alone <code class="docutils literal notranslate"><span class="pre">depobj</span></code> construct uses the  <code class="docutils literal notranslate"><span class="pre">depend</span></code>, <code class="docutils literal notranslate"><span class="pre">update</span></code> and <code class="docutils literal notranslate"><span class="pre">destroy</span></code> clauses to   <em>initialize</em> ,  <em>update</em>  and  <em>uninitialize</em>  a depend object (<code class="docutils literal notranslate"><span class="pre">obj</span></code>).</p>
<p>The first <code class="docutils literal notranslate"><span class="pre">depobj</span></code> construct initializes the <code class="docutils literal notranslate"><span class="pre">obj</span></code>  depend object with  an <code class="docutils literal notranslate"><span class="pre">inout</span></code> dependence type with a storage  location defined by variable <code class="docutils literal notranslate"><span class="pre">a</span></code>.   This dependence is passed into the  <em>driver</em>   routine via the <code class="docutils literal notranslate"><span class="pre">obj</span></code> depend object.</p>
<p>In the first  <em>driver</em>  routine call, <strong>Task 1</strong> uses the dependence of the object (<code class="docutils literal notranslate"><span class="pre">inout</span></code>),  while <strong>Task 2</strong> uses an <code class="docutils literal notranslate"><span class="pre">in</span></code> dependence specified  directly in a <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause. For these task dependences <strong>Task 1</strong> must execute and  complete before <strong>Task 2</strong> begins.</p>
<p>Before the second call to  <em>driver</em> , <code class="docutils literal notranslate"><span class="pre">obj</span></code> is updated  using the <code class="docutils literal notranslate"><span class="pre">depobj</span></code> construct to represent an <code class="docutils literal notranslate"><span class="pre">in</span></code> dependence.  Hence, in the second call to  <em>driver</em> , <strong>Task 1</strong> will have an <code class="docutils literal notranslate"><span class="pre">in</span></code> dependence; and <strong>Task 1</strong> and  <strong>Task 2</strong> can execute simultaneously. Note: in an <code class="docutils literal notranslate"><span class="pre">update</span></code> clause, only the dependence type can be (is) updated.</p>
<p>The third <code class="docutils literal notranslate"><span class="pre">depobj</span></code> construct uses the <code class="docutils literal notranslate"><span class="pre">destroy</span></code> clause. It frees resources as it puts the depend object in an uninitialized state– effectively destroying the depend object. After an object has been uninitialized it can be initialized again with a new dependence type <strong>and</strong> a new variable.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name:       depobj.1
* type:       C
* version:    omp_5.2
*/

#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;

#define N 100
#define TRUE  1
#define FALSE 0

void driver(int update, float a[], float b[], int n, omp_depend_t *obj);

void update_copy(int update, float a[], float b[], int n);
void checkpoint(float a[],int n);
void init(float a[], int n);


int main(){

   float a[N],b[N];
   omp_depend_t obj;

   init(a, N);

   #pragma omp depobj(obj) depend(inout: a)

   driver(TRUE,  a,b,N, &amp;obj);  // updating a occurs

   #pragma omp depobj(obj) update(in)

   driver(FALSE, a,b,N, &amp;obj);  // no updating of a

   #pragma omp depobj(obj) destroy(obj)  // obj is set to uninitialized
                                         // state, resources are freed
   return 0;

}

void driver(int update, float a[], float b[], int n, omp_depend_t *obj)
{
   #pragma omp parallel num_threads(2)
   #pragma omp single
   {

      #pragma omp task depend(depobj: *obj) // Task 1, uses depend object
         update_copy(update, a,b,n); // may update a, always copy a to b

     #pragma omp task depend(in: a[:n])     // Task 2, only read a
         checkpoint(a,n);
   }
}

void update_copy(int update, float a[], float b[], int n)
{
   if(update) for(int i=0;i&lt;n;i++) a[i]+=1.0f;

   for(int i=0;i&lt;n;i++) b[i]=a[i];
}

void checkpoint(float a[], int n)
{
   for(int i=0;i&lt;n;i++) printf(&quot; %f &quot;,a[i]);
   printf(&quot;\n&quot;);
}

void init(float a[], int n)
{
   for(int i=0;i&lt;n;i++) a[i]=i;
}


</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name:       depobj.1
! type:       F-free
! version: omp_5.2

program main
    use omp_lib
    implicit none

    integer,parameter        :: N=100
    real                     :: a(N),b(N)
    integer(omp_depend_kind) :: obj

    call init(a, N)

    !$omp depobj(obj) depend(inout: a)

    call driver(.true.,  a,b,N, obj)  !! updating occurs

    !$omp depobj(obj) update(in)

    call driver(.false., a,b,N, obj)  !! no updating

    !$omp depobj(obj) destroy(obj)    !! obj is set to uninitialized
                                      !! state, resources are freed

end program

subroutine driver(update, a, b, n, obj)
   use omp_lib
   implicit none
   logical :: update
   real    :: a(n), b(n)
   integer :: n
   integer(omp_depend_kind) :: obj

   !$omp parallel num_threads(2)

     !$omp single

       !$omp task depend(depobj: obj)       !! Task 1, uses depend object
         call update_copy(update, a,b,n)
              !! update a or not, always copy a to b
       !$omp end task

       !$omp task depend(in: a)             !! Task 2, only read a
         call checkpoint(a,n)
       !$omp end task

     !$omp end single

   !$omp end parallel

end subroutine

subroutine update_copy(update, a, b, n)
   implicit none
   logical :: update
   real    :: a(n), b(n)
   integer :: n

   if (update) a = a + 1.0

   b = a

end subroutine

subroutine checkpoint( a, n)
   implicit none
   integer :: n
   real    :: a(n)
   integer :: i

   write(*,&#39;( *(f5.0) )&#39;) (a(i), i=1,n)
end subroutine

subroutine init(a,n)
   implicit none
   integer :: n
   real    :: a(n)
   integer :: i

   a=[ (i, i=1,n) ]
end subroutine

</pre></div>
</div>
</div>
</div>
<p>../../synchronization/depobj.tex</p>
</div>
<div class="section" id="doacross-loop-nest">
<h2>Doacross Loop Nest<a class="headerlink" href="#doacross-loop-nest" title="Permalink to this headline">¶</a></h2>
<p><strong>dependences!doacross loop nest</strong> <strong>doacross loop nest!ordered construct <code class="docutils literal notranslate"><span class="pre">ordered</span></code> construct</strong> <strong>ordered construct <code class="docutils literal notranslate"><span class="pre">ordered</span></code> construct!doacross loop nest</strong> <strong>doacross loop nest!doacross clause <code class="docutils literal notranslate"><span class="pre">doacross</span></code> clause</strong> <strong>constructs!ordered <code class="docutils literal notranslate"><span class="pre">ordered</span></code></strong> <strong>clauses!doacross <code class="docutils literal notranslate"><span class="pre">doacross</span></code></strong> <strong>doacross clause <code class="docutils literal notranslate"><span class="pre">doacross</span></code> clause</strong></p>
<p>An <code class="docutils literal notranslate"><span class="pre">ordered</span></code> clause can be used on a loop construct with an integer parameter argument to define the number of associated loops within  a  <em>doacross loop nest</em>  where cross-iteration dependences exist. A <code class="docutils literal notranslate"><span class="pre">doacross</span></code> clause on an <code class="docutils literal notranslate"><span class="pre">ordered</span></code> construct within an ordered  loop describes the dependences of the  <em>doacross</em>  loops.</p>
<p>In the code below, the <code class="docutils literal notranslate"><span class="pre">doacross(sink:i-1)</span></code> clause defines an  <em>i-1</em>   to  <em>i</em>  cross-iteration dependence that specifies a wait point for  the completion of computation from iteration  <em>i-1</em>  before proceeding  to the subsequent statements. The <code class="docutils literal notranslate"><span class="pre">doacross(source:omp_cur_iteration)</span></code>  or <code class="docutils literal notranslate"><span class="pre">doacross(source:)</span></code> clause indicates  the completion of computation from the current iteration ( <em>i</em> )  to satisfy the cross-iteration dependence that arises from the iteration. The <code class="docutils literal notranslate"><span class="pre">omp_cur_iteration</span></code> keyword is optional for the <code class="docutils literal notranslate"><span class="pre">source</span></code> dependence type. For this example the same sequential ordering could have been achieved  with an <code class="docutils literal notranslate"><span class="pre">ordered</span></code> clause without a parameter, on the loop directive,  and a single <code class="docutils literal notranslate"><span class="pre">ordered</span></code> directive without the <code class="docutils literal notranslate"><span class="pre">doacross</span></code> clause specified for the statement executing the  <em>bar</em>  function.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: doacross.1
* type: C
* version: omp_5.2
*/

float foo(int i);
float bar(float a, float b);
float baz(float b);

void work( int N, float *A, float *B, float *C )
{
  int i;

  #pragma omp for ordered(1)
  for (i=1; i&lt;N; i++)
  {
    A[i] = foo(i);

  #pragma omp ordered doacross(sink: i-1)
    B[i] = bar(A[i], B[i-1]);
  #pragma omp ordered doacross(source: omp_cur_iteration)

    C[i] = baz(B[i]);
  }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: doacross.1
! type: F-free
! version:    omp_5.2

subroutine work( N, A, B, C )
  integer :: N, i
  real, dimension(N) :: A, B, C
  real, external :: foo, bar, baz

  !$omp do ordered(1)
  do i=2, N
    A(i) = foo(i)

  !$omp ordered doacross(sink: i-1)
    B(i) = bar(A(i), B(i-1))
  !$omp ordered doacross(source: omp_cur_iteration)

    C(i) = baz(B(i))
  end do
end subroutine

</pre></div>
</div>
</div>
</div>
<p>The following code is similar to the previous example but with   <em>doacross loop nest</em>  extended to two nested loops,  <em>i</em>  and  <em>j</em> ,  as specified by the <code class="docutils literal notranslate"><span class="pre">ordered(2)</span></code> clause on the loop directive.  In the C/C++ code, the  <em>i</em>  and  <em>j</em>  loops are the first and second associated loops, respectively, whereas in the Fortran code, the  <em>j</em>  and  <em>i</em>  loops are the first and second associated loops, respectively. The <code class="docutils literal notranslate"><span class="pre">doacross(sink:i-1,j)</span></code> and <code class="docutils literal notranslate"><span class="pre">doacross(sink:i,j-1)</span></code> clauses in  the C/C++ code define cross-iteration dependences in two dimensions from  iterations ( <em>i-1, j</em> ) and ( <em>i, j-1</em> ) to iteration ( <em>i, j</em> ).   Likewise, the <code class="docutils literal notranslate"><span class="pre">doacross(sink:j-1,i)</span></code> and <code class="docutils literal notranslate"><span class="pre">doacross(sink:j,i-1)</span></code> clauses  in the Fortran code define cross-iteration dependences from iterations  ( <em>j-1, i</em> ) and ( <em>j, i-1</em> ) to iteration ( <em>j, i</em> ).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: doacross.2
* type: C
* version: omp_5.2
*/

float foo(int i, int j);
float bar(float a, float b, float c);
float baz(float b);

void work( int N, int M, float **A, float **B, float **C )
{
  int i, j;

  #pragma omp for ordered(2)
  for (i=1; i&lt;N; i++)
  {
    for (j=1; j&lt;M; j++)
    {
      A[i][j] = foo(i, j);

  #pragma omp ordered doacross(sink: i-1,j) doacross(sink: i,j-1)
      B[i][j] = bar(A[i][j], B[i-1][j], B[i][j-1]);
  #pragma omp ordered doacross(source:)

      C[i][j] = baz(B[i][j]);
    }
  }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: doacross.2
! type: F-free
! version:    omp_5.2

subroutine work( N, M, A, B, C )
  integer :: N, M, i, j
  real, dimension(M,N) :: A, B, C
  real, external :: foo, bar, baz

  !$omp do ordered(2)
  do j=2, N
    do i=2, M
      A(i,j) = foo(i, j)

    !$omp ordered doacross(sink: j-1,i) doacross(sink: j,i-1)
      B(i,j) = bar(A(i,j), B(i-1,j), B(i,j-1))
    !$omp ordered doacross(source:)

      C(i,j) = baz(B(i,j))
    end do
  end do
end subroutine

</pre></div>
</div>
</div>
</div>
<p>The following example shows the incorrect use of the <code class="docutils literal notranslate"><span class="pre">ordered</span></code>  directive with a <code class="docutils literal notranslate"><span class="pre">doacross</span></code> clause.  There are two issues with the code.   The first issue is a missing <code class="docutils literal notranslate"><span class="pre">ordered</span></code> <code class="docutils literal notranslate"><span class="pre">doacross(source:)</span></code> directive, which could cause a deadlock.   The second issue is the <code class="docutils literal notranslate"><span class="pre">doacross(sink:i+1,j)</span></code> and <code class="docutils literal notranslate"><span class="pre">doacross(sink:i,j+1)</span></code>  clauses define dependences on lexicographically later  source iterations ( <em>i+1, j</em> ) and ( <em>i, j+1</em> ), which could cause  a deadlock as well since they may not start to execute until the current iteration completes.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: doacross.3
* type: C
* version: omp_5.2
*/

#define N 100

void work_wrong(double p[][N][N])
{
  int i, j, k;

  #pragma omp parallel for ordered(2) private(i,j,k)
  for (i=1; i&lt;N-1; i++)
  {
    for (j=1; j&lt;N-1; j++)
    {
  #pragma omp ordered doacross(sink: i-1,j) doacross(sink: i+1,j) \
                      doacross(sink: i,j-1) doacross(sink: i,j+1)
      for (k=1; k&lt;N-1; k++)
      {
        double tmp1 = p[i-1][j][k] + p[i+1][j][k];
        double tmp2 = p[i][j-1][k] + p[i][j+1][k];
        double tmp3 = p[i][j][k-1] + p[i][j][k+1];
        p[i][j][k] = (tmp1 + tmp2 + tmp3) / 6.0;
      }
/* missing #pragma omp ordered doacross(source:) */
    }
  }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: doacross.3
! type: F-free
! version:    omp_5.2

subroutine work_wrong(N, p)
  integer :: N
  real(8), dimension(N,N,N) :: p
  integer :: i, j, k
  real(8) :: tmp1, tmp2, tmp3

!$omp parallel do ordered(2) private(i,j,k,tmp1,tmp2,tmp3)
  do i=2, N-1
    do j=2, N-1
    !$omp ordered doacross(sink: i-1,j) doacross(sink: i+1,j) &amp;
    !$omp&amp;        doacross(sink: i,j-1) doacross(sink: i,j+1)
      do k=2, N-1
        tmp1 = p(k-1,j,i) + p(k+1,j,i)
        tmp2 = p(k,j-1,i) + p(k,j+1,i)
        tmp3 = p(k,j,i-1) + p(k,j,i+1)
        p(k,j,i) = (tmp1 + tmp2 + tmp3) / 6.0
      end do
! missing !$omp ordered doacross(source:)
    end do
  end do
end subroutine

</pre></div>
</div>
</div>
</div>
<p>The following example illustrates the use of the <code class="docutils literal notranslate"><span class="pre">collapse</span></code> clause for a  <em>doacross loop nest</em> .  The  <em>i</em>  and  <em>j</em>  loops are the associated loops for the collapsed loop as well as for the  <em>doacross loop nest</em> . The example also shows a compliant usage of the dependence source directive placed before the corresponding sink directive. Checking the completion of computation from previous iterations at the sink point can occur after the source statement.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: doacross.4
* type: C
* version: omp_5.2
*/

double foo(int i, int j);

void work( int N, int M, double **A, double **B, double **C )
{
  int i, j;
  double alpha = 1.2;

  #pragma omp for collapse(2) ordered(2)
  for (i = 1; i &lt; N-1; i++)
  {
    for (j = 1; j &lt; M-1; j++)
    {
      A[i][j] = foo(i, j);
  #pragma omp ordered doacross(source:)

      B[i][j] = alpha * A[i][j];

  #pragma omp ordered doacross(sink: i-1,j) doacross(sink: i,j-1)
      C[i][j] = 0.2 * (A[i-1][j] + A[i+1][j] +
                A[i][j-1] + A[i][j+1] + A[i][j]);
    }
  }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: doacross.4
! type: F-free
! version:    omp_5.2

subroutine work( N, M, A, B, C )
  integer :: N, M
  real(8), dimension(M, N) :: A, B, C
  real(8), external :: foo
  integer :: i, j
  real(8) :: alpha = 1.2

  !$omp do collapse(2) ordered(2)
  do j=2, N-1
    do i=2, M-1
      A(i,j) = foo(i, j)
    !$omp ordered doacross(source:)

      B(i,j) = alpha * A(i,j)

    !$omp ordered doacross(sink: j,i-1) doacross(sink: j-1,i)
      C(i,j) = 0.2 * (A(i-1,j) + A(i+1,j) +  &amp;
               A(i,j-1) + A(i,j+1) + A(i,j))
    end do
  end do
end subroutine

</pre></div>
</div>
</div>
</div>
<p>../../synchronization/doacross.tex</p>
</div>
<div class="section" id="lock-routines">
<h2>Lock Routines<a class="headerlink" href="#lock-routines" title="Permalink to this headline">¶</a></h2>
<p>This section is about the use of lock routines for synchronization. ../../synchronization/locks.tex</p>
<div class="section" id="omp-init-lock-routine">
<h3><code class="docutils literal notranslate"><span class="pre">omp_init_lock</span></code> Routine<a class="headerlink" href="#omp-init-lock-routine" title="Permalink to this headline">¶</a></h3>
<p><strong>routines!omp_init_lock <code class="docutils literal notranslate"><span class="pre">omp_init_lock</span></code></strong> <strong>omp_init_lock routine <code class="docutils literal notranslate"><span class="pre">omp_init_lock</span></code> routine</strong> The following example demonstrates how to initialize an array of locks in a <code class="docutils literal notranslate"><span class="pre">parallel</span></code>  region by using <code class="docutils literal notranslate"><span class="pre">omp_init_lock</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: init_lock.1
* type: C++
*/
#include &lt;omp.h&gt;

omp_lock_t *new_locks() {
  int i;
  omp_lock_t *lock = new omp_lock_t[1000];

  #pragma omp parallel for private(i)
    for (i=0; i&lt;1000; i++)
    { omp_init_lock(&amp;lock[i]); }

    return lock;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: init_lock.1
! type: F-fixed
      FUNCTION NEW_LOCKS()
        USE OMP_LIB        ! or INCLUDE &quot;omp_lib.h&quot;
        INTEGER(OMP_LOCK_KIND), DIMENSION(1000) :: NEW_LOCKS
        INTEGER I

!$OMP   PARALLEL DO PRIVATE(I)
          DO I=1,1000
            CALL OMP_INIT_LOCK(NEW_LOCKS(I))
          END DO
!$OMP   END PARALLEL DO

      END FUNCTION NEW_LOCKS

</pre></div>
</div>
</div>
</div>
<p>../../synchronization/init_lock.tex</p>
</div>
<div class="section" id="omp-init-lock-with-hint-routine">
<h3><code class="docutils literal notranslate"><span class="pre">omp_init_lock_with_hint</span></code> Routine<a class="headerlink" href="#omp-init-lock-with-hint-routine" title="Permalink to this headline">¶</a></h3>
<p><strong>routines!omp_init_lock_with_hint <code class="docutils literal notranslate"><span class="pre">omp_init_lock_with_hint</span></code></strong> <strong>omp_init_lock_with_hint routine <code class="docutils literal notranslate"><span class="pre">omp_init_lock_with_hint</span></code> routine</strong> The following example demonstrates how to initialize an array of locks in a <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region by using <code class="docutils literal notranslate"><span class="pre">omp_init_lock_with_hint</span></code>. Note, hints are combined with an <code class="docutils literal notranslate"><span class="pre">|</span></code> or <code class="docutils literal notranslate"><span class="pre">+</span></code> operator in C/C++ and a <code class="docutils literal notranslate"><span class="pre">+</span></code> operator in Fortran.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: init_lock_with_hint.1
* type: C++
* version: omp_5.0
*/
#include &lt;omp.h&gt;

omp_lock_t *new_locks()
{
  int i;
  omp_lock_t *lock = new omp_lock_t[1000];

  #pragma omp parallel for private(i)
    for (i=0; i&lt;1000; i++)
    {
      omp_init_lock_with_hint(&amp;lock[i],
        static_cast&lt;omp_lock_hint_t&gt;(omp_sync_hint_contended |
                                     omp_sync_hint_speculative));
    }
    return lock;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: init_lock_with_hint.1
! type: F-fixed
! version: omp_5.0
      FUNCTION NEW_LOCKS()
        USE OMP_LIB        ! or INCLUDE &quot;omp_lib.h&quot;
        INTEGER(OMP_LOCK_KIND), DIMENSION(1000) :: NEW_LOCKS

        INTEGER I

!$OMP   PARALLEL DO PRIVATE(I)
          DO I=1,1000
            CALL OMP_INIT_LOCK_WITH_HINT(NEW_LOCKS(I),
     &amp;             OMP_SYNC_HINT_CONTENDED + OMP_SYNC_HINT_SPECULATIVE)
          END DO
!$OMP   END PARALLEL DO

      END FUNCTION NEW_LOCKS

</pre></div>
</div>
</div>
</div>
<p>../../synchronization/init_lock_with_hint.tex</p>
</div>
<div class="section" id="ownership-of-locks">
<h3>Ownership of Locks<a class="headerlink" href="#ownership-of-locks" title="Permalink to this headline">¶</a></h3>
<p><strong>routines!omp_unset_lock <code class="docutils literal notranslate"><span class="pre">omp_unset_lock</span></code></strong> <strong>omp_unset_lock routine <code class="docutils literal notranslate"><span class="pre">omp_unset_lock</span></code> routine</strong> Ownership of locks has changed since OpenMP 2.5. In OpenMP 2.5, locks are owned  by threads; so a lock released by the <code class="docutils literal notranslate"><span class="pre">omp_unset_lock</span></code> routine must be  owned by the same thread executing the routine.  Beginning with OpenMP 3.0, locks are owned  by task regions; so a lock released by the <code class="docutils literal notranslate"><span class="pre">omp_unset_lock</span></code> routine in  a task region must be owned by the same task region.</p>
<p>This change in ownership requires extra care when using locks. The following program  is conforming in OpenMP 2.5 because the thread that releases the lock <code class="docutils literal notranslate"><span class="pre">lck</span></code>  in the parallel region is the same thread that acquired the lock in the sequential  part of the program (primary thread of parallel region and the initial thread are  the same). However, it is not conforming beginning with OpenMP 3.0, because the task  region that releases the lock <code class="docutils literal notranslate"><span class="pre">lck</span></code> is different from the task region that  acquires the lock.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: lock_owner.1
* type: C
* version:    omp_5.1
*/
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;

int main()
{
  int x;
  omp_lock_t lck;

  omp_init_lock (&amp;lck);
  omp_set_lock (&amp;lck);
  x = 0;

#pragma omp parallel shared (x)
  {
    #pragma omp masked
      {
        x = x + 1;
        omp_unset_lock (&amp;lck);
      }

    /* Some more stuff. */
  }
  omp_destroy_lock (&amp;lck);
  return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: lock_owner.1
! type: F-fixed
! version:    omp_5.1
        program lock
        use omp_lib
        integer :: x
        integer (kind=omp_lock_kind) :: lck

        call omp_init_lock (lck)
        call omp_set_lock(lck)
        x = 0

!$omp parallel shared (x)
!$omp masked
        x = x + 1
        call omp_unset_lock(lck)
!$omp end masked

!       Some more stuff.
!$omp end parallel

        call omp_destroy_lock(lck)

        end

</pre></div>
</div>
</div>
</div>
<p>../../synchronization/lock_owner.tex</p>
</div>
<div class="section" id="simple-lock-routines">
<h3>Simple Lock Routines<a class="headerlink" href="#simple-lock-routines" title="Permalink to this headline">¶</a></h3>
<p><strong>routines!omp_set_lock <code class="docutils literal notranslate"><span class="pre">omp_set_lock</span></code></strong> <strong>omp_set_lock routine <code class="docutils literal notranslate"><span class="pre">omp_set_lock</span></code> routine</strong> <strong>routines!omp_test_lock <code class="docutils literal notranslate"><span class="pre">omp_test_lock</span></code></strong> <strong>omp_test_lock routine <code class="docutils literal notranslate"><span class="pre">omp_test_lock</span></code> routine</strong> In the following example, the lock routines cause the threads to be idle while  waiting for entry to the first critical section, but to do other work while waiting  for entry to the second. The <code class="docutils literal notranslate"><span class="pre">omp_set_lock</span></code> function blocks, but the <code class="docutils literal notranslate"><span class="pre">omp_test_lock</span></code>  function does not, allowing the work in <code class="docutils literal notranslate"><span class="pre">skip</span></code> to be done.</p>
<p>Note that the argument to the lock routines should have type  <code class="docutils literal notranslate"><span class="pre">omp_lock_t</span></code> (or <code class="docutils literal notranslate"><span class="pre">omp_lock_kind</span></code> in Fortran),  and that there is no need to flush the lock variable ( <em>lck</em> ).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: simple_lock.1
* type: C
*/
#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;
void skip(int i) {}
void work(int i) {}
int main()
{
  omp_lock_t lck;
  int id;
  omp_init_lock(&amp;lck);

  #pragma omp parallel shared(lck) private(id)
  {
    id = omp_get_thread_num();

    omp_set_lock(&amp;lck);
    /*  only one thread at a time can execute this printf */
    printf(&quot;My thread id is %d.\n&quot;, id);
    omp_unset_lock(&amp;lck);

    while (! omp_test_lock(&amp;lck)) {
      skip(id);   /* we do not yet have the lock,
                     so we must do something else */
    }

    work(id);      /* we now have the lock
                      and can do the work */

    omp_unset_lock(&amp;lck);
  }
  omp_destroy_lock(&amp;lck);

  return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: simple_lock.1
! type: F-fixed
      SUBROUTINE SKIP(ID)
      END SUBROUTINE SKIP

      SUBROUTINE WORK(ID)
      END SUBROUTINE WORK

      PROGRAM SIMPLELOCK

        INCLUDE &quot;omp_lib.h&quot;     ! or USE OMP_LIB

        INTEGER(OMP_LOCK_KIND) LCK
        INTEGER ID

        CALL OMP_INIT_LOCK(LCK)

!$OMP   PARALLEL SHARED(LCK) PRIVATE(ID)
          ID = OMP_GET_THREAD_NUM()
          CALL OMP_SET_LOCK(LCK)
          PRINT *, &#39;My thread id is &#39;, ID
          CALL OMP_UNSET_LOCK(LCK)

          DO WHILE (.NOT. OMP_TEST_LOCK(LCK))
            CALL SKIP(ID)     ! We do not yet have the lock
                              ! so we must do something else
          END DO

          CALL WORK(ID)       ! We now have the lock
                              ! and can do the work

          CALL OMP_UNSET_LOCK( LCK )

!$OMP   END PARALLEL

        CALL OMP_DESTROY_LOCK( LCK )

      END PROGRAM SIMPLELOCK

</pre></div>
</div>
</div>
</div>
<p>../../synchronization/simple_lock.tex</p>
</div>
<div class="section" id="nestable-lock-routines">
<h3>Nestable Lock Routines<a class="headerlink" href="#nestable-lock-routines" title="Permalink to this headline">¶</a></h3>
<p><strong>nestable lock</strong> The following example demonstrates how a nestable lock can be used to synchronize  updates both to a whole structure and to one of its members.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: nestable_lock.1
* type: C
*/

#include &lt;omp.h&gt;

typedef struct {
   int a,b;
   omp_nest_lock_t lck;
} pair;

int work1();
int work2();
int work3();

void incr_a(pair *p, int a)
{

  /* Called only from incr_pair, no need to lock. */
  p-&gt;a += a;

}

void incr_b(pair *p, int b)
{

  /* Called both from incr_pair and elsewhere, */
  /* so need a nestable lock. */

  omp_set_nest_lock(&amp;p-&gt;lck);
  p-&gt;b += b;
  omp_unset_nest_lock(&amp;p-&gt;lck);

}

void incr_pair(pair *p, int a, int b)
{

  omp_set_nest_lock(&amp;p-&gt;lck);
  incr_a(p, a);
  incr_b(p, b);
  omp_unset_nest_lock(&amp;p-&gt;lck);

}

void nestlock(pair *p)
{

  #pragma omp parallel sections
  {
    #pragma omp section
      incr_pair(p, work1(), work2());
    #pragma omp section
      incr_b(p, work3());
  }

}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: nestable_lock.1
! type: F-fixed
      MODULE DATA
        USE OMP_LIB, ONLY: OMP_NEST_LOCK_KIND
        TYPE LOCKED_PAIR
          INTEGER A
          INTEGER B
          INTEGER (OMP_NEST_LOCK_KIND) LCK
       END TYPE
      END MODULE DATA

      SUBROUTINE INCR_A(P, A)
        ! called only from INCR_PAIR, no need to lock
        USE DATA
        TYPE(LOCKED_PAIR) :: P
        INTEGER A
        P%A = P%A + A
      END SUBROUTINE INCR_A

      SUBROUTINE INCR_B(P, B)
        ! called from both INCR_PAIR and elsewhere,
        ! so we need a nestable lock
        USE OMP_LIB       ! or INCLUDE &quot;omp_lib.h&quot;
        USE DATA
        TYPE(LOCKED_PAIR) :: P
        INTEGER B
        CALL OMP_SET_NEST_LOCK(P%LCK)
        P%B = P%B + B
        CALL OMP_UNSET_NEST_LOCK(P%LCK)
      END SUBROUTINE INCR_B

      SUBROUTINE INCR_PAIR(P, A, B)
        USE OMP_LIB        ! or INCLUDE &quot;omp_lib.h&quot;
        USE DATA
        TYPE(LOCKED_PAIR) :: P
        INTEGER A
        INTEGER B

        CALL OMP_SET_NEST_LOCK(P%LCK)
        CALL INCR_A(P, A)
        CALL INCR_B(P, B)
        CALL OMP_UNSET_NEST_LOCK(P%LCK)
      END SUBROUTINE INCR_PAIR

      SUBROUTINE NESTLOCK(P)
        USE OMP_LIB        ! or INCLUDE &quot;omp_lib.h&quot;
        USE DATA
        TYPE(LOCKED_PAIR) :: P
        INTEGER WORK1, WORK2, WORK3
        EXTERNAL WORK1, WORK2, WORK3

!$OMP   PARALLEL SECTIONS

!$OMP   SECTION
          CALL INCR_PAIR(P, WORK1(), WORK2())
!$OMP   SECTION
          CALL INCR_B(P, WORK3())
!$OMP   END PARALLEL SECTIONS

      END SUBROUTINE NESTLOCK

</pre></div>
</div>
</div>
</div>
<p>../../synchronization/nestable_lock.tex</p>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "native"
        },
        kernelOptions: {
            kernelName: "native",
            path: "./contents"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'native'</script>

              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="Chap_loop_transformations.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">&lt;no title&gt;</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="Chap_data_environment.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Data Environment</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      By The OpenMP Community<br/>
    
        &copy; Copyright 2021.<br/>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>