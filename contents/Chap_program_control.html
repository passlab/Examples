
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Program Control &#8212; OpenMP Application Programming Interface Examples</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet">
  <link href="../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script>
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="&lt;no title&gt;" href="Chap_ompt_interface.html" />
    <link rel="prev" title="Memory Model" href="Chap_memory_model.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">OpenMP Application Programming Interface Examples</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../intro.html">
   Welcome to OMP Jupyter Book
  </a>
 </li>
</ul>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_directives.html">
   OpenMP Directive Syntax
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_parallel_execution.html">
   Parallel Execution
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_affinity.html">
   OpenMP Affinity
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_tasking.html">
   Tasking
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_SIMD.html">
   SIMD
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_synchronization.html">
   Synchronization
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_data_environment.html">
   Data Environment
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_memory_model.html">
   Memory Model
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Program Control
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/contents/Chap_program_control.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
                onclick="printPdf(this)" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/passlab/Examples"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/passlab/Examples/issues/new?title=Issue%20on%20page%20%2Fcontents/Chap_program_control.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/passlab/Examples/main?urlpath=lab/tree/notebook/contents/Chap_program_control.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#conditional-compilation">
   Conditional Compilation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#internal-control-variables-icvs">
   Internal Control Variables (ICVs)
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#placement-of-flush-barrier-taskwait-and-taskyield-directives">
   Placement of
   <code class="docutils literal notranslate">
    <span class="pre">
     flush
    </span>
   </code>
   ,
   <code class="docutils literal notranslate">
    <span class="pre">
     barrier
    </span>
   </code>
   ,
   <code class="docutils literal notranslate">
    <span class="pre">
     taskwait
    </span>
   </code>
   and
   <code class="docutils literal notranslate">
    <span class="pre">
     taskyield
    </span>
   </code>
   Directives
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#cancellation-constructs">
   Cancellation Constructs
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#requires-directive">
   <code class="docutils literal notranslate">
    <span class="pre">
     requires
    </span>
   </code>
   Directive
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#declare-variant-directive">
   <code class="docutils literal notranslate">
    <span class="pre">
     declare
    </span>
   </code>
   <code class="docutils literal notranslate">
    <span class="pre">
     variant
    </span>
   </code>
   Directive
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#metadirectives">
   Metadirectives
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#nested-loop-constructs">
   Nested Loop Constructs
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#restrictions-on-nesting-of-regions">
   Restrictions on Nesting of Regions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#target-offload">
   Target Offload
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#controlling-concurrency-and-reproducibility-with-the-order-clause">
   Controlling Concurrency and Reproducibility with  the
   <code class="docutils literal notranslate">
    <span class="pre">
     order
    </span>
   </code>
   Clause
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#interop-construct">
   <code class="docutils literal notranslate">
    <span class="pre">
     interop
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#utilities">
   Utilities
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#timing-routines">
     Timing Routines
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#environment-display">
     Environment Display
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#error-directive">
     <code class="docutils literal notranslate">
      <span class="pre">
       error
      </span>
     </code>
     Directive
    </a>
   </li>
  </ul>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Program Control</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#conditional-compilation">
   Conditional Compilation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#internal-control-variables-icvs">
   Internal Control Variables (ICVs)
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#placement-of-flush-barrier-taskwait-and-taskyield-directives">
   Placement of
   <code class="docutils literal notranslate">
    <span class="pre">
     flush
    </span>
   </code>
   ,
   <code class="docutils literal notranslate">
    <span class="pre">
     barrier
    </span>
   </code>
   ,
   <code class="docutils literal notranslate">
    <span class="pre">
     taskwait
    </span>
   </code>
   and
   <code class="docutils literal notranslate">
    <span class="pre">
     taskyield
    </span>
   </code>
   Directives
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#cancellation-constructs">
   Cancellation Constructs
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#requires-directive">
   <code class="docutils literal notranslate">
    <span class="pre">
     requires
    </span>
   </code>
   Directive
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#declare-variant-directive">
   <code class="docutils literal notranslate">
    <span class="pre">
     declare
    </span>
   </code>
   <code class="docutils literal notranslate">
    <span class="pre">
     variant
    </span>
   </code>
   Directive
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#metadirectives">
   Metadirectives
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#nested-loop-constructs">
   Nested Loop Constructs
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#restrictions-on-nesting-of-regions">
   Restrictions on Nesting of Regions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#target-offload">
   Target Offload
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#controlling-concurrency-and-reproducibility-with-the-order-clause">
   Controlling Concurrency and Reproducibility with  the
   <code class="docutils literal notranslate">
    <span class="pre">
     order
    </span>
   </code>
   Clause
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#interop-construct">
   <code class="docutils literal notranslate">
    <span class="pre">
     interop
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#utilities">
   Utilities
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#timing-routines">
     Timing Routines
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#environment-display">
     Environment Display
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#error-directive">
     <code class="docutils literal notranslate">
      <span class="pre">
       error
      </span>
     </code>
     Directive
    </a>
   </li>
  </ul>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="program-control">
<h1>Program Control<a class="headerlink" href="#program-control" title="Permalink to this headline">¶</a></h1>
<p>{program_control}</p>
<p>Basic concepts and mechanisms for directing and controlling a program compilation and execution are provided in this introduction and illustrated in subsequent examples.</p>
<p>CONDITIONAL COMPILATION and EXECUTION</p>
<p>Conditional compilation can be performed with conventional #ifdef directives in C, C++, and Fortran, and additionally with OpenMP sentinel (<code class="docutils literal notranslate"><span class="pre">!$</span></code>) in Fortran.  The <code class="docutils literal notranslate"><span class="pre">if</span></code> clause on some directives can direct the runtime to ignore or alter the behavior of the construct. Of course, the base-language <code class="docutils literal notranslate"><span class="pre">if</span></code> statements can be used to control the execution of stand-alone directives (such as <code class="docutils literal notranslate"><span class="pre">flush</span></code>, <code class="docutils literal notranslate"><span class="pre">barrier</span></code>, <code class="docutils literal notranslate"><span class="pre">taskwait</span></code>,  and  <code class="docutils literal notranslate"><span class="pre">taskyield</span></code>). However, the directives must appear in a block structure, and not as a substatement. The <code class="docutils literal notranslate"><span class="pre">metadirective</span></code> and <code class="docutils literal notranslate"><span class="pre">declare</span></code> <code class="docutils literal notranslate"><span class="pre">variant</span></code> directives provide conditional  selection of directives and routines for compilation (and use), respectively. The <code class="docutils literal notranslate"><span class="pre">assume</span></code> and <code class="docutils literal notranslate"><span class="pre">requires</span></code> directives provide invariants for optimizing compilation, and essential features for compilation  and correct execution, respectively.</p>
<p>CANCELLATION</p>
<p>Cancellation (termination) of the normal sequence of execution for the threads in an OpenMP region can be  accomplished with the <code class="docutils literal notranslate"><span class="pre">cancel</span></code> construct.  The construct uses a  <em>construct-type-clause</em>  to set the region-type to activate for the cancellation.  That is, inclusion  of one of the  <em>construct-type-clause</em>  names <code class="docutils literal notranslate"><span class="pre">parallel</span></code>, <code class="docutils literal notranslate"><span class="pre">for</span></code>,  <code class="docutils literal notranslate"><span class="pre">do</span></code>, <code class="docutils literal notranslate"><span class="pre">sections</span></code> or <code class="docutils literal notranslate"><span class="pre">taskgroup</span></code> on the directive line  activates the corresponding region.   The <code class="docutils literal notranslate"><span class="pre">cancel</span></code> construct is activated by the first encountering thread,  and it continues execution at the end of the named region. The <code class="docutils literal notranslate"><span class="pre">cancel</span></code> construct is also a cancellation point for any other thread of the team  to also continue execution at the end of the named region.</p>
<p>Also, once the specified region has been activated for cancellation any thread that encounnters  a <code class="docutils literal notranslate"><span class="pre">cancellation</span></code> <code class="docutils literal notranslate"><span class="pre">point</span></code> construct with the same named region ( <em>construct-type-clause</em> ), continues execution at the end of the region.</p>
<p>For an activated <code class="docutils literal notranslate"><span class="pre">cancel</span> <span class="pre">taskgroup</span></code> construct, the tasks that belong to the taskgroup set of the innermost enclosing taskgroup region will be canceled.</p>
<p>A task that encounters a <code class="docutils literal notranslate"><span class="pre">cancel</span></code> <code class="docutils literal notranslate"><span class="pre">taskgroup</span></code> construct continues execution at the end of its task region. Any task of the taskgroup that has already begun execution will run to completion, unless it encounters a <code class="docutils literal notranslate"><span class="pre">cancellation</span></code> <code class="docutils literal notranslate"><span class="pre">point</span></code>; tasks that have not begun execution may be discarded as completed tasks.</p>
<p>CONTROL VARIABLES</p>
<p>Internal control variables (ICV) are used by implementations to hold values which control the execution   of OpenMP regions.  Control (and hence the ICVs) may be set as implementation defaults,    or set and adjusted through environment variables, clauses, and API functions.      Initial ICV values are reported by the runtime   if the <code class="docutils literal notranslate"><span class="pre">OMP_DISPLAY_ENV</span></code> environment variable has been set to <code class="docutils literal notranslate"><span class="pre">TRUE</span></code> or <code class="docutils literal notranslate"><span class="pre">VERBOSE</span></code>.</p>
<p>NESTED CONSTRUCTS</p>
<p>Certain combinations of nested constructs are permitted, giving rise to  <em>combined</em>  constructs consisting of two or more directives.  These can be used when the two (or several) constructs would be used immediately in succession (closely nested). A  <em>combined</em>  construct can use the clauses of the component constructs without restrictions. A  <em>composite</em>  construct is a combined construct which has one or more clauses with (an often obviously) modified or restricted meaning, relative to when the constructs are uncombined.</p>
<p>Certain nestings are forbidden, and often the reasoning is obvious.  For example, worksharing constructs cannot be nested, and the <code class="docutils literal notranslate"><span class="pre">barrier</span></code> construct cannot be nested inside a worksharing construct, or a <code class="docutils literal notranslate"><span class="pre">critical</span></code> construct.  Also, <code class="docutils literal notranslate"><span class="pre">target</span></code> constructs cannot be nested, unless the nested target is a reverse offload.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">parallel</span></code> construct can be nested, as well as the <code class="docutils literal notranslate"><span class="pre">task</span></code> construct.   The parallel execution in the nested parallel construct(s) is controlled by the  <code class="docutils literal notranslate"><span class="pre">OMP_MAX_ACTIVE_LEVELS</span></code> environment variable, and the <code class="docutils literal notranslate"><span class="pre">omp_set_max_active_levels</span></code> routine.  Use the <code class="docutils literal notranslate"><span class="pre">omp_get_max_active_levels</span></code> routine to determine the maximum levels provided by an implementation. As of OpenMP 5.0, use of the <code class="docutils literal notranslate"><span class="pre">OMP_NESTED</span></code> environment variable and the <code class="docutils literal notranslate"><span class="pre">omp_set_nested</span></code> routine  has been deprecated.</p>
<p>More details on nesting can be found in the  <em>Nesting of Regions</em>  of the  <em>Directives</em>   chapter in the OpenMP Specifications document.</p>
<div class="section" id="conditional-compilation">
<h2>Conditional Compilation<a class="headerlink" href="#conditional-compilation" title="Permalink to this headline">¶</a></h2>
<p><strong>conditional compilation!_OPENMP macro <code class="docutils literal notranslate"><span class="pre">_OPENMP</span></code> macro</strong> <strong>conditional compilation!sentinel</strong></p>
<p>The following example illustrates the use of conditional compilation using the  OpenMP macro <code class="docutils literal notranslate"><span class="pre">_OPENMP</span></code>. With OpenMP compilation, the <code class="docutils literal notranslate"><span class="pre">_OPENMP</span></code>  macro becomes defined.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: cond_comp.1
* type: C
*/
#include &lt;stdio.h&gt;

int main()
{

# ifdef _OPENMP
    printf(&quot;Compiled by an OpenMP-compliant implementation.\n&quot;);
# endif

    return 0;
}

</pre></div>
</div>
</div>
</div>
<p>The following example illustrates the use of the conditional compilation sentinel.  With OpenMP compilation, the conditional compilation sentinel <code class="docutils literal notranslate"><span class="pre">!$</span></code> is recognized  and treated as two spaces. In fixed form source, statements guarded by the sentinel  must start after column 6.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: cond_comp.1
! type: F-fixed
      PROGRAM EXAMPLE

C234567890
!$    PRINT *, &quot;Compiled by an OpenMP-compliant implementation.&quot;

      END PROGRAM EXAMPLE

</pre></div>
</div>
</div>
</div>
<p>../../program_control/cond_comp.tex</p>
</div>
<div class="section" id="internal-control-variables-icvs">
<h2>Internal Control Variables (ICVs)<a class="headerlink" href="#internal-control-variables-icvs" title="Permalink to this headline">¶</a></h2>
<p><strong>internal control variables</strong></p>
<p>According to Section 2.3 of the OpenMP 4.0 specification, an OpenMP implementation must act as if there are ICVs that control  the behavior of the program.  This example illustrates two ICVs,  <em>nthreads-var</em>   and  <em>max-active-levels-var</em> . The  <em>nthreads-var</em>  ICV controls the  number of threads requested for encountered parallel regions; there is one copy  of this ICV per task. The  <em>max-active-levels-var</em>  ICV controls the maximum  number of nested active parallel regions; there is one copy of this ICV for the  whole program.</p>
<p>In the following example, the  <em>nest-var</em> ,  <em>max-active-levels-var</em> ,   <em>dyn-var</em> , and  <em>nthreads-var</em>  ICVs are modified through calls to  the runtime library routines <code class="docutils literal notranslate"><span class="pre">omp_set_nested</span></code>, <code class="docutils literal notranslate"><span class="pre">omp_set_max_active_levels</span></code>,<code class="docutils literal notranslate">&#160; <span class="pre">omp_set_dynamic</span></code>, and <code class="docutils literal notranslate"><span class="pre">omp_set_num_threads</span></code> respectively. These ICVs  affect the operation of <code class="docutils literal notranslate"><span class="pre">parallel</span></code> regions. Each implicit task generated  by a <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region has its own copy of the  <em>nest-var, dyn-var</em> ,  and  <em>nthreads-var</em>  ICVs.</p>
<p>In the following example, the new value of  <em>nthreads-var</em>  applies only to  the implicit tasks that execute the call to <code class="docutils literal notranslate"><span class="pre">omp_set_num_threads</span></code>. There  is one copy of the  <em>max-active-levels-var</em>  ICV for the whole program and  its value is the same for all tasks. This example assumes that nested parallelism  is supported.</p>
<p>The outer <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region creates a team of two threads; each of the threads  will execute one of the two implicit tasks generated by the outer <code class="docutils literal notranslate"><span class="pre">parallel</span></code>  region.</p>
<p>Each implicit task generated by the outer <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region calls <code class="docutils literal notranslate"><span class="pre">omp_set_num_threads(3)</span></code>,  assigning the value 3 to its respective copy of  <em>nthreads-var</em> . Then each  implicit task encounters an inner <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region that creates a team  of three threads; each of the threads will execute one of the three implicit tasks  generated by that inner <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region.</p>
<p>Since the outer <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region is executed by 2 threads, and the inner  by 3, there will be a total of 6 implicit tasks generated by the two inner <code class="docutils literal notranslate"><span class="pre">parallel</span></code>  regions.</p>
<p>Each implicit task generated by an inner <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region will execute  the call to <code class="docutils literal notranslate"><span class="pre">omp_set_num_threads(4)</span></code>, assigning the value 4 to its respective  copy of  <em>nthreads-var</em> .</p>
<p>The print statement in the outer <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region is executed by only one  of the threads in the team. So it will be executed only once.</p>
<p>The print statement in an inner <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region is also executed by only  one of the threads in the team. Since we have a total of two inner <code class="docutils literal notranslate"><span class="pre">parallel</span></code>  regions, the print statement will be executed twice – once per inner <code class="docutils literal notranslate"><span class="pre">parallel</span></code>  region.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: icv.1
* type: C
*/
#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;

int main (void)
{
  omp_set_nested(1);
  omp_set_max_active_levels(8);
  omp_set_dynamic(0);
  omp_set_num_threads(2);
  #pragma omp parallel
    {
      omp_set_num_threads(3);

      #pragma omp parallel
        {
          omp_set_num_threads(4);
          #pragma omp single
            {
                 // The following should print:
                 // Inner: max_act_lev=8, num_thds=3, max_thds=4
                 // Inner: max_act_lev=8, num_thds=3, max_thds=4
              printf (&quot;Inner: max_act_lev=%d, num_thds=%d, max_thds=%d\n&quot;,
              omp_get_max_active_levels(), omp_get_num_threads(),
              omp_get_max_threads());
            }
        }

      #pragma omp barrier
      #pragma omp single
        {
                 // The following should print:
                 // Outer: max_act_lev=8, num_thds=2, max_thds=3
          printf (&quot;Outer: max_act_lev=%d, num_thds=%d, max_thds=%d\n&quot;,
                  omp_get_max_active_levels(), omp_get_num_threads(),
                  omp_get_max_threads());
        }
    }
    return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: icv.1
! type: F-fixed
      program icv
      use omp_lib

      call omp_set_nested(.true.)
      call omp_set_max_active_levels(8)
      call omp_set_dynamic(.false.)
      call omp_set_num_threads(2)

!$omp parallel
      call omp_set_num_threads(3)

!$omp parallel
      call omp_set_num_threads(4)
!$omp single
!      The following should print:
!      Inner: max_act_lev= 8 , num_thds= 3 , max_thds= 4
!      Inner: max_act_lev= 8 , num_thds= 3 , max_thds= 4
       print *, &quot;Inner: max_act_lev=&quot;, omp_get_max_active_levels(),
     &amp;           &quot;, num_thds=&quot;, omp_get_num_threads(),
     &amp;           &quot;, max_thds=&quot;, omp_get_max_threads()
!$omp end single
!$omp end parallel

!$omp barrier
!$omp single
!      The following should print:
!      Outer: max_act_lev= 8 , num_thds= 2 , max_thds= 3
       print *, &quot;Outer: max_act_lev=&quot;, omp_get_max_active_levels(),
     &amp;           &quot;, num_thds=&quot;, omp_get_num_threads(),
     &amp;           &quot;, max_thds=&quot;, omp_get_max_threads()
!$omp end single
!$omp end parallel
       end

</pre></div>
</div>
</div>
</div>
<p>../../program_control/icv.tex</p>
</div>
<div class="section" id="placement-of-flush-barrier-taskwait-and-taskyield-directives">
<h2>Placement of <code class="docutils literal notranslate"><span class="pre">flush</span></code>, <code class="docutils literal notranslate"><span class="pre">barrier</span></code>, <code class="docutils literal notranslate"><span class="pre">taskwait</span></code>  and <code class="docutils literal notranslate"><span class="pre">taskyield</span></code> Directives<a class="headerlink" href="#placement-of-flush-barrier-taskwait-and-taskyield-directives" title="Permalink to this headline">¶</a></h2>
<p><strong>standalone directive placement</strong> <strong>constructs!flush <code class="docutils literal notranslate"><span class="pre">flush</span></code></strong> <strong>constructs!barrier <code class="docutils literal notranslate"><span class="pre">barrier</span></code></strong> <strong>constructs!taskwait <code class="docutils literal notranslate"><span class="pre">taskwait</span></code></strong> <strong>constructs!taskyield <code class="docutils literal notranslate"><span class="pre">taskyield</span></code></strong> <strong>flush construct <code class="docutils literal notranslate"><span class="pre">flush</span></code> construct</strong> <strong>barrier construct <code class="docutils literal notranslate"><span class="pre">barrier</span></code> construct</strong> <strong>taskwait construct <code class="docutils literal notranslate"><span class="pre">taskwait</span></code> construct</strong> <strong>taskyield construct <code class="docutils literal notranslate"><span class="pre">taskyield</span></code> construct</strong></p>
<p>The following example is non-conforming, because the <code class="docutils literal notranslate"><span class="pre">flush</span></code>, <code class="docutils literal notranslate"><span class="pre">barrier</span></code>,  <code class="docutils literal notranslate"><span class="pre">taskwait</span></code>, and <code class="docutils literal notranslate"><span class="pre">taskyield</span></code>  directives are stand-alone directives  and cannot be the immediate substatement of an <code class="docutils literal notranslate"><span class="pre">if</span></code> statement.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: standalone.1
* type: C
* version: omp_3.1
*/

void standalone_wrong()
{
  int a = 1;

 if (a != 0)
  #pragma omp flush(a)
/* incorrect as flush cannot be immediate substatement
   of if statement */

 if (a != 0)
  #pragma omp barrier
/* incorrect as barrier cannot be immediate substatement
   of if statement */

 if (a!=0)
  #pragma omp taskyield
/* incorrect as taskyield cannot be immediate substatement of if statement
*/

 if (a != 0)
  #pragma omp taskwait
/* incorrect as taskwait cannot be immediate substatement
   of if statement */

}

</pre></div>
</div>
</div>
</div>
<p>The following example is non-conforming, because the <code class="docutils literal notranslate"><span class="pre">flush</span></code>, <code class="docutils literal notranslate"><span class="pre">barrier</span></code>,  <code class="docutils literal notranslate"><span class="pre">taskwait</span></code>, and <code class="docutils literal notranslate"><span class="pre">taskyield</span></code>  directives are stand-alone directives  and cannot be the action statement of an <code class="docutils literal notranslate"><span class="pre">if</span></code> statement or a labeled branch  target.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: standalone.1
! type: F-free
! version:     omp_3.1


SUBROUTINE STANDALONE_WRONG()

  INTEGER  A

  A = 1

  ! the FLUSH directive must not be the action statement
  ! in an IF statement
  IF (A .NE. 0) !$OMP FLUSH(A)

  ! the BARRIER directive must not be the action statement
  ! in an IF statement
  IF (A .NE. 0) !$OMP BARRIER

  ! the TASKWAIT directive must not be the action statement
  ! in an IF statement
  IF (A .NE. 0) !$OMP TASKWAIT

  ! the TASKYIELD directive must not be the action statement
  ! in an IF statement
  IF (A .NE. 0) !$OMP TASKYIELD

  GOTO 100

  ! the FLUSH directive must not be a labeled branch target
  ! statement
  100 !$OMP FLUSH(A)
  GOTO 200

  ! the BARRIER directive must not be a labeled branch target
  ! statement
  200 !$OMP BARRIER
  GOTO 300

  ! the TASKWAIT directive must not be a labeled branch target
  ! statement
  300 !$OMP TASKWAIT
  GOTO 400

  ! the TASKYIELD directive must not be a labeled branch target
  ! statement
  400 !$OMP TASKYIELD

END SUBROUTINE

</pre></div>
</div>
</div>
</div>
<p>The following version of the above example is conforming because the <code class="docutils literal notranslate"><span class="pre">flush</span></code>,  <code class="docutils literal notranslate"><span class="pre">barrier</span></code>, <code class="docutils literal notranslate"><span class="pre">taskwait</span></code>, and <code class="docutils literal notranslate"><span class="pre">taskyield</span></code> directives are enclosed  in a compound statement.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: standalone.2
* type: C
* version: omp_3.1
*/
void standalone_ok()
{
  int a = 1;

  #pragma omp parallel
  {
     if (a != 0) {
  #pragma omp flush(a)
     }
     if (a != 0) {
  #pragma omp barrier
     }
     if (a != 0) {
  #pragma omp taskwait
     }
 if (a != 0) {
  #pragma omp taskyield
 }
  }
}

</pre></div>
</div>
</div>
</div>
<p>The following example is conforming because the <code class="docutils literal notranslate"><span class="pre">flush</span></code>, <code class="docutils literal notranslate"><span class="pre">barrier</span></code>,  <code class="docutils literal notranslate"><span class="pre">taskwait</span></code>, and <code class="docutils literal notranslate"><span class="pre">taskyield</span></code> directives are enclosed in an <code class="docutils literal notranslate"><span class="pre">if</span></code>  construct or follow the labeled branch target.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: standalone.2
! type: F-free
! version:     omp_3.1
SUBROUTINE STANDALONE_OK()
  INTEGER  A
  A = 1
  IF (A .NE. 0) THEN
    !$OMP FLUSH(A)
  ENDIF
  IF (A .NE. 0) THEN
    !$OMP BARRIER
  ENDIF
  IF (A .NE. 0) THEN
    !$OMP TASKWAIT
  ENDIF
  IF (A .NE. 0) THEN
    !$OMP TASKYIELD
  ENDIF
  GOTO 100
  100 CONTINUE
  !$OMP FLUSH(A)
  GOTO 200
  200 CONTINUE
  !$OMP BARRIER
  GOTO 300
  300 CONTINUE
  !$OMP TASKWAIT
  GOTO 400
  400 CONTINUE
  !$OMP TASKYIELD
END SUBROUTINE

</pre></div>
</div>
</div>
</div>
<p>../../program_control/standalone.tex</p>
</div>
<div class="section" id="cancellation-constructs">
<h2>Cancellation Constructs<a class="headerlink" href="#cancellation-constructs" title="Permalink to this headline">¶</a></h2>
<p><strong>cancellation!cancel construct <code class="docutils literal notranslate"><span class="pre">cancel</span></code> construct</strong> <strong>constructs!cancel <code class="docutils literal notranslate"><span class="pre">cancel</span></code></strong> <strong>cancel construct <code class="docutils literal notranslate"><span class="pre">cancel</span></code> construct</strong></p>
<p><strong>cancellation!for parallel region for <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region</strong> <strong>cancellation!for worksharing region</strong> The following example shows how the <code class="docutils literal notranslate"><span class="pre">cancel</span></code> directive can be used to terminate  an OpenMP region. Although the <code class="docutils literal notranslate"><span class="pre">cancel</span></code> construct terminates the OpenMP  worksharing region, programmers must still track the exception through the pointer  ex and issue a cancellation for the <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region if an exception has  been raised. The primary thread checks the exception pointer to make sure that the  exception is properly handled in the sequential part. If cancellation of the <code class="docutils literal notranslate"><span class="pre">parallel</span></code>  region has been requested, some threads might have executed <code class="docutils literal notranslate"><span class="pre">phase_1()</span></code>.  However, it is guaranteed that none of the threads executed <code class="docutils literal notranslate"><span class="pre">phase_2()</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: cancellation.1
* type: C++
* version: omp_4.0
*/
#include &lt;iostream&gt;
#include &lt;exception&gt;
#include &lt;cstddef&gt;

#define N 10000

extern void causes_an_exception();
extern void phase_1();
extern void phase_2();

void example() {
    std::exception *ex = NULL;
#pragma omp parallel shared(ex)
    {
#pragma omp for
        for (int i = 0; i &lt; N; i++) {
            // no &#39;if&#39; that prevents compiler optimizations
            try {
                causes_an_exception();
            }
            catch (std::exception *e) {
                // still must remember exception for later handling
#pragma omp atomic write
                ex = e;
  // cancel worksharing construct
#pragma omp cancel for
            }
        }
        // if an exception has been raised, cancel parallel region
        if (ex) {
#pragma omp cancel parallel
        }
        phase_1();
#pragma omp barrier
        phase_2();
    }
    // continue here if an exception has been thrown in
    // the worksharing loop
    if (ex) {
        // handle exception stored in ex
    }
}

</pre></div>
</div>
</div>
</div>
<p><strong>cancellation!cancellation point construct <code class="docutils literal notranslate"><span class="pre">cancellation</span></code> <code class="docutils literal notranslate"><span class="pre">point</span></code> construct</strong> <strong>constructs!cancellation point <code class="docutils literal notranslate"><span class="pre">cancellation</span></code> <code class="docutils literal notranslate"><span class="pre">point</span></code></strong> <strong>cancellation point construct <code class="docutils literal notranslate"><span class="pre">cancellation</span></code> <code class="docutils literal notranslate"><span class="pre">point</span></code> construct</strong> The following example illustrates the use of the <code class="docutils literal notranslate"><span class="pre">cancel</span></code> construct in error  handling. If there is an error condition from the <code class="docutils literal notranslate"><span class="pre">allocate</span></code> statement,  the cancellation is activated. The encountering thread sets the shared variable  <code class="docutils literal notranslate"><span class="pre">err</span></code> and other threads of the binding thread set proceed to the end of  the worksharing construct after the cancellation has been activated.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: cancellation.1
! type: F-free
! version: omp_4.0
subroutine example(n, dim)
  integer, intent(in) :: n, dim(n)
  integer :: i, s, err
  real, allocatable :: B(:)
  err = 0
!$omp parallel shared(err)
! ...
!$omp do private(s, B)
  do i=1, n
!$omp cancellation point do
    allocate(B(dim(i)), stat=s)
    if (s .gt. 0) then
!$omp atomic write
      err = s
!$omp cancel do
    endif
!   ...
! deallocate private array B
    if (allocated(B)) then
      deallocate(B)
    endif
  enddo
!$omp end parallel
end subroutine

</pre></div>
</div>
</div>
</div>
<p><strong>cancellation!for taskgroup region for <code class="docutils literal notranslate"><span class="pre">taskgroup</span></code> region</strong> The following example shows how to cancel a parallel search on a binary tree as  soon as the search value has been detected. The code creates a task to descend  into the child nodes of the current tree node. If the search value has been found,  the code remembers the tree node with the found value through an <code class="docutils literal notranslate"><span class="pre">atomic</span></code>  write to the result variable and then cancels execution of all search tasks. The  function <code class="docutils literal notranslate"><span class="pre">search_tree_parallel</span></code> groups all search tasks into a single  task group to control the effect of the <code class="docutils literal notranslate"><span class="pre">cancel</span> <span class="pre">taskgroup</span></code> directive. The   <em>level</em>  argument is used to create undeferred tasks after the first ten  levels of the tree.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: cancellation.2
* type: C
* version: omp_5.1
*/
#include &lt;stddef.h&gt;

typedef struct binary_tree_s {
   int value;
   struct binary_tree_s *left, *right;
} binary_tree_t;

binary_tree_t *search_tree(binary_tree_t *tree, int value, int level) {
    binary_tree_t *found = NULL;
    if (tree) {
        if (tree-&gt;value == value) {
            found = tree;
        }
        else {
#pragma omp task shared(found) if(level &lt; 10)
            {
                binary_tree_t *found_left = NULL;
                found_left = search_tree(tree-&gt;left, value, level + 1);
                if (found_left) {
#pragma omp atomic write
                    found = found_left;
#pragma omp cancel taskgroup
                }
            }
#pragma omp task shared(found) if(level &lt; 10)
            {
                binary_tree_t *found_right = NULL;
                found_right = search_tree(tree-&gt;right, value, level + 1);
                if (found_right) {
#pragma omp atomic write
                    found = found_right;
#pragma omp cancel taskgroup
                }
            }
#pragma omp taskwait
        }
    }
    return found;
}
binary_tree_t *search_tree_parallel(binary_tree_t *tree, int value) {
    binary_tree_t *found = NULL;
#pragma omp parallel shared(found, tree, value)
    {
#pragma omp masked
        {
#pragma omp taskgroup
            {
                found = search_tree(tree, value, 0);
            }
        }
    }
    return found;
}

</pre></div>
</div>
</div>
</div>
<p>The following is the equivalent parallel search example in Fortran.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: cancellation.2
! type: F-free
! version: omp_5.1
module parallel_search
  type binary_tree
    integer :: value
    type(binary_tree), pointer :: right
    type(binary_tree), pointer :: left
  end type

contains
  recursive subroutine search_tree(tree, value, level, found)
    type(binary_tree), intent(in), pointer :: tree
    integer, intent(in) :: value, level
    type(binary_tree), pointer :: found
    type(binary_tree), pointer :: found_left =&gt; NULL(), &amp;
                                  found_right =&gt; NULL()

    if (associated(tree)) then
      if (tree%value .eq. value) then
        found =&gt; tree
      else
!$omp task shared(found) if(level&lt;10)
        call search_tree(tree%left, value, level+1, found_left)
        if (associated(found_left)) then
!$omp critical
          found =&gt; found_left
!$omp end critical

!$omp cancel taskgroup
        endif
!$omp end task

!$omp task shared(found) if(level&lt;10)
        call search_tree(tree%right, value, level+1, found_right)
        if (associated(found_right)) then
!$omp critical
          found =&gt; found_right
!$omp end critical

!$omp cancel taskgroup
        endif
!$omp end task

!$omp taskwait
      endif
    endif
  end subroutine

  subroutine search_tree_parallel(tree, value, found)
    type(binary_tree), intent(in), pointer :: tree
    integer, intent(in) :: value
    type(binary_tree), pointer :: found

    found =&gt; NULL()
!$omp parallel shared(found, tree, value)
!$omp masked
!$omp taskgroup
    call search_tree(tree, value, 0, found)
!$omp end taskgroup
!$omp end masked
!$omp end parallel
  end subroutine

end module parallel_search

</pre></div>
</div>
</div>
</div>
<p>../../program_control/cancellation.tex</p>
</div>
<div class="section" id="requires-directive">
<h2><code class="docutils literal notranslate"><span class="pre">requires</span></code> Directive<a class="headerlink" href="#requires-directive" title="Permalink to this headline">¶</a></h2>
<p><strong>directives!requires <code class="docutils literal notranslate"><span class="pre">requires</span></code></strong> <strong>requires directive <code class="docutils literal notranslate"><span class="pre">requires</span></code> directive</strong></p>
<p>The declarative <code class="docutils literal notranslate"><span class="pre">requires</span></code> directive can be used to  specify features that an implementation must provide to compile and  execute correctly.</p>
<p><strong>requires directive <code class="docutils literal notranslate"><span class="pre">requires</span></code> directive!unified_shared_memory clause <code class="docutils literal notranslate"><span class="pre">unified_shared_memory</span></code> clause</strong> <strong>clauses!unified_shared_memory <code class="docutils literal notranslate"><span class="pre">unified_shared_memory</span></code></strong> <strong>unified_shared_memory clause <code class="docutils literal notranslate"><span class="pre">unified_shared_memory</span></code> clause</strong> In the following example the <code class="docutils literal notranslate"><span class="pre">unified_shared_memory</span></code> clause  of the <code class="docutils literal notranslate"><span class="pre">requires</span></code> directive ensures that the host and all  devices accessible through OpenMP provide a  <em>unified address</em>  space for memory that is shared by all devices.</p>
<p>The example illustrates the use of the <code class="docutils literal notranslate"><span class="pre">requires</span></code> directive specifying  <em>unified shared memory</em>  in file scope, before any device  directives or device routines. No <code class="docutils literal notranslate"><span class="pre">map</span></code> clause is needed for the  <em>p</em>  structure on the device (and its address  <em>&amp;p</em> , for the C++ code, is the same address on the host and device). However, scalar variables referenced within the <code class="docutils literal notranslate"><span class="pre">target</span></code> construct still have a default data-sharing attribute of firstprivate. The  <em>q</em>  scalar is incremented on the device, and its change is not updated on the host.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name:       requires.1
* type:       C++
* version:    omp_5.0
*/

#include &lt;iostream&gt;
using namespace std;

#pragma omp requires unified_shared_memory

typedef struct mypoints
{
   double res;
   double data[500];
} mypoints_t;

void do_something_with_p(mypoints_t *p, int q);

int main()
{
  mypoints_t p;
  int q=0;

  #pragma omp target // no map clauses needed
  {                  // q is firstprivate
     q++;
     do_something_with_p(&amp;p,q);
  }
  cout&lt;&lt; p.res &lt;&lt; &quot; &quot; &lt;&lt; q &lt;&lt; endl;  // output 1 0
  return 0;
}
void do_something_with_p(mypoints_t *p, int q)
{
  p-&gt;res = q;
  for(int i=0;i&lt;sizeof(p-&gt;data)/sizeof(double);i++)
      p-&gt;data[i]=q*i;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name:       requires.1
! type:       F-free
! version:    omp_5.0

module data
!$omp requires unified_shared_memory
  type,public :: mypoints
     double precision :: res
     double precision :: data(500)
  end type
end module

program main
  use data
  type(mypoints) :: p
  integer        :: q=0

  !$omp target    !! no map clauses needed
     q = q + 1    !! q is firstprivate
     call do_something_with_p(p,q)
  !$omp end target

  write(*,&#39;(f5.0,i5)&#39;) p%res, q    !! output 1.   0

end program

subroutine do_something_with_p(p,q)
  use data
  type(mypoints) :: p
  integer        :: q

  p%res = q;
  do i=1,size(p%data)
     p%data(i)=q*i
  enddo

end subroutine

</pre></div>
</div>
</div>
</div>
<p>../../program_control/requires.tex</p>
</div>
<div class="section" id="declare-variant-directive">
<h2><code class="docutils literal notranslate"><span class="pre">declare</span></code> <code class="docutils literal notranslate"><span class="pre">variant</span></code> Directive<a class="headerlink" href="#declare-variant-directive" title="Permalink to this headline">¶</a></h2>
<p><strong>directives!declare variant <code class="docutils literal notranslate"><span class="pre">declare</span></code> <code class="docutils literal notranslate"><span class="pre">variant</span></code></strong> <strong>declare variant directive <code class="docutils literal notranslate"><span class="pre">declare</span></code> <code class="docutils literal notranslate"><span class="pre">variant</span></code> directive</strong> <strong>declare variant directive <code class="docutils literal notranslate"><span class="pre">declare</span></code> <code class="docutils literal notranslate"><span class="pre">variant</span></code> directive!match clause <code class="docutils literal notranslate"><span class="pre">match</span></code> clause</strong> <strong>clauses!match <code class="docutils literal notranslate"><span class="pre">match</span></code></strong> <strong>match clause <code class="docutils literal notranslate"><span class="pre">match</span></code> clause</strong></p>
<p><strong>directives!declare target <code class="docutils literal notranslate"><span class="pre">declare</span></code> <code class="docutils literal notranslate"><span class="pre">target</span></code></strong> <strong>declare target directive <code class="docutils literal notranslate"><span class="pre">declare</span></code> <code class="docutils literal notranslate"><span class="pre">target</span></code> directive</strong></p>
<p><strong>directives!begin declare target <code class="docutils literal notranslate"><span class="pre">begin</span></code> <code class="docutils literal notranslate"><span class="pre">declare</span></code> <code class="docutils literal notranslate"><span class="pre">target</span></code></strong> <strong>begin declare target directive <code class="docutils literal notranslate"><span class="pre">begin</span></code> <code class="docutils literal notranslate"><span class="pre">declare</span></code> <code class="docutils literal notranslate"><span class="pre">target</span></code> directive</strong></p>
<p>A <code class="docutils literal notranslate"><span class="pre">declare</span></code> <code class="docutils literal notranslate"><span class="pre">variant</span></code> directive specifies an alternate function,   <em>function variant</em> , to be used in place of the  <em>base function</em>   when the trait within the <code class="docutils literal notranslate"><span class="pre">match</span></code> clause matches the OpenMP context at a given call site. The base function follows the directive in the C and C++ languages. In Fortran, either a subroutine or function may be used as the  <em>base function</em> , and the <code class="docutils literal notranslate"><span class="pre">declare</span></code> <code class="docutils literal notranslate"><span class="pre">variant</span></code> directive must be in the specification  part of a subroutine or function (unless a  <em>base-proc-name</em>  modifier is used, as in the case of a procedure declaration statement). See the OpenMP 5.0 Specification for details on the modifier.</p>
<p>When multiple <code class="docutils literal notranslate"><span class="pre">declare</span></code> <code class="docutils literal notranslate"><span class="pre">variant</span></code> directives are used  a function variant becomes a candidate for replacing the base function if the context at the base function call matches the traits of all selectors in the <code class="docutils literal notranslate"><span class="pre">match</span></code> clause. If there are multiple candidates, a score is assigned with rules for each of the selector traits. The scoring algorithm can be found in the OpenMP 5.0 Specification.</p>
<p>In the first example the  <em>vxv()</em>  function is called within a <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region, a <code class="docutils literal notranslate"><span class="pre">target</span></code> region, and in a sequential part of the program.  Two function variants,  <em>p_vxv()</em>  and  <em>t_vxv()</em> , are defined for the first two regions by using  <em>parallel</em>  and  <em>target</em>  selectors (within the  <em>construct</em>  trait set) in a <code class="docutils literal notranslate"><span class="pre">match</span></code> clause.  The  <em>p_vxv()</em>  function variant includes a <code class="docutils literal notranslate"><span class="pre">for</span></code> construct (<code class="docutils literal notranslate"><span class="pre">do</span></code> construct for Fortran) for the <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region,  while  <em>t_vxv()</em>  includes a <code class="docutils literal notranslate"><span class="pre">distribute</span></code> <code class="docutils literal notranslate"><span class="pre">simd</span></code> construct for the <code class="docutils literal notranslate"><span class="pre">target</span></code> region. The  <em>t_vxv()</em>  function is explicitly compiled for the device using a declare target directive.</p>
<p>Since the two <code class="docutils literal notranslate"><span class="pre">declare</span></code> <code class="docutils literal notranslate"><span class="pre">variant</span></code> directives have no selectors that match traits for the context of the base function call in the sequential part of the program, the base  <em>vxv()</em>  function is used there,  as expected. (The vectors in the  <em>p_vxv</em>  and  <em>t_vxv</em>  functions have been multiplied by 3 and 2, respectively, for checking the validity of the replacement. Normally the purpose of a function variant is to produce the same results by a different method.)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: declare_variant.1
* type: C
* version: omp_5.1
*/

#define N 100
#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;

void p_vxv(int *v1,int *v2,int *v3,int n);
void t_vxv(int *v1,int *v2,int *v3,int n);

#pragma omp declare variant( p_vxv ) match( construct={parallel} )
#pragma omp declare variant( t_vxv ) match( construct={target}   )
void vxv(int *v1,int *v2,int *v3,int n)     // base function
{
   for (int i= 0; i&lt; n; i++)  v3[i] = v1[i] * v2[i];
}

void p_vxv(int *v1,int *v2,int *v3,int n)   // function variant
{
   #pragma omp for
   for (int i= 0; i&lt; n; i++)  v3[i] = v1[i] * v2[i]*3;
}

#pragma omp begin declare target
void t_vxv(int *v1,int *v2,int *v3,int n)   // function variant
{
   #pragma omp distribute simd
   for (int i= 0; i&lt; n; i++)  v3[i] = v1[i] * v2[i]*2;
}
#pragma omp end declare target

int main()
{
   int v1[N], v2[N], v3[N];
   for(int i=0; i&lt;N; i++){ v1[i]=(i+1); v2[i]=-(i+1); v3[i]=0; }   //init

   #pragma omp parallel
   {
      vxv(v1,v2,v3,N);
   }
   printf(&quot; %d  %d\n&quot;,v3[0],v3[N-1]); //from p_vxv --  output: -3  -30000

   #pragma omp target teams map(to: v1[:N],v2[:N]) map(from: v3[:N])
   {
      vxv(v1,v2,v3,N);
   }
   printf(&quot; %d  %d\n&quot;,v3[0],v3[N-1]); //from t_vxv --  output: -2  -20000

   vxv(v1,v2,v3,N);
   printf(&quot; %d  %d\n&quot;,v3[0],v3[N-1]); //from   vxv --  output: -1  -10000

   return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: declare_variant.1
! type: F-free
! version: omp_5.0

module subs
  use omp_lib
contains
   subroutine vxv(v1, v2, v3)             !! base function
      integer,intent(in)  :: v1(:),v2(:)
      integer,intent(out) :: v3(:)
      integer             :: i,n
      !$omp  declare variant( p_vxv ) match( construct={parallel} )
      !$omp  declare variant( t_vxv ) match( construct={target}   )

      n=size(v1)
      do i = 1,n; v3(i) = v1(i) * v2(i); enddo

   end subroutine

   subroutine p_vxv(v1, v2, v3)            !! function variant
      integer,intent(in)  :: v1(:),v2(:)
      integer,intent(out) :: v3(:)
      integer             :: i,n
      n=size(v1)

      !$omp do
      do i = 1,n; v3(i) = v1(i) * v2(i) * 3; enddo

   end subroutine

   subroutine t_vxv(v1, v2, v3)            !! function variant
      integer,intent(in)  :: v1(:),v2(:)
      integer,intent(out) :: v3(:)
      integer             :: i,n
      !$omp declare target
      n=size(v1)

      !$omp distribute simd
      do i = 1,n; v3(i) = v1(i) * v2(i) * 2; enddo

   end subroutine

end module subs


program main
   use omp_lib
   use subs
   integer,parameter :: N = 100
   integer           :: v1(N), v2(N), v3(N)

   do i= 1,N; v1(i)= i; v2(i)= -i; v3(i)= 0;  enddo  !! init

   !$omp parallel
      call vxv(v1,v2,v3)
   !$omp end parallel
   print *, v3(1),v3(N)    !! from p_vxv -- output: -3  -30000

   !$omp target teams map(to: v1,v2) map(from: v3)
      call vxv(v1,v2,v3)
   !$omp end target teams
   print *, v3(1),v3(N)    !! from t_vxv -- output: -2  -20000

   call vxv(v1,v2,v3)
   print *, v3(1),v3(N)    !! from   vxv -- output: -1  -10000

end program

</pre></div>
</div>
</div>
</div>
<p>In this example, traits from the  <em>device</em>  set are used to select a function variant. In the <code class="docutils literal notranslate"><span class="pre">declare</span></code> <code class="docutils literal notranslate"><span class="pre">variant</span></code> directive, an  <em>isa</em>  selector specifies that if the implementation of the ” <em>core-avx512</em> ‘’  instruction set is detected at compile time the  <em>avx512_saxpy()</em>  variant function is used for the call to  <em>base_saxpy()</em> .</p>
<p>A compilation of  <em>avx512_saxpy()</em>  is aware of the AVX-512 instruction set that supports 512-bit vector extensions (for Xeon or Xeon Phi architectures).  Within  <em>avx512_saxpy()</em> , the <code class="docutils literal notranslate"><span class="pre">parallel</span></code> <code class="docutils literal notranslate"><span class="pre">for</span></code> <code class="docutils literal notranslate"><span class="pre">simd</span></code> construct performs parallel execution, and takes advantage of 64-byte data alignment.  When the  <em>avx512_saxpy()</em>  function variant is not selected, the base  <em>base_saxpy()</em>  function variant containing only a basic <code class="docutils literal notranslate"><span class="pre">parallel</span></code> <code class="docutils literal notranslate"><span class="pre">for</span></code> construct is used for the call to  <em>base_saxpy()</em> .</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: declare_variant.2
* type: C
* version: omp_5.0
*/
#include &lt;omp.h&gt;

void   base_saxpy(int, float, float *, float *);
void avx512_saxpy(int, float, float *, float *);

#pragma omp declare variant( avx512_saxpy ) \
                      match( device={isa(&quot;core-avx512&quot;)} )
void base_saxpy(int n, float s, float *x, float *y)   // base function
{
   #pragma omp parallel for
   for(int i=0; i&lt;n; i++) y[i] = s*x[i] + y[i];
}

void avx512_saxpy(int n, float s, float *x, float *y) //function variant
{
   //assume 64-byte alignment for AVX-512
   #pragma omp parallel for simd simdlen(16) aligned(x,y:64)
   for(int i=0; i&lt;n; i++) y[i] = s*x[i] + y[i];
}

// Above may be in another file scope.

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;
#define N 1000

int main()
{
   static float x[N],y[N] __attribute__ ((aligned(64)));
   float s=2.0;
                         // Check for 64-byte aligned
   if( ((intptr_t)y)%64 != 0 || ((intptr_t)x)%64 != 0 )
   { printf(&quot;ERROR: x|y not 64-Byte aligned\n&quot;); exit(1); }

   for(int i=0; i&lt;N; i++){ x[i]=i+1; y[i]=i+1; } // initialize

   base_saxpy(N,s,x,y);

   printf(&quot;y[0],y[N-1]: %5.0f %5.0f\n&quot;,y[0],y[N-1]);
   //output: y[0],y[N-1]: 3  3000

   return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: declare_variant.2
! type: F-free
! version: omp_5.0

module subs
  use omp_lib
contains

   subroutine base_saxpy(s,x,y)              !! base function
      real,intent(inout) :: s,x(:),y(:)
     !$omp  declare variant( avx512_saxpy ) &amp;
     !$omp&amp;           match( device={isa(&quot;core-avx512&quot;)} )

      y = s*x + y

   end subroutine

   subroutine avx512_saxpy(s,x,y)               !! function variant
      real,intent(inout) :: s,x(:),y(:)
      integer            :: i,n
      n=size(x)
                             !!assume 64-byte alignment for AVX-512
      !$omp parallel do simd simdlen(16) aligned(x,y: 64)
      do i = 1,n
         y(i) = s*x(i) + y(i)
      end do

   end subroutine

end module subs


program main
   use omp_lib
   use subs

   integer, parameter :: N=1000, align=64
   real, allocatable  :: x(:),y(:)
   real               :: s = 2.0e0
   integer            :: i

   allocate(x(N),y(N))   !! Assumes allocation is 64-byte aligned
                         !! (using compiler options, or another
                         !! allocation method).

                         !! loc is non-standard, but found everywhere
                         !! remove these lines if not available
   if(modulo(loc(x),align) /= 0 .and. modulo(loc(y),align) /=0 ) then
      print*,&quot;ERROR: x|y not 64-byte aligned&quot;; stop
   endif

   do i=1,N  !! initialize
     x(i)=i
     y(i)=i
   end do

   call base_saxpy(s,x,y)

   write(*,&#39;(&quot;y(1),y(N):&quot;,2f6.0)&#39;) y(1),y(N) !!output: y... 3. 3000.

   deallocate(x,y)

end program

</pre></div>
</div>
</div>
</div>
<p>../../program_control/variant.tex</p>
</div>
<div class="section" id="metadirectives">
<h2>Metadirectives<a class="headerlink" href="#metadirectives" title="Permalink to this headline">¶</a></h2>
<p><strong>directives!metadirective <code class="docutils literal notranslate"><span class="pre">metadirective</span></code></strong> <strong>metadirective directive <code class="docutils literal notranslate"><span class="pre">metadirective</span></code> directive</strong></p>
<p><strong>metadirective directive <code class="docutils literal notranslate"><span class="pre">metadirective</span></code> directive!when clause <code class="docutils literal notranslate"><span class="pre">when</span></code> clause</strong> <strong>metadirective directive <code class="docutils literal notranslate"><span class="pre">metadirective</span></code> directive!otherwise clause <code class="docutils literal notranslate"><span class="pre">otherwise</span></code> clause</strong> <strong>clauses!when <code class="docutils literal notranslate"><span class="pre">when</span></code></strong> <strong>when clause <code class="docutils literal notranslate"><span class="pre">when</span></code> clause</strong> <strong>clauses!otherwise <code class="docutils literal notranslate"><span class="pre">otherwise</span></code></strong> <strong>otherwise clause <code class="docutils literal notranslate"><span class="pre">otherwise</span></code> clause</strong> A <code class="docutils literal notranslate"><span class="pre">metadirective</span></code> directive provides a mechanism to select a directive in a <code class="docutils literal notranslate"><span class="pre">when</span></code> clause to be used, depending upon one or more contexts:   implementation, available devices and the present enclosing construct.  The directive in an <code class="docutils literal notranslate"><span class="pre">otherwise</span></code> clause is used when a directive of the  <code class="docutils literal notranslate"><span class="pre">when</span></code> clause is not selected.</p>
<p>**context selector!construct  <em>construct</em> ** In the <code class="docutils literal notranslate"><span class="pre">when</span></code> clause the  <em>context selector</em>  (or just  <em>selector</em> ) defines traits that are evaluated for selection of the directive that follows the selector.  This “selectable” directive is called a  <em>directive variant</em> . Traits are grouped by  <em>construct</em> ,  <em>implementation</em>  and   <em>device</em>   <em>sets</em>  to be used by a selector of the same name.</p>
<p>**context selector!device  <em>device</em> ** In the first example the architecture trait  <em>arch</em>  of the   <em>device</em>  selector set specifies that if an  <em>nvptx</em>  architecture is active in the OpenMP context, then the <code class="docutils literal notranslate"><span class="pre">teams</span></code> <code class="docutils literal notranslate"><span class="pre">loop</span></code>   <em>directive variant</em>  is selected as the directive; otherwise, the <code class="docutils literal notranslate"><span class="pre">parallel</span></code> <code class="docutils literal notranslate"><span class="pre">loop</span></code>  <em>directive variant</em>  of the <code class="docutils literal notranslate"><span class="pre">otherwise</span></code> clause is selected as the directive. That is, if a  <em>device</em>  of  <em>nvptx</em>  architecture is supported by the implementation within the enclosing <code class="docutils literal notranslate"><span class="pre">target</span></code> construct, its  <em>directive variant</em>  is selected. The architecture names, such as  <em>nvptx</em> , are implementation defined. Also, note that  <em>device</em>  as used in a <code class="docutils literal notranslate"><span class="pre">target</span></code> construct specifies a device number, while  <em>device</em> , as used in the <code class="docutils literal notranslate"><span class="pre">metadirective</span></code> directive as selector set, has traits of  <em>kind</em> ,  <em>isa</em>  and  <em>arch</em> .</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: metadirective.1
* type: C
* version: omp_5.2
*/

#define N 100
#include &lt;stdio.h&gt;

int main()
{
   int v1[N], v2[N], v3[N];
   for(int i=0; i&lt;N; i++){ v1[i]=(i+1); v2[i]=-(i+1); }

   #pragma omp target map(to:v1,v2) map(from:v3) device(0)
   #pragma omp metadirective \
                   when(     device={arch(&quot;nvptx&quot;)}: teams loop) \
                   otherwise(                     parallel loop)
     for (int i= 0; i&lt; N; i++)  v3[i] = v1[i] * v2[i];

   printf(&quot; %d  %d\n&quot;,v3[0],v3[N-1]); //output: -1  -10000

   return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: metadirective.1
! type: F-free
! version: omp_5.2
program main
   integer, parameter :: N= 100
   integer ::  v1(N), v2(N), v3(N);

   do i=1,N;  v1(i)=i; v2(i)=-i;  enddo   ! initialize

   !$omp  target map(to:v1,v2) map(from:v3) device(0)
   !$omp  metadirective &amp;
   !$omp&amp;     when(     device={arch(&quot;nvptx&quot;)}: teams loop) &amp;
   !$omp&amp;     otherwise(                     parallel loop)
     do i= 1,N; v3(i) = v1(i) * v2(i); enddo
   !$omp  end target

   print *, v3(1),v3(N) !!output: -1  -10000
end program

</pre></div>
</div>
</div>
</div>
<p>**context selector!implementation  <em>implementation</em> ** In the second example, the  <em>implementation</em>  selector set is specified in the <code class="docutils literal notranslate"><span class="pre">when</span></code> clause to distinguish between platforms.  Additionally, specific architectures are specified with the  <em>device</em>   selector set.</p>
<p>In the code, different <code class="docutils literal notranslate"><span class="pre">teams</span></code> constructs are employed as determined by the <code class="docutils literal notranslate"><span class="pre">metadirective</span></code> directive. The number of teams is restricted by a <code class="docutils literal notranslate"><span class="pre">num_teams</span></code> clause and a thread limit is also set by a <code class="docutils literal notranslate"><span class="pre">thread_limit</span></code> clause for   <em>vendor</em>  platforms and specific architecture traits.  Otherwise, just the <code class="docutils literal notranslate"><span class="pre">teams</span></code> construct is used without any clauses, as prescribed by the <code class="docutils literal notranslate"><span class="pre">otherwise</span></code> clause.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: metadirective.2
* type: C
* version: omp_5.2
*/
#define N 100
#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;

void work_on_chunk(int idev, int i);

int main()                    //Driver
{
   int i,idev;

   for (idev=0; idev&lt;omp_get_num_devices(); idev++)
   {
      #pragma omp target device(idev)
      #pragma omp metadirective \
               when( implementation={vendor(nvidia)},            \
                                       device={arch(&quot;kepler&quot;)}:  \
                     teams num_teams(512) thread_limit(32) )     \
               when( implementation={vendor(amd)},               \
                                       device={arch(&quot;fiji&quot;  )}:  \
                     teams num_teams(512) thread_limit(64) )     \
               otherwise(                                        \
                     teams)
      #pragma omp distribute parallel for
      for (i=0; i&lt;N; i++) work_on_chunk(idev,i);
   }
   return 0;
}


</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: metadirective.2
! type: F-free
! version: omp_5.2
program main                    !!Driver
  use omp_lib
  implicit none
  integer, parameter :: N=1000
  external           :: work_on_chunk
  integer            :: i,idev

  do idev=0,omp_get_num_devices()-1

    !$omp target device(idev)
    !$omp begin metadirective &amp;
    !$omp&amp;  when( implementation={vendor(nvidia)},        &amp;
    !$omp&amp;           device={arch(&quot;kepler&quot;)}:             &amp;
    !$omp&amp;        teams num_teams(512) thread_limit(32) ) &amp;
    !$omp&amp;  when( implementation={vendor(amd)},           &amp;
    !$omp&amp;           device={arch(&quot;fiji&quot;  )}:             &amp;
    !$omp&amp;        teams num_teams(512) thread_limit(64) ) &amp;
    !$omp&amp;  otherwise( teams )
    !$omp distribute parallel do
    do i=1,N
       call work_on_chunk(idev,i)
    end do
    !$omp end metadirective
    !$omp end target

  end do

end program

</pre></div>
</div>
</div>
</div>
<p>**context selector!construct  <em>construct</em> **</p>
<p><strong>directives!declare target <code class="docutils literal notranslate"><span class="pre">declare</span></code> <code class="docutils literal notranslate"><span class="pre">target</span></code></strong> <strong>declare target directive <code class="docutils literal notranslate"><span class="pre">declare</span></code> <code class="docutils literal notranslate"><span class="pre">target</span></code> directive</strong></p>
<p><strong>directives!begin declare target <code class="docutils literal notranslate"><span class="pre">begin</span></code> <code class="docutils literal notranslate"><span class="pre">declare</span></code> <code class="docutils literal notranslate"><span class="pre">target</span></code></strong> <strong>begin declare target directive <code class="docutils literal notranslate"><span class="pre">begin</span></code> <code class="docutils literal notranslate"><span class="pre">declare</span></code> <code class="docutils literal notranslate"><span class="pre">target</span></code> directive</strong></p>
<p>In the third example, a  <em>construct</em>  selector set is specified in the <code class="docutils literal notranslate"><span class="pre">when</span></code> clause.   Here, a <code class="docutils literal notranslate"><span class="pre">metadirective</span></code> directive is used within a function that is also compiled as a function for a target device as directed by a declare target directive. The  <em>target</em>  directive name of the <code class="docutils literal notranslate"><span class="pre">construct</span></code> selector ensures that the <code class="docutils literal notranslate"><span class="pre">distribute</span></code> <code class="docutils literal notranslate"><span class="pre">parallel</span></code> <code class="docutils literal notranslate"><span class="pre">for/do</span></code> construct is employed for the target compilation. Otherwise, for the host-compiled version the <code class="docutils literal notranslate"><span class="pre">parallel</span></code> <code class="docutils literal notranslate"><span class="pre">for/do</span></code> <code class="docutils literal notranslate"><span class="pre">simd</span></code> construct is used.</p>
<p>In the first call to the  <em>exp_pi_diff()</em>  routine the context is a <code class="docutils literal notranslate"><span class="pre">target</span></code> <code class="docutils literal notranslate"><span class="pre">teams</span></code> construct and the <code class="docutils literal notranslate"><span class="pre">distribute</span></code> <code class="docutils literal notranslate"><span class="pre">parallel</span></code> <code class="docutils literal notranslate"><span class="pre">for/do</span></code> construct version of the function is invoked, while in the second call the <code class="docutils literal notranslate"><span class="pre">parallel</span></code> <code class="docutils literal notranslate"><span class="pre">for/do</span></code> <code class="docutils literal notranslate"><span class="pre">simd</span></code> construct version is used.</p>
<p>This case illustrates an important point for users that may want to hoist the  <code class="docutils literal notranslate"><span class="pre">target</span></code> directive out of a function that contains the usual  <code class="docutils literal notranslate"><span class="pre">target</span></code> <code class="docutils literal notranslate"><span class="pre">teams</span></code> <code class="docutils literal notranslate"><span class="pre">distribute</span></code> <code class="docutils literal notranslate"><span class="pre">parallel</span></code> <code class="docutils literal notranslate"><span class="pre">for/do</span></code> construct (for providing alternate constructs through the <code class="docutils literal notranslate"><span class="pre">metadirective</span></code> directive as here). While this combined construct can be decomposed into a <code class="docutils literal notranslate"><span class="pre">target</span></code> and <code class="docutils literal notranslate"><span class="pre">teams</span> <span class="pre">distribute</span> <span class="pre">parallel</span> <span class="pre">for/do</span></code> constructs, the OpenMP 5.0 specification has the restriction: “If a <code class="docutils literal notranslate"><span class="pre">teams</span></code> construct is nested within a <code class="docutils literal notranslate"><span class="pre">target</span></code> construct, that <code class="docutils literal notranslate"><span class="pre">target</span></code> construct must contain no statements, declarations or directives outside of the <code class="docutils literal notranslate"><span class="pre">teams</span></code> construct’’. So, the <code class="docutils literal notranslate"><span class="pre">teams</span></code> construct must immediately follow the <code class="docutils literal notranslate"><span class="pre">target</span></code> construct without any intervening code statements (which includes function calls).   Since the <code class="docutils literal notranslate"><span class="pre">target</span></code> construct alone cannot be hoisted out of a function,  the <code class="docutils literal notranslate"><span class="pre">target</span></code> <code class="docutils literal notranslate"><span class="pre">teams</span></code> construct has been hoisted out of the function, and the  <code class="docutils literal notranslate"><span class="pre">distribute</span></code> <code class="docutils literal notranslate"><span class="pre">parallel</span></code> <code class="docutils literal notranslate"><span class="pre">for/do</span></code> construct is used as the  <em>variant</em>  directive of the <code class="docutils literal notranslate"><span class="pre">metadirective</span></code> directive within the function.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: metadirective.3
* type: C
* version: omp_5.2
*/
#include &lt;stdio.h&gt;
#include  &lt;math.h&gt;
#define      N 1000

#pragma omp begin declare target
void exp_pi_diff(double *d, double my_pi){
   #pragma omp metadirective \
               when(   construct={target}: distribute parallel for ) \
               otherwise(                  parallel for simd )
   for(int i = 0; i&lt;N; i++) d[i] = exp( (M_PI-my_pi)*i );
}
#pragma omp end declare target

int main()
{
  //Calculates sequence of exponentials: (M_PI-my_pi) * index
  //M_PI is from math.h, and my_pi is user provided.

  double d[N];
  double my_pi=3.14159265358979e0;

      #pragma omp target teams map(tofrom: d[0:N])
      exp_pi_diff(d,my_pi);
                                           // value should be near 1
      printf(&quot;d[N-1] = %20.14f\n&quot;,d[N-1]); // ...= 1.00000000000311

      exp_pi_diff(d,my_pi);                // value should be near 1
      printf(&quot;d[N-1] = %20.14f\n&quot;,d[N-1]); // ...= 1.00000000000311
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: metadirective.3
! type: F-free
! version: omp_5.2
module params
   integer, parameter :: N=1000
   DOUBLE PRECISION, PARAMETER::M_PI=4.0d0*DATAN(1.0d0)
                                     ! 3.1415926535897932_8
end module


subroutine exp_pi_diff(d,    my_pi)
  use params
  implicit none
  integer          ::  i
  double precision ::  d(N), my_pi
  !$omp declare target

  !$omp   metadirective &amp;
  !$omp&amp;      when( construct={target}: distribute parallel do )  &amp;
  !$omp&amp;      otherwise(                parallel do simd )

  do i = 1,size(d)
     d(i) = exp( (M_PI-my_pi)*i )
  end do

end subroutine

program main
  ! Calculates sequence of exponentials: (M_PI-my_pi) * index
  ! M_PI is from usual way, and my_pi is user provided.
  ! Fortran Standard does not provide PI

  use params
  implicit none
  double precision   :: d(N)
  double precision   :: my_pi=3.14159265358979d0

      !$omp target teams map(from: d)
      call exp_pi_diff(d,my_pi)
      !$omp end target teams
                                  ! value should be near 1
      print*, &quot;d(N) = &quot;,d(N)      ! 1.00000000000311

      call exp_pi_diff(d,my_pi) ! value should be near 1
      print*, &quot;d(N) = &quot;,d(N)      ! 1.00000000000311

end program

</pre></div>
</div>
</div>
</div>
<p>**context selector!user  <em>user</em> ** <strong>context selector!condition selector <code class="docutils literal notranslate"><span class="pre">condition</span></code> selector</strong> The <code class="docutils literal notranslate"><span class="pre">user</span></code> selector set can be used in a metadirective to select directives at execution time when the  <code class="docutils literal notranslate"><span class="pre">condition(</span></code>  <em>boolean-expr</em>  <code class="docutils literal notranslate"><span class="pre">)</span></code> selector expression is not a constant expression. In this case it is a  <em>dynamic</em>  trait set, and the selection is made at run time, rather than at compile time.</p>
<p>In the following example the  <em>foo</em>  function employs the <code class="docutils literal notranslate"><span class="pre">condition</span></code> selector to choose a device for execution at run time.  In the  <em>bar</em>  routine metadirectives are nested. At the outer level a selection between serial and parallel execution in performed at run time, followed by another run time selection on the schedule kind in the inner level when the active  <em>construct</em>  trait is <code class="docutils literal notranslate"><span class="pre">parallel</span></code>.</p>
<p>(Note, the variable  <em>b</em>  in two of the “selected’’ constructs is declared private for the sole purpose  of detecting and reporting that the construct is used. Since the variable is private, its value  is unchanged outside of the construct region, whereas it is changed if the “unselected’’ construct is used.)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name:       metadirective.4
* type:       C
* version:    omp_5.2
*/
#define N 100
#include &lt;stdbool.h&gt;
#include   &lt;stdio.h&gt;
#include     &lt;omp.h&gt;

void foo(int *a, int n, bool use_gpu)
{
   int b=0;   //  use b to detect if run on gpu

   #pragma omp metadirective \
               when( user={condition(use_gpu)}:           \
                     target teams distribute parallel for \
                     private(b) map(from:a[0:n]) )        \
               otherwise(                                 \
                     parallel for )
   for (int i=0; i&lt;n; i++) {a[i]=i; if(i==n-1) b=1;}

   if(b==0) printf(&quot;PASSED 1 of 3\n&quot;);
}

void bar (int *a, int n, bool run_parallel, bool unbalanced)
{
   int b=0;
   #pragma omp metadirective \
               when(user={condition(run_parallel)}: parallel)
   {
      if(omp_in_parallel() == 1 &amp;&amp; omp_get_thread_num() == 0)
      {printf(&quot;PASSED 2 of 3\n&quot;);}

      #pragma omp metadirective \
          when( construct={parallel}, \
                user={condition(unbalanced)}: for schedule(guided) \
                                                  private(b)) \
          when( construct={parallel}        : for schedule(static))
      for (int i=0; i&lt;n; i++) {a[i]=i; if(i==n-1) b=1;}
   }
   // if guided b=0, because b is private
   if(b==0) printf(&quot;PASSED 3 of 3\n&quot;);
}

void foo(int *a, int n, bool use_gpu);
void bar(int *a, int n, bool run_parallel, bool unbalanced);

int main(){

   int p[N];
   // App normally sets these, dependent on input parameters
   bool use_gpu=true, run_parallel=true, unbalanced=true;

   // Testing: set Env Var MK_FAIL to anything to fail tests
   if(getenv(&quot;MK_FAIL&quot;)!=NULL) {
      use_gpu=false; run_parallel=false; unbalanced=false;
   }

   foo(p, N, use_gpu);
   bar(p, N, run_parallel,unbalanced);

}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: metadirective.4
! type: F-free
! version: omp_5.2
subroutine foo(a, n, use_gpu)
   integer :: n, a(n)
   logical :: use_gpu

   integer :: b=0   !! use b to detect if run on gpu

   !$omp metadirective &amp;
   !$omp&amp;            when(user={condition(use_gpu)}:           &amp;
   !$omp&amp;                 target teams distribute parallel for &amp;
   !$omp&amp;                 private(b) map(from:a(1:n)) )        &amp;
   !$omp&amp;            otherwise(                                &amp;
   !$omp&amp;                 parallel do)
   do i = 1,n; a(i)=i; if(i==n) b=1; end do

   if(b==0) print *, &quot;PASSED 1 of 3&quot;  ! bc b is firstprivate for gpu run
end subroutine

subroutine bar (a, n, run_parallel, unbalanced)
   use omp_lib, only : omp_get_thread_num
   integer :: n, a(n)
   logical :: run_parallel, unbalanced

   integer :: b=0
   !$omp begin metadirective when(user={condition(run_parallel)}: parallel)

    if(omp_in_parallel() == 1 .and. omp_get_thread_num() == 0) &amp;
       print *,&quot;PASSED 2 of 3&quot;

    !$omp metadirective &amp;
    !$omp&amp;  when(construct={parallel}, user={condition(unbalanced)}: &amp;
    !$omp&amp;         for schedule(guided) private(b)) &amp;
    !$omp&amp;  when(construct={parallel}: for schedule(static))
    do i = 1,n; a(i)=i; if(i==n) b=1; end do

   !$omp end metadirective

   if(b==0) print *, &quot;PASSED 3 of 3&quot;   !!if guided, b=0 since b is private
end subroutine

program meta
   use omp_lib
   integer, parameter :: N=100
   integer :: p(N)
   integer :: env_stat
                !! App normally sets these, dependent on input parameters
   logical ::  use_gpu=.true., run_parallel=.true., unbalanced=.true.

                !! Testing: set Env Var MK_FAIL to anything to fail tests
   call get_environment_variable(&#39;MK_FAIL&#39;,status=env_stat)
   if(env_stat /= 1) then                ! status =1 when not set!
      use_gpu=.false.; run_parallel=.false.; unbalanced=.false.
   endif


   call foo(p, N, use_gpu)
   call bar(p, N, run_parallel,unbalanced)

end program

</pre></div>
</div>
</div>
</div>
<p>Metadirectives can be used in conjunction with templates as shown in the C++ code below. Here the template definition generates two versions of the Fibonacci function. The  <em>tasking</em>  boolean is used in the <code class="docutils literal notranslate"><span class="pre">condition</span></code> selector to enable tasking. The true form implements a parallel version with <code class="docutils literal notranslate"><span class="pre">task</span></code> and <code class="docutils literal notranslate"><span class="pre">taskwait</span></code> constructs as in the  <em>tasking.4.c</em>  code in Section .  The false form implements a serial version without any tasking constructs. Note that the serial version is used in the parallel function for optimally processing numbers less than 8.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name:       metadirective.5
* type:       C++
* version:    omp_5.0
*/
#include &lt;stdio.h&gt;

// revised Fibonacci from tasking.4.c example

template &lt;bool tasking&gt;
int fib(int n) {
  int i, j;
  if (n&lt;2) {
    return n;
  } else if ( tasking &amp;&amp; n&lt;8 ) { // serial/taskless cutoff for n&lt;8
    return fib&lt;false&gt;(n);
  } else {
    #pragma omp metadirective \
                when(user={condition(tasking)}: task shared(i))
    {
      i=fib&lt;tasking&gt;(n-1);
    }
    #pragma omp metadirective \
                when(user={condition(tasking)}: task shared(j))
    {
      j=fib&lt;tasking&gt;(n-2);
    }
    #pragma omp metadirective \
                when(user={condition(tasking)}: taskwait)
    return i+j;
  }
}

int main(int argc, char** argv) {
  int n = 15;
  #pragma omp parallel
  #pragma omp single
  {
    printf(&quot;fib(%i) = %i\n&quot;, n, fib&lt;true&gt;(n));
  }
  return 0;
}
// OUTPUT:
// fib(15) = 610

</pre></div>
</div>
</div>
</div>
<p>../../program_control/metadirective.tex</p>
</div>
<div class="section" id="nested-loop-constructs">
<h2>Nested Loop Constructs<a class="headerlink" href="#nested-loop-constructs" title="Permalink to this headline">¶</a></h2>
<p><strong>nested loop constructs</strong></p>
<p>The following example of loop construct nesting is conforming because the inner  and outer loop regions bind to different <code class="docutils literal notranslate"><span class="pre">parallel</span></code> regions:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: nested_loop.1
* type: C
*/
void work(int i, int j) {}

void good_nesting(int n)
{
  int i, j;
  #pragma omp parallel default(shared)
  {
    #pragma omp for
    for (i=0; i&lt;n; i++) {
      #pragma omp parallel shared(i, n)
      {
        #pragma omp for
        for (j=0; j &lt; n; j++)
          work(i, j);
      }
    }
  }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: nested_loop.1
! type: F-fixed
      SUBROUTINE WORK(I, J)
      INTEGER I, J
      END SUBROUTINE WORK

      SUBROUTINE GOOD_NESTING(N)
      INTEGER N

        INTEGER I
!$OMP   PARALLEL DEFAULT(SHARED)
!$OMP     DO
          DO I = 1, N
!$OMP       PARALLEL SHARED(I,N)
!$OMP         DO
              DO J = 1, N
                CALL WORK(I,J)
              END DO
!$OMP       END PARALLEL
          END DO
!$OMP   END PARALLEL
      END SUBROUTINE GOOD_NESTING

</pre></div>
</div>
</div>
</div>
<p>The following variation of the preceding example is also conforming:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: nested_loop.2
* type: C
*/
void work(int i, int j) {}


void work1(int i, int n)
{
  int j;
  #pragma omp parallel default(shared)
  {
    #pragma omp for
    for (j=0; j&lt;n; j++)
      work(i, j);
  }
}


void good_nesting2(int n)
{
  int i;
  #pragma omp parallel default(shared)
  {
    #pragma omp for
    for (i=0; i&lt;n; i++)
      work1(i, n);
  }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: nested_loop.2
! type: F-fixed
      SUBROUTINE WORK(I, J)
      INTEGER I, J
      END SUBROUTINE WORK

      SUBROUTINE WORK1(I, N)
      INTEGER J
!$OMP PARALLEL DEFAULT(SHARED)
!$OMP DO
        DO J = 1, N
          CALL WORK(I,J)
        END DO
!$OMP END PARALLEL
      END SUBROUTINE WORK1

      SUBROUTINE GOOD_NESTING2(N)
      INTEGER N
!$OMP PARALLEL DEFAULT(SHARED)
!$OMP DO
      DO I = 1, N
         CALL WORK1(I, N)
      END DO
!$OMP END PARALLEL
      END SUBROUTINE GOOD_NESTING2

</pre></div>
</div>
</div>
</div>
<p>../../program_control/nested_loop.tex</p>
</div>
<div class="section" id="restrictions-on-nesting-of-regions">
<h2>Restrictions on Nesting of Regions<a class="headerlink" href="#restrictions-on-nesting-of-regions" title="Permalink to this headline">¶</a></h2>
<p><strong>region nesting rules</strong> The examples in this section illustrate the region nesting rules.</p>
<p>The following example is non-conforming because the inner and outer loop regions  are closely nested:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: nesting_restrict.1
* type: C
*/

void work(int i, int j) {}

void wrong1(int n)
{

  #pragma omp parallel default(shared)
  {
    int i, j;
    #pragma omp for
    for (i=0; i&lt;n; i++) {
       /* incorrect nesting of loop regions */
       #pragma omp for
         for (j=0; j&lt;n; j++)
           work(i, j);
    }
  }

}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: nesting_restrict.1
! type: F-fixed

      SUBROUTINE WORK(I, J)
      INTEGER I, J

      END SUBROUTINE WORK

      SUBROUTINE WRONG1(N)

      INTEGER N
      INTEGER I,J
!$OMP   PARALLEL DEFAULT(SHARED)
!$OMP     DO
          DO I = 1, N
!$OMP       DO             ! incorrect nesting of loop regions
            DO J = 1, N
              CALL WORK(I,J)
            END DO
          END DO
!$OMP   END PARALLEL

      END SUBROUTINE WRONG1

</pre></div>
</div>
</div>
</div>
<p>The following orphaned version of the preceding example is also non-conforming:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: nesting_restrict.2
* type: C
*/
void work(int i, int j) {}
void work1(int i, int n)
{
  int j;
/* incorrect nesting of loop regions */
  #pragma omp for
    for (j=0; j&lt;n; j++)
      work(i, j);
}

void wrong2(int n)
{
  #pragma omp parallel default(shared)
  {
    int i;
    #pragma omp for
      for (i=0; i&lt;n; i++)
         work1(i, n);
  }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: nesting_restrict.2
! type: F-fixed
       SUBROUTINE WORK1(I,N)
       INTEGER I, N
       INTEGER J
!$OMP   DO      ! incorrect nesting of loop regions
        DO J = 1, N
          CALL WORK(I,J)
        END DO
       END SUBROUTINE WORK1
       SUBROUTINE WRONG2(N)
       INTEGER N
       INTEGER I
!$OMP   PARALLEL DEFAULT(SHARED)
!$OMP     DO
          DO I = 1, N
            CALL WORK1(I,N)
          END DO
!$OMP   END PARALLEL
       END SUBROUTINE WRONG2

</pre></div>
</div>
</div>
</div>
<p>The following example is non-conforming because the loop and <code class="docutils literal notranslate"><span class="pre">single</span></code> regions  are closely nested:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: nesting_restrict.3
* type: C
*/
void work(int i, int j) {}
void wrong3(int n)
{
  #pragma omp parallel default(shared)
  {
    int i;
    #pragma omp for
      for (i=0; i&lt;n; i++) {
/* incorrect nesting of regions */
        #pragma omp single
          work(i, 0);
      }
  }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: nesting_restrict.3
! type: F-fixed
      SUBROUTINE WRONG3(N)
      INTEGER N

        INTEGER I
!$OMP   PARALLEL DEFAULT(SHARED)
!$OMP     DO
          DO I = 1, N
!$OMP       SINGLE            ! incorrect nesting of regions
              CALL WORK(I, 1)
!$OMP       END SINGLE
          END DO
!$OMP   END PARALLEL
      END SUBROUTINE WRONG3

</pre></div>
</div>
</div>
</div>
<p>The following example is non-conforming because a <code class="docutils literal notranslate"><span class="pre">barrier</span></code> region cannot  be closely nested inside a loop region:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: nesting_restrict.4
* type: C
*/
void work(int i, int j) {}
void wrong4(int n)
{

  #pragma omp parallel default(shared)
  {
    int i;
    #pragma omp for
      for (i=0; i&lt;n; i++) {
        work(i, 0);
/* incorrect nesting of barrier region in a loop region */
        #pragma omp barrier
        work(i, 1);
      }
  }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: nesting_restrict.4
! type: F-fixed
      SUBROUTINE WRONG4(N)
      INTEGER N

        INTEGER I
!$OMP   PARALLEL DEFAULT(SHARED)
!$OMP     DO
          DO I = 1, N
            CALL WORK(I, 1)
! incorrect nesting of barrier region in a loop region
!$OMP       BARRIER
            CALL WORK(I, 2)
          END DO
!$OMP   END PARALLEL
      END SUBROUTINE WRONG4

</pre></div>
</div>
</div>
</div>
<p>The following example is non-conforming because the <code class="docutils literal notranslate"><span class="pre">barrier</span></code> region cannot  be closely nested inside the <code class="docutils literal notranslate"><span class="pre">critical</span></code> region. If this were permitted,  it would result in deadlock due to the fact that only one thread at a time can  enter the <code class="docutils literal notranslate"><span class="pre">critical</span></code> region:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: nesting_restrict.5
* type: C
*/
void work(int i, int j) {}
void wrong5(int n)
{
  #pragma omp parallel
  {
    #pragma omp critical
    {
       work(n, 0);
/* incorrect nesting of barrier region in a critical region */
       #pragma omp barrier
       work(n, 1);
    }
  }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: nesting_restrict.5
! type: F-fixed
      SUBROUTINE WRONG5(N)
      INTEGER N

!$OMP   PARALLEL DEFAULT(SHARED)
!$OMP     CRITICAL
            CALL WORK(N,1)
! incorrect nesting of barrier region in a critical region
!$OMP       BARRIER
            CALL WORK(N,2)
!$OMP     END CRITICAL
!$OMP   END PARALLEL
      END SUBROUTINE WRONG5

</pre></div>
</div>
</div>
</div>
<p>The following example is non-conforming because the <code class="docutils literal notranslate"><span class="pre">barrier</span></code> region cannot  be closely nested inside the <code class="docutils literal notranslate"><span class="pre">single</span></code> region. If this were permitted, it  would result in deadlock due to the fact that only one thread executes the <code class="docutils literal notranslate"><span class="pre">single</span></code>  region:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: nesting_restrict.6
* type: C
*/
void work(int i, int j) {}
void wrong6(int n)
{
  #pragma omp parallel
  {
    #pragma omp single
    {
      work(n, 0);
/* incorrect nesting of barrier region in a single region */
      #pragma omp barrier
      work(n, 1);
    }
  }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: nesting_restrict.6
! type: F-fixed
      SUBROUTINE WRONG6(N)
      INTEGER N

!$OMP   PARALLEL DEFAULT(SHARED)
!$OMP     SINGLE
            CALL WORK(N,1)
! incorrect nesting of barrier region in a single region
!$OMP       BARRIER
            CALL WORK(N,2)
!$OMP     END SINGLE
!$OMP   END PARALLEL
      END SUBROUTINE WRONG6

</pre></div>
</div>
</div>
</div>
<p>../../program_control/nesting_restrict.tex</p>
</div>
<div class="section" id="target-offload">
<h2>Target Offload<a class="headerlink" href="#target-offload" title="Permalink to this headline">¶</a></h2>
<p><strong>environment variables!OMP_TARGET_OFFLOAD <code class="docutils literal notranslate"><span class="pre">OMP_TARGET_OFFLOAD</span></code></strong> <strong>OMP_TARGET_OFFLOAD <code class="docutils literal notranslate"><span class="pre">OMP_TARGET_OFFLOAD</span></code></strong></p>
<p>In the OpenMP 5.0 implementation the <code class="docutils literal notranslate"><span class="pre">OMP_TARGET_OFFLOAD</span></code> environment variable was defined to change  <em>default</em>  offload behavior.  By  <em>default</em>  the target code (region) is executed on the host if the target device  does not exist or the implementation does not support the target device.</p>
<p>In an OpenMP 5.0 compliant implementation, setting the  <code class="docutils literal notranslate"><span class="pre">OMP_TARGET_OFFLOAD</span></code> variable to <code class="docutils literal notranslate"><span class="pre">MANDATORY</span></code> will  force the program to terminate execution when a <code class="docutils literal notranslate"><span class="pre">target</span></code>  construct is encountered and the target device is not supported or is not available. With a value <code class="docutils literal notranslate"><span class="pre">DEFAULT</span></code> the target region will execute on a device if the  device exists and is supported by the implementation, otherwise it will execute on the host. Support for the <code class="docutils literal notranslate"><span class="pre">DISABLED</span></code> value is optional; when it is supported the behavior is as if only the  host device exists (other devices are considered non-existent to the runtime),  and target regions are executed on the host.</p>
<p>The following example reports execution behavior for different  values of the <code class="docutils literal notranslate"><span class="pre">OMP_TARGET_OFFLOAD</span></code> variable. A handy routine  for extracting the <code class="docutils literal notranslate"><span class="pre">OMP_TARGET_OFFLOAD</span></code> environment variable value is deployed here, because the OpenMP API does not have a routine  for obtaining the value.</p>
<p>Note:  The example issues a warning when a pre-5.0 implementation is used, indicating that the <code class="docutils literal notranslate"><span class="pre">OMP_TARGET_OFFLOAD</span></code> is ignored. The value of the <code class="docutils literal notranslate"><span class="pre">OMP_TARGET_OFFLOAD</span></code> variable is reported  when the <code class="docutils literal notranslate"><span class="pre">OMP_DISPLAY_ENV</span></code>  environment variable is set to <code class="docutils literal notranslate"><span class="pre">TRUE</span></code> or <code class="docutils literal notranslate"><span class="pre">VERBOSE</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: target_offload_control.1
* type: C
* version: omp_5.0
*/
#include    &lt;omp.h&gt;
#include  &lt;stdio.h&gt;
#include  &lt;ctype.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

typedef enum offload_policy
{MANDATORY, DISABLED, DEFAULT, UNKNOWN, NOTSET} offload_policy_t;


offload_policy_t get_offload_policy()
{
   char *env, *end;
   size_t n;

   env = getenv(&quot;OMP_TARGET_OFFLOAD&quot;);
   if(env  == NULL) return NOTSET;

   end = env + strlen(env);                //Find trimmed beginning/end
   while (      *env &amp;&amp; isspace(*(env  )) ) env++;
   while (end != env &amp;&amp; isspace(*(end-1)) ) end--;
   n = (int)(end - env);

                    //Find ONLY string -nothing more, case insensitive
   if      (n == 9 &amp;&amp; !strncasecmp(env, &quot;MANDATORY&quot;,n)) return MANDATORY;
   else if (n == 8 &amp;&amp; !strncasecmp(env, &quot;DISABLED&quot; ,n)) return DISABLED ;
   else if (n == 7 &amp;&amp; !strncasecmp(env, &quot;DEFAULT&quot;  ,n)) return DEFAULT  ;
   else                                                 return UNKNOWN  ;
}


int main()
{
   int i;
   int device_num, on_init_dev;

   // get policy from OMP_TARGET_OFFLOAD variable
   offload_policy_t policy = get_offload_policy();

   if(_OPENMP&lt; 201811)
   {
      printf(&quot;Warning: OMP_TARGET_OFFLOAD NOT supported, version %d\n&quot;,
             _OPENMP );
      printf(&quot;         If OMP_TARGET_OFFLOAD is set, &quot;
             &quot;it will be ignored.\n&quot;);
   }

   // Set target device number to an unavailable
   // device to test offload policy.
   device_num = omp_get_num_devices() + 1;

   // Policy:
   printf(&quot;OMP_TARGET_OFFLOAD Policy:  &quot;);
   if     (policy==MANDATORY)
      printf(&quot;MANDATORY-Terminate if dev. not avail\n&quot;);
   else if(policy==DISABLED )
      printf(&quot;DISABLED -(if supported) Only on Host\n&quot;);
   else if(policy==DEFAULT  )
      printf(&quot;DEFAULT  -On host if device not avail\n&quot;);
   else if(policy==UNKNOWN  )
      printf(&quot;OMP_TARGET_OFFLOAD has unknown value\n&quot; );
   else if(policy==NOTSET   )
      printf(&quot;OMP_TARGET_OFFLOAD not set\n&quot; );


   on_init_dev = 1;
   // device# out of range--not supported
   #pragma omp target device(device_num) map(tofrom: on_init_dev)
     on_init_dev=omp_is_initial_device();

   if (policy == MANDATORY &amp;&amp; _OPENMP &gt;= 201811)
      printf(&quot;ERROR: OpenMP implementation ignored MANDATORY policy.\n&quot;);

   printf(&quot;Target region executed on init dev %s\n&quot;,
          on_init_dev ? &quot;TRUE&quot;:&quot;FALSE&quot;);

   return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: target_offload_control.1
! type: F-free
! version: omp_5.0
module offload_policy
  implicit none
  integer, parameter :: LEN_POLICY=10
contains
  character(LEN_POLICY) function get_offload_policy()
     character(64) :: env
     integer       :: length, i
     env=repeat(&#39; &#39;,len(env))
                                    !policy is blank if not found *
     call get_environment_variable(&quot;OMP_TARGET_OFFLOAD&quot;,env,length)

     do i = 1,len(env)              !Makes a-z upper case
        if(iachar(env(i:i))&gt;96) env(i:i)=achar(iachar(env(i:i))-32)
     end do

     get_offload_policy = trim(adjustl(env)) !remove peripheral spaces

     if(length==0) get_offload_policy=&quot;NOTSET&quot;

     return

  end function

end module

program policy_test

  use omp_lib
  use offload_policy

  integer                :: i, device_num
  logical                :: on_init_dev
  character(LEN_POLICY)  :: policy

  policy = get_offload_policy() !!Get OMP_TARGET_OFFLOAD value

  if (OPENMP_VERSION &lt; 201811) then
     print*,&quot;Warning: OMP_TARGET_OFFLOAD NOT supported by VER.&quot;, &amp;
            OPENMP_VERSION
     print*,&quot;         If OMP_TARGET_OFFLOAD is set, it will be ignored.&quot;
  endif

     ! Set target device number to an unavailable device
     ! to test offload policy.
  device_num = omp_get_num_devices() + 1

                      !! Report OMP_TARGET_OFFOAD value
  select CASE (policy)
     case(&quot;MANDATORY&quot;)
          print*,&quot;Policy:  MANDATORY-Terminate if dev. not avail.&quot;
     case(&quot;DISABLED&quot;)
          print*,&quot;Policy:  DISABLED-(if supported) Only on Host.&quot;
     case(&quot;DEFAULT&quot;)
          print*,&quot;Policy:  DEFAULT On host if device not avail.&quot;
     case(&quot;NOTSET&quot;)
          print*,&quot;         OMP_TARGET_OFFLOAD is not set.&quot;
     case DEFAULT
          print*,&quot;         OMP_TARGET_OFFLOAD has unknown value.&quot;
          print*,&quot;         UPPER CASE VALUE=&quot;,policy
  end select


  on_init_dev = .FALSE.
                      !! device# out of range--not supported
  !$omp target  device(device_num) map(tofrom: on_init_dev)
     on_init_dev=omp_is_initial_device()
  !$omp end target

  if (policy==&quot;MANDATORY&quot; .and. OPENMP_VERSION&gt;=201811) then
     print*,&quot;OMP ERROR: &quot;, &amp;
            &quot;OpenMP 5.0 implementation ignored MANDATORY policy.&quot;
     print*,&quot;           Termination should have occurred&quot;, &amp;
            &quot; at target directive.&quot;
  endif

  print*, &quot;Target executed on init dev (T|F): &quot;, on_init_dev

end program policy_test

</pre></div>
</div>
</div>
</div>
<p>../../program_control/target_offload.tex</p>
</div>
<div class="section" id="controlling-concurrency-and-reproducibility-with-the-order-clause">
<h2>Controlling Concurrency and Reproducibility with  the <code class="docutils literal notranslate"><span class="pre">order</span></code> Clause<a class="headerlink" href="#controlling-concurrency-and-reproducibility-with-the-order-clause" title="Permalink to this headline">¶</a></h2>
<p><strong>clauses!order(concurrent) <code class="docutils literal notranslate"><span class="pre">order(concurrent)</span></code></strong> <strong>order(concurrent) clause <code class="docutils literal notranslate"><span class="pre">order(concurrent)</span></code> clause</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">order</span></code> clause is used for controlling the parallel execution of  loop iterations for one or more loops that are associated with a directive.  It is specified with a clause argument and optional modifier.  The only supported argument, introduced in OpenMP 5.0, is the keyword  <code class="docutils literal notranslate"><span class="pre">concurrent</span></code> which indicates that the loop iterations may execute  concurrently, including iterations in the same chunk per the loop schedule.  Because of the relaxed execution permitted with an <code class="docutils literal notranslate"><span class="pre">order(concurrent)</span></code>  clause, codes must not assume that any cross-iteration data dependences  would be preserved or that any two iterations may execute on the same thread.</p>
<p>The following example in this section demonstrates the use of  the <code class="docutils literal notranslate"><span class="pre">order(concurrent)</span></code> clause, without any modifiers, for controlling  the parallel execution of loop iterations. The <code class="docutils literal notranslate"><span class="pre">order(concurrent)</span></code> clause cannot be used for the second and third  <code class="docutils literal notranslate"><span class="pre">parallel</span></code> <code class="docutils literal notranslate"><span class="pre">for</span></code>/<code class="docutils literal notranslate"><span class="pre">do</span></code> constructs because of either having  data dependences or accessing threadprivate variables.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: reproducible.1
* type: C
* version: omp_5.0
*/
#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;

int main()
{
   const int n = 1000;
   int v[n], u[n];
   static int sum;
   #pragma omp threadprivate(sum)

   // no data dependences, so can execute concurrently
   #pragma omp parallel for order(concurrent)
   for (int i = 0; i &lt; n; i++) {
      u[i] = i;
      v[i] = i;
      v[i] += u[i] * u[i];
   }

   // with data dependences, so cannot execute iterations
   // concurrently with the order(concurrent) clause
   #pragma omp parallel for ordered
   for (int i = 1; i &lt; n; i++) {
      v[i] += u[i] * u[i];
      #pragma omp ordered
   v[i] += v[i-1];
   }

   sum = 0;
   // accessing a threadprivate variable, which would not be
   // permitted if the order(concurrent) clause was present
   #pragma omp parallel for copyin(sum)
   for (int i = 0; i &lt; n; i++) {
      sum += v[i];
   }

   #pragma omp parallel
   {
      printf(&quot;sum = %d on thread %d\n&quot;, sum, omp_get_thread_num());
   }

   return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: reproducible.1
! type: F-free
! version:    omp_5.0
program main
   use omp_lib
   implicit none
   integer, parameter :: n = 1000
   integer :: v(n), u(n)
   integer :: i
   integer, save :: sum
   !$omp threadprivate(sum)

   !! no data dependences, so can execute concurrently
   !$omp parallel do order(concurrent)
   do i = 1, n
      u(i) = i
      v(i) = i
      v(i) = v(i) + u(i) * u(i)
   end do

   !! with data dependences, so cannot execute iterations
   !! concurrently with the order(concurrent) clause
   !$omp parallel do ordered
   do i = 2, n
      v(i) = v(i) + u(i) * u(i)
      !$omp ordered
  v(i) = v(i) + v(i-1)
      !$omp end ordered
   end do

   sum = 0
   !! accessing a threadprivate variable, which would not be
   !! permitted if the order(concurrent) clause was present
   !$omp parallel do copyin(sum)
   do i = 2, n
      sum = sum + v(i)
   end do

   !$omp parallel
      print *,&quot;sum = &quot;,sum,&quot; on thread &quot;, omp_get_thread_num()
   !$omp end parallel

end program

</pre></div>
</div>
</div>
</div>
<p><strong>order(concurrent) clause <code class="docutils literal notranslate"><span class="pre">order(concurrent)</span></code> clause!reproducible modifier <code class="docutils literal notranslate"><span class="pre">reproducible</span></code> modifier</strong> <strong>order(concurrent) clause <code class="docutils literal notranslate"><span class="pre">order(concurrent)</span></code> clause!unconstrained modifier <code class="docutils literal notranslate"><span class="pre">unconstrained</span></code> modifier</strong> Modifiers to the <code class="docutils literal notranslate"><span class="pre">order</span></code> clause, introduced in OpenMP 5.1, may be  specified to control the reproducibility of the loop schedule for  the associated loop(s). A reproducible loop schedule will consistently  yield the same mapping of iterations to threads (or SIMD lanes) if the  directive name, loop schedule, iteration space, and binding region remain  the same. The <code class="docutils literal notranslate"><span class="pre">reproducible</span></code> modifier indicates the loop schedule must  be reproducible, while the <code class="docutils literal notranslate"><span class="pre">unconstrained</span></code> modifier indicates that  the loop schedule is not reproducible. If a modifier is not specified, then the <code class="docutils literal notranslate"><span class="pre">order</span></code> clause does not affect  the reproducibility of the loop schedule.</p>
<p>The next example demonstrates the use of the <code class="docutils literal notranslate"><span class="pre">order(concurrent)</span></code> clause  with modifiers for additionally controlling the reproducibility of a loop’s  schedule. The two worksharing-loop constructs in the first <code class="docutils literal notranslate"><span class="pre">parallel</span></code> construct specify that the loops have reproducible schedules, thus memory effects from iteration  <em>i</em>  from the first loop will be observable to iteration  <em>i</em>  in the second loop.  In the second <code class="docutils literal notranslate"><span class="pre">parallel</span></code> construct, the <code class="docutils literal notranslate"><span class="pre">order</span></code> clause does not  control reproducibility for the loop schedules. However, since both loops  specify the same static schedules, the schedules are reproducible and the  data dependences between the loops are preserved by the execution. In the third <code class="docutils literal notranslate"><span class="pre">parallel</span></code> construct, the <code class="docutils literal notranslate"><span class="pre">order</span></code> clause indicates  that the loops are not reproducible, overriding the default reproducibility prescribed by the specified static schedule. Consequentially,  the <code class="docutils literal notranslate"><span class="pre">nowait</span></code> clause on the first worksharing-loop construct should not  be used to ensure that the data dependences are preserved by the execution.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: reproducible.2
* type: C
* version: omp_5.1
*/
#include &lt;stdio.h&gt;

int main()
{
   const int n = 1000;
   int v[n], u[n];

   #pragma omp parallel
   {
      // reproducible schedules are used for the following two constructs
      #pragma omp for order(reproducible: concurrent) nowait
      for (int i = 0; i &lt; n; i++) {
         u[i] = i;
         v[i] = i;
      }
      #pragma omp for order(reproducible: concurrent)
      for (int i = 0; i &lt; n; i++) {
         v[i]  += u[i] * u[i];
      }
   }

   #pragma omp parallel
   {
      // static schedules preserve data dependences between the loops
      #pragma omp for schedule(static) order(concurrent) nowait
      for (int i = 0; i &lt; n; i++) {
         u[i] = i;
         v[i] = i;
      }
      #pragma omp for schedule(static) order(concurrent)
      for (int i = 0; i &lt; n; i++) {
         v[i]  += u[i] * u[i];
      }
   }

   #pragma omp parallel
   {
      // the default reproducibility by the static schedule is not
      // preserved due to the unconstrained order clause.
      // use of nowait here could result in data race.
      #pragma omp for schedule(static) order(unconstrained: concurrent)
      for (int i = 0; i &lt; n; i++) {
         u[i] = i;
         v[i] = i;
      }
      #pragma omp for schedule(static) order(unconstrained: concurrent)
      for (int i = 0; i &lt; n; i++) {
         v[i]  += u[i] * u[i];
      }
   }

   return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: reproducible.2
! type: F-free
! version:    omp_5.1
program main
   implicit none
   integer, parameter :: n = 1000
   integer :: v(n), u(n)
   integer :: i

   !$omp parallel
      !! reproducible schedules are used the following two constructs
      !$omp do order(reproducible: concurrent) nowait
      do i = 1, n
         u(i) = i
         v(i) = i
      end do
      !$omp do order(reproducible: concurrent)
      do i = 1, n
         v(i) = v(i) + u(i) * u(i)
      end do
   !$omp end parallel

   !$omp parallel
      !! static schedules preserve data dependences between the loops
      !$omp do schedule(static) order(concurrent) nowait
      do i = 1, n
         u(i) = i
         v(i) = i
      end do
      !$omp do schedule(static) order(concurrent)
      do i = 1, n
         v(i) = v(i) + u(i) * u(i)
      end do
   !$omp end parallel

   !$omp parallel
      !! the default reproducibility by the static schedule is not
      !! preserved due to the unconstrained order clause.
      !! use of nowait here could result in data race.
      !$omp do schedule(static) order(unconstrained: concurrent)
      do i = 1, n
         u(i) = i
         v(i) = i
      end do
      !$omp do schedule(static) order(unconstrained: concurrent)
      do i = 1, n
         v(i) = v(i) + u(i) * u(i)
      end do
   !$omp end parallel

end program

</pre></div>
</div>
</div>
</div>
<p>../../program_control/reproducible.tex</p>
</div>
<div class="section" id="interop-construct">
<h2><code class="docutils literal notranslate"><span class="pre">interop</span></code> Construct<a class="headerlink" href="#interop-construct" title="Permalink to this headline">¶</a></h2>
<p><strong>constructs!interop <code class="docutils literal notranslate"><span class="pre">interop</span></code></strong> <strong>interop construct <code class="docutils literal notranslate"><span class="pre">interop</span></code> construct</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">interop</span></code> construct allows OpenMP to interoperate with foreign runtime environments. In the example below, asynchronous cuda memory copies and a  <em>cublasDaxpy</em>  routine are executed  in a cuda stream. Also, an asynchronous target task execution (having a <code class="docutils literal notranslate"><span class="pre">nowait</span></code> clause)  and two explicit tasks are executed through OpenMP directives.  Scheduling dependences (synchronization) are imposed on the foreign stream and the OpenMP tasks through <code class="docutils literal notranslate"><span class="pre">depend</span></code> clauses.</p>
<p><strong>interop construct <code class="docutils literal notranslate"><span class="pre">interop</span></code> construct!init clause <code class="docutils literal notranslate"><span class="pre">init</span></code> clause</strong> <strong>init clause <code class="docutils literal notranslate"><span class="pre">init</span></code> clause</strong> <strong>clauses!init <code class="docutils literal notranslate"><span class="pre">init</span></code></strong> <strong>interop construct <code class="docutils literal notranslate"><span class="pre">interop</span></code> construct!depend clause <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause</strong> <strong>depend clause <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause</strong> <strong>clauses!depend <code class="docutils literal notranslate"><span class="pre">depend</span></code></strong> First, an interop object,  <em>obj</em> , is initialized for synchronization by including the <code class="docutils literal notranslate"><span class="pre">targetsync</span></code>  <em>interop-type</em>  in the interop <code class="docutils literal notranslate"><span class="pre">init</span></code> clause  (<code class="docutils literal notranslate"><span class="pre">init(</span></code> <code class="docutils literal notranslate"><span class="pre">targetsync,obj</span></code> <code class="docutils literal notranslate"><span class="pre">)</span></code>).   The object provides access to the foreign runtime. The <code class="docutils literal notranslate"><span class="pre">depend</span></code> clause provides a dependence behavior for foreign tasks associated with a valid object.</p>
<p><strong>routines!omp_get_interop_int <code class="docutils literal notranslate"><span class="pre">omp_get_interop_int</span></code></strong> <strong>omp_get_interop_int routine <code class="docutils literal notranslate"><span class="pre">omp_get_interop_int</span></code> routine</strong> Next, the <code class="docutils literal notranslate"><span class="pre">omp_get_interop_int</span></code> routine is used to extract the foreign  runtime id (<code class="docutils literal notranslate"><span class="pre">omp_ipr_fr_id</span></code>), and a test in the next statement ensures  that the cuda runtime (<code class="docutils literal notranslate"><span class="pre">omp_ifr_cuda</span></code>) is available.</p>
<p><strong>routines!omp_get_interop_ptr <code class="docutils literal notranslate"><span class="pre">omp_get_interop_ptr</span></code></strong> <strong>omp_get_interop_ptr routine <code class="docutils literal notranslate"><span class="pre">omp_get_interop_ptr</span></code> routine</strong> <strong>interop construct <code class="docutils literal notranslate"><span class="pre">interop</span></code> construct!destroy clause <code class="docutils literal notranslate"><span class="pre">destroy</span></code> clause</strong> <strong>destroy clause <code class="docutils literal notranslate"><span class="pre">destroy</span></code> clause</strong> <strong>clauses!destroy <code class="docutils literal notranslate"><span class="pre">destroy</span></code></strong> Within the block for executing the  <em>cublasDaxpy</em>  routine, a stream is acquired  with the <code class="docutils literal notranslate"><span class="pre">omp_get_interop_ptr</span></code> routine, which returns a cuda stream ( <em>s</em> ). The stream is included in the cublas handle, and used directly in the asynchronous memory routines.  The following <code class="docutils literal notranslate"><span class="pre">interop</span></code> construct, with the <code class="docutils literal notranslate"><span class="pre">destroy</span></code> clause,  ensures that the foreign tasks have completed.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name:       interop.1
* type:       C
* version:    omp_5.1
*/
#include &lt;omp.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;cublas_v2.h&gt;
#include &lt;cuda_runtime_api.h&gt;

#define N 16384

void myVectorSet(int n, double s, double *x)
{
   for(int i=0; i&lt;n; ++i) x[i] = s*(i+1);
}
void myDaxpy(int n, double s, double *x, double *y)
{
   for(int i=0; i&lt;n; ++i) y[i] = s*x[i]+y[i];
}
void myDscal(int n, double s, double *x)
{
   for(int i=0; i&lt;n; ++i) x[i] = s*x[i];
}


int main(){
  const  double scalar=2.0;
  double *x, *y, *d_x, *d_y;
  int    dev;

  omp_interop_t obj=omp_interop_none;
  intptr_t  type;

  // Async Memcpy requires pinned memory
  cudaMallocHost( (void**)&amp;x,   N*sizeof(double) );
  cudaMallocHost( (void**)&amp;y,   N*sizeof(double) );
  cudaMalloc(     (void**)&amp;d_x, N*sizeof(double) );
  cudaMalloc(     (void**)&amp;d_y, N*sizeof(double) );

  dev = omp_get_default_device();
  omp_target_associate_ptr(&amp;x[0], d_x, sizeof(double)*N, 0, dev);
  omp_target_associate_ptr(&amp;y[0], d_y, sizeof(double)*N, 0, dev);

  #pragma omp target nowait depend(out: x[0:N]) \
                     map(from: x[0:N]) device(dev)
  myVectorSet(N,  1.0, x);

  #pragma omp task depend(out: y[0:N])
  myVectorSet(N, -1.0, y);

  // get obj for syncing
  #pragma omp interop init(targetsync: obj) device(dev) \
                 depend(in: x[0:N]) depend(inout: y[0:N])

                                        //foreign rt id and string name
  int        id = (int  )omp_get_interop_int(obj, omp_ipr_fr_id,   NULL);
  char* rt_name = (char*)omp_get_interop_str(obj, omp_ipr_fr_name, NULL);

  if(obj != omp_interop_none &amp;&amp; id == omp_ifr_cuda) {

    printf(&quot; OpenMP working with %s runtime to execute cublas daxpy.\n&quot;,
           rt_name);
    cublasHandle_t handle;
    int rc;
    cublasCreate(&amp;handle);

    cudaStream_t s=
        (cudaStream_t)omp_get_interop_ptr(obj, omp_ipr_targetsync, &amp;rc);
    if(rc != omp_irc_success) {
       fprintf(stderr,&quot;ERROR: Failed to get %s stream, rt error= %d.\n&quot;,
               rt_name, rc);
       if(rc == omp_irc_no_value)
          fprintf(stderr,
                  &quot;Parameters valid, no meaningful value available.&quot;);
       exit(1);
    }

    cublasSetStream( handle,s );
    cudaMemcpyAsync( d_x, x, N*sizeof(double),
                     cudaMemcpyHostToDevice, s );
    cudaMemcpyAsync( d_y, y, N*sizeof(double),
                     cudaMemcpyHostToDevice, s );
    cublasDaxpy(     handle, N, &amp;scalar, &amp;d_x[0], 1, &amp;d_y[0], 1 ) ;
    cudaMemcpyAsync( y, d_y, N*sizeof(double),
                     cudaMemcpyDeviceToHost, s );

  } else {     // Execute as OpenMP offload.

    printf(&quot; Notice: Offloading myDaxpy to perform daxpy calculation.\n&quot;);

    #pragma omp target depend(inout: y[0:N]) depend(in: x[0:N]) nowait \
                       map(to: x[0:N]) map(tofrom: y[0:N]) device(dev)
    myDaxpy(N, scalar, x, y);

  }

   // This also ensures foreign tasks complete.
  #pragma omp interop destroy(obj) nowait depend(out: y[0:N])

  #pragma omp target depend(inout: x[0:N])
  myDscal(N, scalar, x);

  #pragma omp taskwait
  printf(&quot;(-1:-16384) %f:%f\n&quot;, y[0], y[N-1]);
  printf(&quot;(-2:-32768) %f:%f\n&quot;, x[0], x[N-1]);

}

</pre></div>
</div>
</div>
</div>
<p>../../program_control/interop.tex</p>
</div>
<div class="section" id="utilities">
<h2>Utilities<a class="headerlink" href="#utilities" title="Permalink to this headline">¶</a></h2>
<p>This section contains examples of utility routines and features.</p>
<div class="section" id="timing-routines">
<h3>Timing Routines<a class="headerlink" href="#timing-routines" title="Permalink to this headline">¶</a></h3>
<p><strong>routines!omp_get_wtime <code class="docutils literal notranslate"><span class="pre">omp_get_wtime</span></code></strong> <strong>omp_get_wtime routine <code class="docutils literal notranslate"><span class="pre">omp_get_wtime</span></code> routine</strong> <strong>routines!omp_get_wtick <code class="docutils literal notranslate"><span class="pre">omp_get_wtick</span></code></strong> <strong>omp_get_wtick routine <code class="docutils literal notranslate"><span class="pre">omp_get_wtick</span></code> routine</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">omp_get_wtime</span></code> routine can be used to measure the elapsed wall clock time (in seconds) of code execution in a program. The routine is thread safe and can be executed by multiple threads concurrently. The precision of the timer can be obtained by a call to the <code class="docutils literal notranslate"><span class="pre">omp_get_wtick</span></code> routine. The following example shows a use case.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: get_wtime.1
* type: C
*/
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;omp.h&gt;

void work_to_be_timed()
{
  sleep(2);
}

int main()
{
  double start, end;

  start = omp_get_wtime();
  work_to_be_timed();     // any parallel or serial codes
  end = omp_get_wtime();

  printf(&quot;Work took %f seconds\n&quot;, end - start);
  printf(&quot;Precision of the timer is %f (sec)\n&quot;, omp_get_wtick());
  return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: get_wtime.1
! type: F-free
subroutine work_to_be_timed
  use, intrinsic :: iso_c_binding, only: c_int
  interface
     subroutine fsleep(sec) bind(C, name=&quot;sleep&quot;)
       import c_int
       integer(c_int), value :: sec
     end subroutine
  end interface
  call fsleep(2)
end subroutine

program do_work
  use omp_lib
  implicit none
  double precision :: start, end

  start = omp_get_wtime()
  call work_to_be_timed    ! any parallel or serial codes
  end = omp_get_wtime()

  print *, &quot;Work took&quot;, end - start, &quot;seconds&quot;
  print *, &quot;Precision of the timer is&quot;, omp_get_wtick(), &quot;(sec)&quot;
end program

</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="environment-display">
<h3>Environment Display<a class="headerlink" href="#environment-display" title="Permalink to this headline">¶</a></h3>
<p><strong>environment display!OMP_DISPLAY_ENV <code class="docutils literal notranslate"><span class="pre">OMP_DISPLAY_ENV</span></code></strong> <strong>environment variables!OMP_DISPLAY_ENV <code class="docutils literal notranslate"><span class="pre">OMP_DISPLAY_ENV</span></code></strong> <strong>OMP_DISPLAY_ENV <code class="docutils literal notranslate"><span class="pre">OMP_DISPLAY_ENV</span></code></strong> <strong>environment display!omp_display_env routine <code class="docutils literal notranslate"><span class="pre">omp_display_env</span></code> routine</strong> <strong>routines!omp_display_env <code class="docutils literal notranslate"><span class="pre">omp_display_env</span></code></strong> <strong>omp_display_env routine <code class="docutils literal notranslate"><span class="pre">omp_display_env</span></code> routine</strong></p>
<p>The OpenMP version number and the values of ICVs associated with the relevant environment variables can be displayed at runtime by setting  the <code class="docutils literal notranslate"><span class="pre">OMP_DISPLAY_ENV</span></code> environment variable to either  <code class="docutils literal notranslate"><span class="pre">TRUE</span></code> or <code class="docutils literal notranslate"><span class="pre">VERBOSE</span></code>. The information is displayed once by the runtime.</p>
<p>A more flexible or controllable approach is to call  the <code class="docutils literal notranslate"><span class="pre">omp_display_env</span></code> API routine at any desired point of a code to display the same information. This OpenMP 5.1 API routine takes a single  <em>verbose</em>  argument. A value of 0 or .false. (for C/C++ or Fortran) indicates the required OpenMP ICVs associated with environment variables be displayed, and a value of 1 or .true. (for C/C++ or Fortran) will include vendor-specific ICVs that can be modified by environment variables.</p>
<p>The following example illustrates the conditional execution of the API <code class="docutils literal notranslate"><span class="pre">omp_display_env</span></code> routine.  Typically it would be invoked in various debug modes of an application.  An important use case is to have a single MPI process (e.g., rank = 0)  of a hybrid (MPI+OpenMP) code execute the routine, instead of all MPI processes, as would be done by  setting the <code class="docutils literal notranslate"><span class="pre">OMP_DISPLAY_ENV</span></code> to <code class="docutils literal notranslate"><span class="pre">TRUE</span></code> or <code class="docutils literal notranslate"><span class="pre">VERBOSE</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: display_env.1
* type: C
* version: omp_5.1
*/
#include &lt;omp.h&gt;

//implementers: customize debug routines for app debugging
int debug(){ return 1; }
int debug_omp_verbose(){ return 0; }

int main()
{
   if( debug() ) omp_display_env( debug_omp_verbose() );
   // ...
   return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: display_env.1
! type: F-free
! version: omp_5.1
!implementers: customize debug routines for app debugging
function  debug()
  logical :: debug
  debug = .true.
end function

function debug_omp_verbose()
  logical :: debug_omp_verbose
  debug_omp_verbose = .false.
end function

program display_omp_environment
  use omp_lib
  logical :: debug, debug_omp_verbose

  if( debug() ) call omp_display_env( debug_omp_verbose() )
  !! ...
end program


</pre></div>
</div>
</div>
</div>
<p>A sample output from the execution of the code might look like: {  OPENMP DISPLAY ENVIRONMENT BEGIN     _OPENMP=’202011’    [host] OMP_AFFINITY_FORMAT=’(null)’    [host] OMP_ALLOCATOR=’omp_default_mem_alloc’    [host] OMP_CANCELLATION=’FALSE’    [host] OMP_DEFAULT_DEVICE=’0’    [host] OMP_DISPLAY_AFFINITY=’FALSE’    [host] OMP_DISPLAY_ENV=’FALSE’    [host] OMP_DYNAMIC=’FALSE’    [host] OMP_MAX_ACTIVE_LEVELS=’1’    [host] OMP_MAX_TASK_PRIORITY=’0’    [host] OMP_NESTED: deprecated; max-active-levels-var=1    [host] OMP_NUM_THREADS: value is not defined    [host] OMP_PLACES: value is not defined    [host] OMP_PROC_BIND: value is not defined    [host] OMP_SCHEDULE=’static’    [host] OMP_STACKSIZE=’4M’    [host] OMP_TARGET_OFFLOAD=DEFAULT    [host] OMP_THREAD_LIMIT=’0’    [host] OMP_TOOL=’enabled’    [host] OMP_TOOL_LIBRARIES: value is not defined  OPENMP DISPLAY ENVIRONMENT END }</p>
</div>
<div class="section" id="error-directive">
<h3><code class="docutils literal notranslate"><span class="pre">error</span></code> Directive<a class="headerlink" href="#error-directive" title="Permalink to this headline">¶</a></h3>
<p><strong>directives!error <code class="docutils literal notranslate"><span class="pre">error</span></code></strong> <strong>error directive <code class="docutils literal notranslate"><span class="pre">error</span></code> directive</strong> <strong>error directive <code class="docutils literal notranslate"><span class="pre">error</span></code> directive!at clause <code class="docutils literal notranslate"><span class="pre">at</span></code> clause</strong> <strong>clauses!at <code class="docutils literal notranslate"><span class="pre">at</span></code></strong> <strong>at clause <code class="docutils literal notranslate"><span class="pre">at</span></code> clause</strong> <strong>error directive <code class="docutils literal notranslate"><span class="pre">error</span></code> directive!severity clause <code class="docutils literal notranslate"><span class="pre">severity</span></code> clause</strong> <strong>clauses!severity <code class="docutils literal notranslate"><span class="pre">severity</span></code></strong> <strong>severity clause <code class="docutils literal notranslate"><span class="pre">severity</span></code> clause</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">error</span></code> directive provides a consistent method for C, C++, and Fortran to emit a  <em>fatal</em>  or  <em>warning</em>  message at  <em>compilation</em>  or  <em>execution</em>  time, as determined by a <code class="docutils literal notranslate"><span class="pre">severity</span></code>  or an <code class="docutils literal notranslate"><span class="pre">at</span></code> clause, respectively. When <code class="docutils literal notranslate"><span class="pre">severity(fatal)</span></code> is present, the compilation  or execution is aborted. Without any clauses the default behavior is as if <code class="docutils literal notranslate"><span class="pre">at(compilation)</span></code>  and <code class="docutils literal notranslate"><span class="pre">severity(fatal)</span></code> were specified.</p>
<p>The C, C++, and Fortran examples below show all the cases for reporting messages.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name:       error.1
* type:       C
* version:    omp_5.2
*/
#include &lt;stdio.h&gt;
#include   &lt;omp.h&gt;

int main(){

#pragma omp metadirective \
            when(implementation={vendor(gnu)}: nothing )   \
            otherwise(error at(compilation) severity(fatal) \
                    message(&quot;GNU compiler required.&quot;))

  if( omp_get_num_procs() &lt; 3 ){
    #pragma omp error at(runtime) severity(fatal) \
                      message(&quot;3 or more procs required.&quot;)
  }

  #pragma omp parallel master
  {
    // Give notice about master deprecation at compile time and run time.
    #pragma omp error at(compilation) severity(warning) \
                      message(&quot;Notice: master is deprecated.&quot;)
    #pragma omp error at(runtime) severity(warning) \
                      message(&quot;Notice: masked used next release.&quot;)

     printf(&quot; Hello from thread number 0.\n&quot;);
  }

}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name:       error.1
! type:       F-free
! version:    omp_5.2
program main
use omp_lib

!$omp  metadirective  &amp;
!$omp&amp;     when( implementation={vendor(gnu)}: nothing    ) &amp;
!$omp&amp;     otherwise( error at(compilation) severity(fatal) &amp;
!$omp&amp;                message( &quot;GNU compiler required.&quot; ) )


if( omp_get_num_procs() &lt; 3 ) then
   !$omp  error at(runtime) severity(fatal) &amp;
   !$omp&amp;       message(&quot;3 or more procs required.&quot;)
endif

  !$omp parallel master

!! Give notice about master deprecation at compile time and run time.
  !$omp  error at(compilation) severity(warning) &amp;
  !$omp&amp;       message(&quot;Notice: master is deprecated.&quot;)
  !$omp  error at(runtime) severity(warning) &amp;
  !$omp&amp;       message(&quot;Notice: masked to be used in next release.&quot;)

  print*,&quot; Hello from thread number 0.&quot;

  !$omp end parallel master

end program

</pre></div>
</div>
</div>
</div>
<p>../../program_control/utilities.tex</p>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "native"
        },
        kernelOptions: {
            kernelName: "native",
            path: "./contents"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'native'</script>

              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="Chap_memory_model.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Memory Model</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="Chap_ompt_interface.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">&lt;no title&gt;</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      By The OpenMP Community<br/>
    
        &copy; Copyright 2021.<br/>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>