
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Parallel Execution &#8212; OpenMP Application Programming Interface Examples</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet">
  <link href="../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script>
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="OpenMP Affinity" href="Chap_affinity.html" />
    <link rel="prev" title="OpenMP Directive Syntax" href="Chap_directives.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">OpenMP Application Programming Interface Examples</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../intro.html">
   Welcome to OMP Jupyter Book
  </a>
 </li>
</ul>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_directives.html">
   OpenMP Directive Syntax
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Parallel Execution
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_affinity.html">
   OpenMP Affinity
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_tasking.html">
   Tasking
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_SIMD.html">
   SIMD
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_synchronization.html">
   Synchronization
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_data_environment.html">
   Data Environment
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_memory_model.html">
   Memory Model
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_program_control.html">
   Program Control
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/contents/Chap_parallel_execution.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
                onclick="printPdf(this)" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/passlab/Examples"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/passlab/Examples/issues/new?title=Issue%20on%20page%20%2Fcontents/Chap_parallel_execution.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/passlab/Examples/main?urlpath=lab/tree/notebook/contents/Chap_parallel_execution.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#a-simple-parallel-loop">
   A Simple Parallel Loop
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#parallel-construct">
   <code class="docutils literal notranslate">
    <span class="pre">
     parallel
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#teams-construct-on-host">
   <code class="docutils literal notranslate">
    <span class="pre">
     teams
    </span>
   </code>
   Construct on Host
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#controlling-the-number-of-threads-on-multiple-nesting-levels">
   Controlling the Number of Threads on Multiple Nesting Levels
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#interaction-between-the-num-threads-clause-and-omp-set-dynamic">
   Interaction Between the
   <code class="docutils literal notranslate">
    <span class="pre">
     num_threads
    </span>
   </code>
   Clause and
   <code class="docutils literal notranslate">
    <span class="pre">
     omp_set_dynamic
    </span>
   </code>
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#fortran-restrictions-on-the-do-construct">
   Fortran Restrictions on the
   <code class="docutils literal notranslate">
    <span class="pre">
     do
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#nowait-clause">
   <code class="docutils literal notranslate">
    <span class="pre">
     nowait
    </span>
   </code>
   Clause
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#collapse-clause">
   <code class="docutils literal notranslate">
    <span class="pre">
     collapse
    </span>
   </code>
   Clause
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#linear-clause-in-loop-constructs">
   <code class="docutils literal notranslate">
    <span class="pre">
     linear
    </span>
   </code>
   Clause in Loop Constructs
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#parallel-sections-construct">
   <code class="docutils literal notranslate">
    <span class="pre">
     parallel
    </span>
   </code>
   <code class="docutils literal notranslate">
    <span class="pre">
     sections
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#firstprivate-clause-and-sections-construct">
   <code class="docutils literal notranslate">
    <span class="pre">
     firstprivate
    </span>
   </code>
   Clause and
   <code class="docutils literal notranslate">
    <span class="pre">
     sections
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#single-construct">
   <code class="docutils literal notranslate">
    <span class="pre">
     single
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#workshare-construct">
   <code class="docutils literal notranslate">
    <span class="pre">
     workshare
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#masked-construct">
   <code class="docutils literal notranslate">
    <span class="pre">
     masked
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#loop-construct">
   <code class="docutils literal notranslate">
    <span class="pre">
     loop
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#parallel-random-access-iterator-loop">
   Parallel Random Access Iterator Loop
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#omp-set-dynamic-and-omp-set-num-threads-routines">
   <code class="docutils literal notranslate">
    <span class="pre">
     omp_set_dynamic
    </span>
   </code>
   and
   <code class="docutils literal notranslate">
    <span class="pre">
     omp_set_num_threads
    </span>
   </code>
   Routines
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#omp-get-num-threads-routine">
   <code class="docutils literal notranslate">
    <span class="pre">
     omp_get_num_threads
    </span>
   </code>
   Routine
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Parallel Execution</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#a-simple-parallel-loop">
   A Simple Parallel Loop
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#parallel-construct">
   <code class="docutils literal notranslate">
    <span class="pre">
     parallel
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#teams-construct-on-host">
   <code class="docutils literal notranslate">
    <span class="pre">
     teams
    </span>
   </code>
   Construct on Host
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#controlling-the-number-of-threads-on-multiple-nesting-levels">
   Controlling the Number of Threads on Multiple Nesting Levels
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#interaction-between-the-num-threads-clause-and-omp-set-dynamic">
   Interaction Between the
   <code class="docutils literal notranslate">
    <span class="pre">
     num_threads
    </span>
   </code>
   Clause and
   <code class="docutils literal notranslate">
    <span class="pre">
     omp_set_dynamic
    </span>
   </code>
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#fortran-restrictions-on-the-do-construct">
   Fortran Restrictions on the
   <code class="docutils literal notranslate">
    <span class="pre">
     do
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#nowait-clause">
   <code class="docutils literal notranslate">
    <span class="pre">
     nowait
    </span>
   </code>
   Clause
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#collapse-clause">
   <code class="docutils literal notranslate">
    <span class="pre">
     collapse
    </span>
   </code>
   Clause
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#linear-clause-in-loop-constructs">
   <code class="docutils literal notranslate">
    <span class="pre">
     linear
    </span>
   </code>
   Clause in Loop Constructs
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#parallel-sections-construct">
   <code class="docutils literal notranslate">
    <span class="pre">
     parallel
    </span>
   </code>
   <code class="docutils literal notranslate">
    <span class="pre">
     sections
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#firstprivate-clause-and-sections-construct">
   <code class="docutils literal notranslate">
    <span class="pre">
     firstprivate
    </span>
   </code>
   Clause and
   <code class="docutils literal notranslate">
    <span class="pre">
     sections
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#single-construct">
   <code class="docutils literal notranslate">
    <span class="pre">
     single
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#workshare-construct">
   <code class="docutils literal notranslate">
    <span class="pre">
     workshare
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#masked-construct">
   <code class="docutils literal notranslate">
    <span class="pre">
     masked
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#loop-construct">
   <code class="docutils literal notranslate">
    <span class="pre">
     loop
    </span>
   </code>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#parallel-random-access-iterator-loop">
   Parallel Random Access Iterator Loop
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#omp-set-dynamic-and-omp-set-num-threads-routines">
   <code class="docutils literal notranslate">
    <span class="pre">
     omp_set_dynamic
    </span>
   </code>
   and
   <code class="docutils literal notranslate">
    <span class="pre">
     omp_set_num_threads
    </span>
   </code>
   Routines
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#omp-get-num-threads-routine">
   <code class="docutils literal notranslate">
    <span class="pre">
     omp_get_num_threads
    </span>
   </code>
   Routine
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="parallel-execution">
<h1>Parallel Execution<a class="headerlink" href="#parallel-execution" title="Permalink to this headline">¶</a></h1>
<p>{parallel_execution}</p>
<p>A single thread, the  <em>initial thread</em> , begins sequential execution of  an OpenMP enabled program, as if the whole program is in an implicit parallel region consisting of an implicit task executed by the  <em>initial thread</em> .</p>
<p>A <code class="docutils literal notranslate"><span class="pre">parallel</span></code> construct encloses code,  forming a parallel region.  An  <em>initial thread</em>  encountering a <code class="docutils literal notranslate"><span class="pre">parallel</span></code>  region forks (creates) a team of threads at the beginning of the  <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region, and joins them (removes from execution) at the  end of the region.  The initial thread becomes the primary thread of the team in a  <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region with a  <em>thread</em>  number equal to zero, the other  threads are numbered from 1 to number of threads minus 1.  A team may be comprised of just a single thread.</p>
<p>Each thread of a team is assigned an implicit task consisting of code within the  parallel region. The task that creates a parallel region is suspended while the tasks of the team are executed.  A thread is tied to its task; that is, only the thread assigned to the task can execute that task.  After completion  of the <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region, the primary thread resumes execution of the generating task.</p>
<p>Any task within a <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region is allowed to encounter another <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region to form a nested <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region. The  parallelism of a nested <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region (whether it forks additional  threads, or is executed serially by the encountering task) can be controlled by the <code class="docutils literal notranslate"><span class="pre">OMP_NESTED</span></code> environment variable or the <code class="docutils literal notranslate"><span class="pre">omp_set_nested()</span></code>  API routine with arguments indicating true or false.</p>
<p>The number of threads of a <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region can be set by the <code class="docutils literal notranslate"><span class="pre">OMP_NUM_THREADS</span></code> environment variable, the <code class="docutils literal notranslate"><span class="pre">omp_set_num_threads()</span></code> routine, or on the <code class="docutils literal notranslate"><span class="pre">parallel</span></code>  directive with the <code class="docutils literal notranslate"><span class="pre">num_threads</span></code> clause. The routine overrides the environment variable, and the clause overrides all.  Use the <code class="docutils literal notranslate"><span class="pre">OMP_DYNAMIC</span></code> or the <code class="docutils literal notranslate"><span class="pre">omp_set_dynamic()</span></code> function to specify that the OpenMP implementation dynamically adjust the number of threads for <code class="docutils literal notranslate"><span class="pre">parallel</span></code> regions.  The default setting for dynamic adjustment is implementation defined. When dynamic adjustment is on and the number of threads is specified, the number of threads becomes an upper limit for the number of threads to be provided by the OpenMP runtime.</p>
<p>WORKSHARING CONSTRUCTS</p>
<p>A worksharing construct distributes the execution of the associated region among the members of the team that encounter it.  There is an implied barrier at the end of the worksharing region (there is no barrier at the beginning). The worksharing constructs are:</p>
<ul class="simple">
<li><p>loop constructs: {<code class="docutils literal notranslate"><span class="pre">for</span></code> and <code class="docutils literal notranslate"><span class="pre">do</span></code> }</p></li>
</ul>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sections</span></code></p></li>
</ul>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">single</span></code></p></li>
</ul>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">workshare</span></code></p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">for</span></code> and <code class="docutils literal notranslate"><span class="pre">do</span></code> constructs (loop constructs) create a region  consisting of a loop.  A loop controlled by a loop construct is called  an  <em>associated</em>  loop.  Nested loops can form a single region when the  <code class="docutils literal notranslate"><span class="pre">collapse</span></code> clause (with an integer argument) designates the number of   <em>associated</em>  loops to be executed in parallel, by forming a  “single iteration space” for the specified number of nested loops.   The <code class="docutils literal notranslate"><span class="pre">ordered</span></code> clause can also control multiple associated loops.</p>
<p>An associated loop must adhere to a “canonical form” (specified in the   <em>Canonical Loop Form</em>  of the OpenMP Specifications document) which allows the  iteration count (of all associated loops) to be computed before the  (outermost) loop is executed. Most common loops comply with the canonical form, including C++ iterators.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">single</span></code> construct forms a region in which only one thread (any one  of the team) executes the region.  The other threads wait at the implied  barrier at the end, unless the <code class="docutils literal notranslate"><span class="pre">nowait</span></code> clause is specified.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">sections</span></code> construct forms a region that contains one or more  structured blocks.  Each block of a <code class="docutils literal notranslate"><span class="pre">sections</span></code> directive is  constructed with a <code class="docutils literal notranslate"><span class="pre">section</span></code> construct, and executed once by  one of the threads (any one) in the team.  (If only one block is  formed in the region, the <code class="docutils literal notranslate"><span class="pre">section</span></code> construct, which is used to separate blocks, is not required.) The other threads wait at the implied  barrier at the end, unless the <code class="docutils literal notranslate"><span class="pre">nowait</span></code> clause is specified.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">workshare</span></code> construct is a Fortran feature that consists of a region with a single structure block (section of code). Statements in the <code class="docutils literal notranslate"><span class="pre">workshare</span></code> region are divided into units of work, and executed (once) by threads of the team.</p>
<p>MASKED CONSTRUCT</p>
<p>The <code class="docutils literal notranslate"><span class="pre">masked</span></code> construct is not a worksharing construct.  The <code class="docutils literal notranslate"><span class="pre">masked</span></code> region is executed only by the primary thread. There is no implicit barrier (and flush)  at the end of the <code class="docutils literal notranslate"><span class="pre">masked</span></code> region; hence the other threads of the team continue execution beyond code statements beyond the <code class="docutils literal notranslate"><span class="pre">masked</span></code> region. The <code class="docutils literal notranslate"><span class="pre">master</span></code> construct, which has been deprecated in OpenMP 5.1, has identical semantics to the <code class="docutils literal notranslate"><span class="pre">masked</span></code> construct with no <code class="docutils literal notranslate"><span class="pre">filter</span></code> clause.</p>
<div class="section" id="a-simple-parallel-loop">
<h2>A Simple Parallel Loop<a class="headerlink" href="#a-simple-parallel-loop" title="Permalink to this headline">¶</a></h2>
<p><strong>combined constructs!parallel worksharing-loop</strong> <strong>constructs!parallel <code class="docutils literal notranslate"><span class="pre">parallel</span></code></strong> <strong>parallel construct <code class="docutils literal notranslate"><span class="pre">parallel</span></code> construct</strong> <strong>worksharing-loop constructs!for <code class="docutils literal notranslate"><span class="pre">for</span></code></strong> <strong>worksharing-loop constructs!do <code class="docutils literal notranslate"><span class="pre">do</span></code></strong> <strong>constructs!for <code class="docutils literal notranslate"><span class="pre">for</span></code></strong> <strong>constructs!do <code class="docutils literal notranslate"><span class="pre">do</span></code></strong> <strong>for construct <code class="docutils literal notranslate"><span class="pre">for</span></code> construct</strong> <strong>do construct <code class="docutils literal notranslate"><span class="pre">do</span></code> construct</strong></p>
<p>The following example demonstrates how to parallelize a simple loop  using the parallel worksharing-loop construct. The loop iteration variable is private by default, so it is not  necessary to specify it explicitly in a <code class="docutils literal notranslate"><span class="pre">private</span></code> clause.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: ploop.1
* type: C
*/
void simple(int n, float *a, float *b)
{
    int i;

#pragma omp parallel for
    for (i=1; i&lt;n; i++) /* i is private by default */
        b[i] = (a[i] + a[i-1]) / 2.0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: ploop.1
! type: F-fixed
      SUBROUTINE SIMPLE(N, A, B)

      INTEGER I, N
      REAL B(N), A(N)

!$OMP PARALLEL DO  !I is private by default
      DO I=2,N
          B(I) = (A(I) + A(I-1)) / 2.0
      ENDDO
!$OMP END PARALLEL DO

      END SUBROUTINE SIMPLE

</pre></div>
</div>
</div>
</div>
<p>../../parallel_execution/ploop.tex</p>
</div>
<div class="section" id="parallel-construct">
<h2><code class="docutils literal notranslate"><span class="pre">parallel</span></code> Construct<a class="headerlink" href="#parallel-construct" title="Permalink to this headline">¶</a></h2>
<p><strong>constructs!parallel <code class="docutils literal notranslate"><span class="pre">parallel</span></code></strong> <strong>parallel construct <code class="docutils literal notranslate"><span class="pre">parallel</span></code> construct</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">parallel</span></code> construct  can be used in coarse-grain parallel programs.  In the following example, each thread in the <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region decides what  part of the global array  <em>x</em>  to work on, based on the thread number:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: parallel.1
* type: C
*/
#include &lt;omp.h&gt;

void subdomain(float *x, int istart, int ipoints)
{
  int i;

  for (i = 0; i &lt; ipoints; i++)
      x[istart+i] = 123.456;
}

void sub(float *x, int npoints)
{
    int iam, nt, ipoints, istart;

#pragma omp parallel default(shared) private(iam,nt,ipoints,istart)
    {
        iam = omp_get_thread_num();
        nt =  omp_get_num_threads();
        ipoints = npoints / nt;    /* size of partition */
        istart = iam * ipoints;  /* starting array index */
        if (iam == nt-1)     /* last thread may do more */
          ipoints = npoints - istart;
        subdomain(x, istart, ipoints);
    }
}

int main()
{
    float array[10000];

    sub(array, 10000);

    return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: parallel.1
! type: F-fixed
      SUBROUTINE SUBDOMAIN(X, ISTART, IPOINTS)
          INTEGER ISTART, IPOINTS
          REAL X(*)

          INTEGER I

          DO 100 I=1,IPOINTS
             X(ISTART+I) = 123.456
 100      CONTINUE

      END SUBROUTINE SUBDOMAIN

      SUBROUTINE SUB(X, NPOINTS)
          INCLUDE &quot;omp_lib.h&quot;     ! or USE OMP_LIB

          REAL X(*)
          INTEGER NPOINTS
          INTEGER IAM, NT, IPOINTS, ISTART

!$OMP PARALLEL DEFAULT(PRIVATE) SHARED(X,NPOINTS)

          IAM = OMP_GET_THREAD_NUM()
          NT =  OMP_GET_NUM_THREADS()
          IPOINTS = NPOINTS/NT
          ISTART = IAM * IPOINTS
          IF (IAM .EQ. NT-1) THEN
              IPOINTS = NPOINTS - ISTART
          ENDIF
          CALL SUBDOMAIN(X,ISTART,IPOINTS)

!$OMP END PARALLEL
      END SUBROUTINE SUB

      PROGRAM PAREXAMPLE
          REAL ARRAY(10000)
          CALL SUB(ARRAY, 10000)
      END PROGRAM PAREXAMPLE

</pre></div>
</div>
</div>
</div>
<p>../../parallel_execution/parallel.tex</p>
</div>
<div class="section" id="teams-construct-on-host">
<h2><code class="docutils literal notranslate"><span class="pre">teams</span></code> Construct on Host<a class="headerlink" href="#teams-construct-on-host" title="Permalink to this headline">¶</a></h2>
<p><strong>constructs!teams <code class="docutils literal notranslate"><span class="pre">teams</span></code></strong> <strong>teams construct <code class="docutils literal notranslate"><span class="pre">teams</span></code> construct</strong></p>
<p>Originally the <code class="docutils literal notranslate"><span class="pre">teams</span></code> construct was created for devices (such as GPUs) for independent executions of a structured block by teams within a league (on SMs). It was only available through offloading with the <code class="docutils literal notranslate"><span class="pre">target</span></code> construct, and the execution of a <code class="docutils literal notranslate"><span class="pre">teams</span></code> region could only be directed to host execution by various means such as <code class="docutils literal notranslate"><span class="pre">if</span></code> and <code class="docutils literal notranslate"><span class="pre">device</span></code> clauses, and the <code class="docutils literal notranslate"><span class="pre">OMP_TARGET_OFFLOAD</span></code> environment variable.</p>
<p>In OpenMP 5.0 the <code class="docutils literal notranslate"><span class="pre">teams</span></code> construct was extended to enable the host to execute a <code class="docutils literal notranslate"><span class="pre">teams</span></code> region (without an associated <code class="docutils literal notranslate"><span class="pre">target</span></code> construct),  with anticipation of further affinity and threading controls in future OpenMP releases.</p>
<p>In the example below the <code class="docutils literal notranslate"><span class="pre">teams</span></code> construct is used to create two teams, one to execute single precision code, and the other to execute double precision code. Two teams are required, and the thread limit for each team is set to 1/2 of the number of  available processors.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: host_teams.1
* type: C
* version: omp_5.0
*/
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include  &lt;math.h&gt;
#include   &lt;omp.h&gt;
#define    N 1000

int main(){
   int     nteams_required=2, max_thrds, tm_id;
   float   sp_x[N], sp_y[N], sp_a=0.0001e0;
   double  dp_x[N], dp_y[N], dp_a=0.0001e0;

   max_thrds = omp_get_num_procs()/nteams_required;

   // Create 2 teams, each team works in a different precision
   #pragma omp teams num_teams(nteams_required) \
                     thread_limit(max_thrds)  private(tm_id)
   {
      tm_id = omp_get_team_num();

      if( omp_get_num_teams() != 2 )   //if only getting 1, quit
      { printf(&quot;error: Insufficient teams on host, 2 required\n&quot;);
        exit(0);
      }

      if(tm_id == 0)  // Do Single Precision Work (SAXPY) with this team
      {
         #pragma omp parallel
         {
            #pragma omp for                             //init
            for(int i=0; i&lt;N; i++){sp_x[i] = i*0.0001;  sp_y[i]=i; }

            #pragma omp for simd simdlen(8)
            for(int i=0; i&lt;N; i++){sp_x[i] = sp_a*sp_x[i] + sp_y[i];}
         }
      }

      if(tm_id == 1)  // Do Double Precision Work (DAXPY) with this team
      {
         #pragma omp parallel
         {
            #pragma omp for                             //init
            for(int i=0; i&lt;N; i++){dp_x[i] = i*0.0001;  dp_y[i]=i; }

            #pragma omp for simd simdlen(4)
            for(int i=0; i&lt;N; i++){dp_x[i] = dp_a*dp_x[i] + dp_y[i];}
         }
      }
   }

   printf(&quot;i=%d  sp|dp  %f %f \n&quot;,N-1, sp_x[N-1], dp_x[N-1]);
   printf(&quot;i=%d  sp|dp  %f %f \n&quot;,N/2, sp_x[N/2], dp_x[N/2]);
 //OUTPUT1:i=999  sp|dp  999.000000 999.000010
 //OUTPUT2:i=500  sp|dp  500.000000 500.000005

   return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: host_teams.1
! type: F-free
! version: omp_5.0

program main
   use omp_lib
   integer           :: nteams_required=2, max_thrds, tm_id
   integer,parameter ::  N=1000
   real              :: sp_x(N), sp_y(N), sp_a=0.0001e0
   double precision  :: dp_x(N), dp_y(N), dp_a=0.0001d0

   max_thrds = omp_get_num_procs()/nteams_required

   !! Create 2 teams, each team works in a different precision
   !$omp teams num_teams(nteams_required) thread_limit(max_thrds) \
               private(tm_id)

      tm_id = omp_get_team_num()

      if( omp_get_num_teams() /= 2 ) then   !! if only getting 1, quit
         stop &quot;error: Insufficient teams on host, 2 required.&quot;
      endif

      !! Do Single Precision Work (SAXPY) with this team
      if(tm_id == 0) then

         !$omp parallel
            !$omp do         !! init
            do i = 1,N
               sp_x(i) = i*0.0001e0
               sp_y(i) = i
            end do

            !$omp do simd simdlen(8)
            do i = 1,N
               sp_x(i) = sp_a*sp_x(i) + sp_y(i)
            end do
         !$omp end parallel

      endif

      !! Do Double Precision Work (DAXPY) with this team
      if(tm_id == 1) then

         !$omp parallel
            !$omp do         !! init
            do i = 1,N
               dp_x(i) = i*0.0001d0
               dp_y(i) = i
            end do

            !$omp do simd simdlen(4)
            do i = 1,N
               dp_x(i) = dp_a*dp_x(i) + dp_y(i)
            end do
         !$omp end parallel

      endif
   !$omp end teams

   write(*,&#39;( &quot;i=&quot;,i4,&quot; sp|dp= &quot;, e15.7, d25.16  )&#39;) &amp;
            N, sp_x(N), dp_x(N)
   write(*,&#39;( &quot;i=&quot;,i4,&quot; sp|dp= &quot;, e15.7, d25.16  )&#39;) &amp;
            N/2, sp_x(N/2), dp_x(N/2)
            !! i=1000 sp|dp=   0.1000000E+04   0.1000000010000000D+04
            !! i= 500 sp|dp=   0.5000000E+03   0.5000000050000000D+03
end program

</pre></div>
</div>
</div>
</div>
<p>../../parallel_execution/host_teams.tex</p>
</div>
<div class="section" id="controlling-the-number-of-threads-on-multiple-nesting-levels">
<h2>Controlling the Number of Threads on Multiple Nesting Levels<a class="headerlink" href="#controlling-the-number-of-threads-on-multiple-nesting-levels" title="Permalink to this headline">¶</a></h2>
<p><strong>environment variables!OMP_NUM_THREADS <code class="docutils literal notranslate"><span class="pre">OMP_NUM_THREADS</span></code></strong> <strong>OMP_NUM_THREADS <code class="docutils literal notranslate"><span class="pre">OMP_NUM_THREADS</span></code></strong></p>
<p>The following examples demonstrate how to use the <code class="docutils literal notranslate"><span class="pre">OMP_NUM_THREADS</span></code> environment  variable  to control the number of threads on multiple nesting levels:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: nthrs_nesting.1
* type: C
*/
#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;
int main (void)
{
   omp_set_nested(1);
   omp_set_dynamic(0);
   #pragma omp parallel
   {
      #pragma omp parallel
      {
         #pragma omp single
         {
         /*
         * If OMP_NUM_THREADS=2,3 was set, the following should print:
         * Inner: num_thds=3
         * Inner: num_thds=3
         *
         * If nesting is not supported, the following should print:
         * Inner: num_thds=1
         * Inner: num_thds=1
         */
            printf (&quot;Inner: num_thds=%d\n&quot;, omp_get_num_threads());
         }
      }
      #pragma omp barrier
      omp_set_nested(0);
      #pragma omp parallel
      {
         #pragma omp single
         {
         /*
         * Even if OMP_NUM_THREADS=2,3 was set, the following should
         * print, because nesting is disabled:
         * Inner: num_thds=1
         * Inner: num_thds=1
         */
            printf (&quot;Inner: num_thds=%d\n&quot;, omp_get_num_threads());
         }
      }
      #pragma omp barrier
      #pragma omp single
      {
         /*
         * If OMP_NUM_THREADS=2,3 was set, the following should print:
         * Outer: num_thds=2
         */
         printf (&quot;Outer: num_thds=%d\n&quot;, omp_get_num_threads());
      }
   }
   return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: nthrs_nesting.1
! type: F-fixed
 program icv
 use omp_lib
 call omp_set_nested(.true.)
 call omp_set_dynamic(.false.)
!$omp parallel
!$omp parallel
!$omp single
 ! If OMP_NUM_THREADS=2,3 was set, the following should print:
 ! Inner: num_thds= 3
 ! Inner: num_thds= 3
 ! If nesting is not supported, the following should print:
 ! Inner: num_thds= 1
 ! Inner: num_thds= 1
 print *, &quot;Inner: num_thds=&quot;, omp_get_num_threads()
!$omp end single
!$omp end parallel
!$omp barrier
 call omp_set_nested(.false.)
!$omp parallel
!$omp single
 ! Even if OMP_NUM_THREADS=2,3 was set, the following should print,
 ! because nesting is disabled:
 ! Inner: num_thds= 1
 ! Inner: num_thds= 1
 print *, &quot;Inner: num_thds=&quot;, omp_get_num_threads()
!$omp end single
!$omp end parallel
!$omp barrier
!$omp single
 ! If OMP_NUM_THREADS=2,3 was set, the following should print:
 ! Outer: num_thds= 2
 print *, &quot;Outer: num_thds=&quot;, omp_get_num_threads()
!$omp end single
!$omp end parallel
 end

</pre></div>
</div>
</div>
</div>
<p>../../parallel_execution/nthrs_nesting.tex</p>
</div>
<div class="section" id="interaction-between-the-num-threads-clause-and-omp-set-dynamic">
<h2>Interaction Between the <code class="docutils literal notranslate"><span class="pre">num_threads</span></code> Clause and <code class="docutils literal notranslate"><span class="pre">omp_set_dynamic</span></code><a class="headerlink" href="#interaction-between-the-num-threads-clause-and-omp-set-dynamic" title="Permalink to this headline">¶</a></h2>
<p><strong>clauses!num_threads <code class="docutils literal notranslate"><span class="pre">num_threads</span></code></strong> <strong>num_threads clause <code class="docutils literal notranslate"><span class="pre">num_threads</span></code> clause</strong> <strong>routines!omp_set_dynamic <code class="docutils literal notranslate"><span class="pre">omp_set_dynamic</span></code></strong> <strong>omp_set_dynamic routine <code class="docutils literal notranslate"><span class="pre">omp_set_dynamic</span></code> routine</strong></p>
<p>The following example demonstrates the <code class="docutils literal notranslate"><span class="pre">num_threads</span></code> clause  and the effect  of the  <code class="docutils literal notranslate"><span class="pre">omp_set_dynamic</span></code> routine  on it.</p>
<p>The call to the <code class="docutils literal notranslate"><span class="pre">omp_set_dynamic</span></code> routine with argument <code class="docutils literal notranslate"><span class="pre">0</span></code> in  C/C++, or <code class="docutils literal notranslate"><span class="pre">.FALSE.</span></code> in Fortran, disables the dynamic adjustment of the number  of threads in OpenMP implementations that support it. In this case, 10 threads  are provided. Note that in case of an error the OpenMP implementation is free to  abort the program or to supply any number of threads available.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: nthrs_dynamic.1
* type: C
*/
#include &lt;omp.h&gt;
int main()
{
  omp_set_dynamic(0);
  #pragma omp parallel num_threads(10)
  {
    /* do work here */
  }
  return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: nthrs_dynamic.1
! type: F-fixed
      PROGRAM EXAMPLE
        INCLUDE &quot;omp_lib.h&quot;      ! or USE OMP_LIB
        CALL OMP_SET_DYNAMIC(.FALSE.)
!$OMP     PARALLEL NUM_THREADS(10)
            ! do work here
!$OMP     END PARALLEL
      END PROGRAM EXAMPLE

</pre></div>
</div>
</div>
</div>
<p>The call to the <code class="docutils literal notranslate"><span class="pre">omp_set_dynamic</span></code> routine with a non-zero argument in  C/C++, or <code class="docutils literal notranslate"><span class="pre">.TRUE.</span></code> in Fortran, allows the OpenMP implementation to choose  any number of threads between 1 and 10.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: nthrs_dynamic.2
* type: C
*/
#include &lt;omp.h&gt;
int main()
{
  omp_set_dynamic(1);
  #pragma omp parallel num_threads(10)
  {
    /* do work here */
  }
  return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: nthrs_dynamic.2
! type: F-fixed
      PROGRAM EXAMPLE
        INCLUDE &quot;omp_lib.h&quot;      ! or USE OMP_LIB
        CALL OMP_SET_DYNAMIC(.TRUE.)
!$OMP     PARALLEL NUM_THREADS(10)
            ! do work here
!$OMP     END PARALLEL
      END PROGRAM EXAMPLE

</pre></div>
</div>
</div>
</div>
<p>It is good practice to set the  <em>dyn-var</em>  ICV explicitly by calling the <code class="docutils literal notranslate"><span class="pre">omp_set_dynamic</span></code>  routine, as its default setting is implementation defined.</p>
<p>../../parallel_execution/nthrs_dynamic.tex</p>
</div>
<div class="section" id="fortran-restrictions-on-the-do-construct">
<h2>Fortran Restrictions on the <code class="docutils literal notranslate"><span class="pre">do</span></code> Construct<a class="headerlink" href="#fortran-restrictions-on-the-do-construct" title="Permalink to this headline">¶</a></h2>
<p><strong>constructs!do <code class="docutils literal notranslate"><span class="pre">do</span></code></strong> <strong>do construct <code class="docutils literal notranslate"><span class="pre">do</span></code> construct</strong></p>
<p>If an <code class="docutils literal notranslate"><span class="pre">end</span> <span class="pre">do</span></code> directive follows a  <em>do-construct</em>   in which several  <code class="docutils literal notranslate"><span class="pre">DO</span></code> statements share a <code class="docutils literal notranslate"><span class="pre">DO</span></code> termination statement, then a  <code class="docutils literal notranslate"><span class="pre">do</span></code>  directive can only be specified for the outermost of these <code class="docutils literal notranslate"><span class="pre">DO</span></code> statements.  The following example contains correct usages of loop constructs:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: fort_do.1
! type: F-fixed
      SUBROUTINE WORK(I, J)
      INTEGER I,J
      END SUBROUTINE WORK

      SUBROUTINE DO_GOOD()
        INTEGER I, J
        REAL A(1000)

        DO 100 I = 1,10
!$OMP     DO
          DO 100 J = 1,10
            CALL WORK(I,J)
100     CONTINUE      !  !$OMP ENDDO implied here

!$OMP   DO
        DO 200 J = 1,10
200       A(I) = I + 1
!$OMP   ENDDO

!$OMP   DO
        DO 300 I = 1,10
          DO 300 J = 1,10
            CALL WORK(I,J)
300     CONTINUE
!$OMP   ENDDO
      END SUBROUTINE DO_GOOD

</pre></div>
</div>
</div>
</div>
<p>The following example is non-conforming because the matching <code class="docutils literal notranslate"><span class="pre">do</span></code> directive  for the <code class="docutils literal notranslate"><span class="pre">end</span> <span class="pre">do</span></code> does not precede the outermost loop:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: fort_do.2
! type: F-fixed
      SUBROUTINE WORK(I, J)
      INTEGER I,J
      END SUBROUTINE WORK

      SUBROUTINE DO_WRONG
        INTEGER I, J

        DO 100 I = 1,10
!$OMP     DO
          DO 100 J = 1,10
            CALL WORK(I,J)
100     CONTINUE
!$OMP   ENDDO
      END SUBROUTINE DO_WRONG

</pre></div>
</div>
</div>
</div>
<p>../../parallel_execution/fort_do.tex</p>
</div>
<div class="section" id="nowait-clause">
<h2><code class="docutils literal notranslate"><span class="pre">nowait</span></code> Clause<a class="headerlink" href="#nowait-clause" title="Permalink to this headline">¶</a></h2>
<p><strong>clauses!nowait <code class="docutils literal notranslate"><span class="pre">nowait</span></code></strong> <strong>nowait clause <code class="docutils literal notranslate"><span class="pre">nowait</span></code> clause</strong></p>
<p>If there are multiple independent loops within a <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region, you  can use the <code class="docutils literal notranslate"><span class="pre">nowait</span></code> clause to avoid the implied barrier at the end of the  loop construct, as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: nowait.1
* type: C
*/
#include &lt;math.h&gt;

void nowait_example(int n, int m, float *a, float *b, float *y, float *z)
{
  int i;
  #pragma omp parallel
  {
    #pragma omp for nowait
      for (i=1; i&lt;n; i++)
        b[i] = (a[i] + a[i-1]) / 2.0;

    #pragma omp for nowait
      for (i=0; i&lt;m; i++)
        y[i] = sqrt(z[i]);
  }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: nowait.1
! type: F-fixed
        SUBROUTINE NOWAIT_EXAMPLE(N, M, A, B, Y, Z)

        INTEGER N, M
        REAL A(*), B(*), Y(*), Z(*)

        INTEGER I

!$OMP PARALLEL

!$OMP DO
        DO I=2,N
          B(I) = (A(I) + A(I-1)) / 2.0
        ENDDO
!$OMP END DO NOWAIT

!$OMP DO
        DO I=1,M
          Y(I) = SQRT(Z(I))
        ENDDO
!$OMP END DO NOWAIT

!$OMP END PARALLEL

        END SUBROUTINE NOWAIT_EXAMPLE

</pre></div>
</div>
</div>
</div>
<p><strong>loop scheduling!static</strong> <strong>static scheduling</strong> In the following example, static scheduling distributes the same logical iteration  numbers to the threads that execute the three loop regions. This allows the <code class="docutils literal notranslate"><span class="pre">nowait</span></code>  clause to be used, even though there is a data dependence between the loops. The  dependence is satisfied as long the same thread executes the same logical iteration  numbers in each loop.</p>
<p>Note that the iteration count of the loops must be the same. The example satisfies  this requirement, since the iteration space of the first two loops is from <code class="docutils literal notranslate"><span class="pre">0</span></code>  to <code class="docutils literal notranslate"><span class="pre">n-1</span></code> (from <code class="docutils literal notranslate"><span class="pre">1</span></code> to <code class="docutils literal notranslate"><span class="pre">N</span></code> in the Fortran version), while the  iteration space of the last loop is from <code class="docutils literal notranslate"><span class="pre">1</span></code> to <code class="docutils literal notranslate"><span class="pre">n</span></code> (<code class="docutils literal notranslate"><span class="pre">2</span></code> to  <code class="docutils literal notranslate"><span class="pre">N+1</span></code> in the Fortran version).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: nowait.2
* type: C
*/

#include &lt;math.h&gt;
void nowait_example2(int n, float *a, float *b, float *c, float *y, float
*z)
{
   int i;
#pragma omp parallel
   {
#pragma omp for schedule(static) nowait
   for (i=0; i&lt;n; i++)
      c[i] = (a[i] + b[i]) / 2.0f;
#pragma omp for schedule(static) nowait
   for (i=0; i&lt;n; i++)
      z[i] = sqrtf(c[i]);
#pragma omp for schedule(static) nowait
   for (i=1; i&lt;=n; i++)
      y[i] = z[i-1] + a[i];
   }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: nowait.2
! type: F-free
   SUBROUTINE NOWAIT_EXAMPLE2(N, A, B, C, Y, Z)
   INTEGER N
   REAL A(*), B(*), C(*), Y(*), Z(*)
   INTEGER I
!$OMP PARALLEL
!$OMP DO SCHEDULE(STATIC)
   DO I=1,N
      C(I) = (A(I) + B(I)) / 2.0
   ENDDO
!$OMP END DO NOWAIT
!$OMP DO SCHEDULE(STATIC)
   DO I=1,N
      Z(I) = SQRT(C(I))
   ENDDO
!$OMP END DO NOWAIT
!$OMP DO SCHEDULE(STATIC)
   DO I=2,N+1
      Y(I) = Z(I-1) + A(I)
   ENDDO
!$OMP END DO NOWAIT
!$OMP END PARALLEL
   END SUBROUTINE NOWAIT_EXAMPLE2

</pre></div>
</div>
</div>
</div>
<p>../../parallel_execution/nowait.tex</p>
</div>
<div class="section" id="collapse-clause">
<h2><code class="docutils literal notranslate"><span class="pre">collapse</span></code> Clause<a class="headerlink" href="#collapse-clause" title="Permalink to this headline">¶</a></h2>
<p><strong>clauses!collapse <code class="docutils literal notranslate"><span class="pre">collapse</span></code></strong> <strong>collapse clause <code class="docutils literal notranslate"><span class="pre">collapse</span></code> clause</strong></p>
<p>In the following example, the <code class="docutils literal notranslate"><span class="pre">k</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code> loops are associated with  the loop construct. So the iterations of the <code class="docutils literal notranslate"><span class="pre">k</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code> loops are  collapsed into one loop with a larger iteration space, and that loop is then divided  among the threads in the current team. Since the <code class="docutils literal notranslate"><span class="pre">i</span></code> loop is not associated  with the loop construct, it is not collapsed, and the <code class="docutils literal notranslate"><span class="pre">i</span></code> loop is executed  sequentially in its entirety in every iteration of the collapsed <code class="docutils literal notranslate"><span class="pre">k</span></code> and  <code class="docutils literal notranslate"><span class="pre">j</span></code> loop.</p>
<p>The variable <code class="docutils literal notranslate"><span class="pre">j</span></code> can be omitted from the <code class="docutils literal notranslate"><span class="pre">private</span></code>  clause when the  <code class="docutils literal notranslate"><span class="pre">collapse</span></code> clause is used since it is implicitly private. However, if the  <code class="docutils literal notranslate"><span class="pre">collapse</span></code> clause is omitted then <code class="docutils literal notranslate"><span class="pre">j</span></code> will be shared if it is omitted  from the <code class="docutils literal notranslate"><span class="pre">private</span></code> clause. In either case, <code class="docutils literal notranslate"><span class="pre">k</span></code> is implicitly private  and could be omitted from the <code class="docutils literal notranslate"><span class="pre">private</span></code>  clause.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: collapse.1
* type: C
* version: omp_3.0
*/

void bar(float *a, int i, int j, int k);

int kl, ku, ks, jl, ju, js, il, iu,is;

void sub(float *a)
{
    int i, j, k;

    #pragma omp for collapse(2) private(i, k, j)
    for (k=kl; k&lt;=ku; k+=ks)
       for (j=jl; j&lt;=ju; j+=js)
          for (i=il; i&lt;=iu; i+=is)
             bar(a,i,j,k);
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: collapse.1
! type: F-fixed
! version: omp_3.0

      subroutine sub(a)

      real a(*)
      integer kl, ku, ks, jl, ju, js, il, iu, is
      common /csub/ kl, ku, ks, jl, ju, js, il, iu, is
      integer i, j, k

!$omp do collapse(2) private(i,j,k)
       do k = kl, ku, ks
         do j = jl, ju, js
           do i = il, iu, is
             call bar(a,i,j,k)
          enddo
        enddo
      enddo
!$omp end do

      end subroutine

</pre></div>
</div>
</div>
</div>
<p>In the next example, the <code class="docutils literal notranslate"><span class="pre">k</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code> loops are associated with the  loop construct. So the iterations of the <code class="docutils literal notranslate"><span class="pre">k</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code> loops are collapsed  into one loop with a larger iteration space, and that loop is then divided among  the threads in the current team.</p>
<p>The sequential execution of the iterations in the <code class="docutils literal notranslate"><span class="pre">k</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code> loops  determines the order of the iterations in the collapsed iteration space. This implies  that in the sequentially last iteration of the collapsed iteration space, <code class="docutils literal notranslate"><span class="pre">k</span></code>  will have the value <code class="docutils literal notranslate"><span class="pre">2</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code> will have the value <code class="docutils literal notranslate"><span class="pre">3</span></code>. Since  <code class="docutils literal notranslate"><span class="pre">klast</span></code> and <code class="docutils literal notranslate"><span class="pre">jlast</span></code> are <code class="docutils literal notranslate"><span class="pre">lastprivate</span></code>, their values are assigned  by the sequentially last iteration of the collapsed <code class="docutils literal notranslate"><span class="pre">k</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code> loop.  This example prints: <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">3</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: collapse.2
* type: C
* version: omp_3.0
*/

#include &lt;stdio.h&gt;
void test()
{
   int j, k, jlast, klast;
   #pragma omp parallel
   {
      #pragma omp for collapse(2) lastprivate(jlast, klast)
      for (k=1; k&lt;=2; k++)
         for (j=1; j&lt;=3; j++)
         {
            jlast=j;
            klast=k;
         }
      #pragma omp single
      printf(&quot;%d %d\n&quot;, klast, jlast);
   }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: collapse.2
! type: F-fixed
! version: omp_3.0

      program test
!$omp parallel
!$omp do private(j,k) collapse(2) lastprivate(jlast, klast)
      do k = 1,2
        do j = 1,3
          jlast=j
          klast=k
        enddo
      enddo
!$omp end do
!$omp single
      print *, klast, jlast
!$omp end single
!$omp end parallel
      end program test

</pre></div>
</div>
</div>
</div>
<p><strong>clauses!collapse <code class="docutils literal notranslate"><span class="pre">collapse</span></code></strong> <strong>collapse clause <code class="docutils literal notranslate"><span class="pre">collapse</span></code> clause</strong> <strong>clauses!ordered <code class="docutils literal notranslate"><span class="pre">ordered</span></code></strong> <strong>ordered clause <code class="docutils literal notranslate"><span class="pre">ordered</span></code> clause</strong> The next example illustrates the interaction of the <code class="docutils literal notranslate"><span class="pre">collapse</span></code> and <code class="docutils literal notranslate"><span class="pre">ordered</span></code>   clauses.</p>
<p>In the example, the loop construct has both a <code class="docutils literal notranslate"><span class="pre">collapse</span></code> clause and an <code class="docutils literal notranslate"><span class="pre">ordered</span></code>  clause. The <code class="docutils literal notranslate"><span class="pre">collapse</span></code> clause causes the iterations of the <code class="docutils literal notranslate"><span class="pre">k</span></code> and  <code class="docutils literal notranslate"><span class="pre">j</span></code> loops to be collapsed into one loop with a larger iteration space, and  that loop is divided among the threads in the current team. An <code class="docutils literal notranslate"><span class="pre">ordered</span></code>  clause is added to the loop construct because an ordered region binds to the loop  region arising from the loop construct.</p>
<p>According to Section 2.12.8 of the OpenMP 4.0 specification,  a thread must not execute more than one ordered region that binds  to the same loop region. So the <code class="docutils literal notranslate"><span class="pre">collapse</span></code> clause is required for the example  to be conforming. With the <code class="docutils literal notranslate"><span class="pre">collapse</span></code> clause, the iterations of the <code class="docutils literal notranslate"><span class="pre">k</span></code>  and <code class="docutils literal notranslate"><span class="pre">j</span></code> loops are collapsed into one loop, and therefore only one ordered  region will bind to the collapsed <code class="docutils literal notranslate"><span class="pre">k</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code> loop. Without the <code class="docutils literal notranslate"><span class="pre">collapse</span></code>  clause, there would be two ordered regions that bind to each iteration of the <code class="docutils literal notranslate"><span class="pre">k</span></code>  loop (one arising from the first iteration of the <code class="docutils literal notranslate"><span class="pre">j</span></code> loop, and the other  arising from the second iteration of the <code class="docutils literal notranslate"><span class="pre">j</span></code> loop).</p>
<p>The code prints</p>
<p><code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">1</span> <span class="pre">1</span></code>  <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">1</span> <span class="pre">2</span></code>  <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">2</span> <span class="pre">1</span></code>  <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">2</span> <span class="pre">2</span></code>  <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">3</span> <span class="pre">1</span></code>  <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">3</span> <span class="pre">2</span></code></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: collapse.3
* type: C
* version: omp_3.0
*/
#include &lt;omp.h&gt;
#include &lt;stdio.h&gt;
void work(int a, int j, int k);
void sub()
{
   int j, k, a;
   #pragma omp parallel num_threads(2)
   {
      #pragma omp for collapse(2) ordered private(j,k) schedule(static,3)
      for (k=1; k&lt;=3; k++)
         for (j=1; j&lt;=2; j++)
         {
            #pragma omp ordered
            printf(&quot;%d %d %d\n&quot;, omp_get_thread_num(), k, j);
            /* end ordered */
            work(a,j,k);
         }
   }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: collapse.3
! type: F-fixed
! version: omp_3.0
      program test
      include &#39;omp_lib.h&#39;
!$omp parallel num_threads(2)
!$omp do collapse(2) ordered private(j,k) schedule(static,3)
      do k = 1,3
        do j = 1,2
!$omp ordered
          print *, omp_get_thread_num(), k, j
!$omp end ordered
          call work(a,j,k)
        enddo
      enddo
!$omp end do
!$omp end parallel
      end program test

</pre></div>
</div>
</div>
</div>
<p><strong>non-rectangular loop nest</strong> The following example illustrates the collapse of a non-rectangular loop nest, a new feature in OpenMP 5.0. In a loop nest, a non-rectangular loop has a loop bound that references the iteration variable of an enclosing loop.</p>
<p>The motivation for this feature is illustrated in the example below that creates a symmetric correlation matrix for a set of variables. Note that the initial value of the second loop depends on the index variable of the first loop for the loops to be collapsed. Here the data are represented by a 2D array, each row corresponds to a variable and each column corresponds to a sample of the variable – the last two columns are the sample mean and standard deviation (for Fortran, rows and columns are swapped).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: collapse.4
* type: C
* version: omp_5.0
*/
#include &lt;stdio.h&gt;
#define N 20
#define M 10

// routine to calculate a
// For variable a[i]:
// a[i][0],...,a[i][n-1]   contains the n samples
// a[i][n]                 contains the sample mean
// a[i][n+1]               contains the standard deviation
extern void calc_a(int n,int m, float a[][N+2]);

int main(){
  float a[M][N+2], b[M][M];

  calc_a(N,M,a);

  #pragma omp parallel for collapse(2)
  for (int i = 0; i &lt; M; i++)
     for (int j = i; j &lt; M; j++)
     {
        float temp = 0.0f;
        for (int k = 0; k &lt; N; k++)
           temp += (a[i][k]-a[i][N])*(a[j][k]-a[j][N]);

        b[i][j] = temp / (a[i][N+1] * a[j][N+1] * (N - 1));
        b[j][i] = b[i][j];
     }

  printf(&quot;b[0][0] = %f, b[M-1][M-1] = %f\n&quot;, b[0][0], b[M-1][M-1]);

  return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: collapse.4
! type: F-free
! version: omp_5.0
module calc_m
  interface
  subroutine calc_a(n, m, a)
  integer n, m
  real a(n+2,m)
  ! routine to calculate a
  ! For variable a(*,j):
  ! a(1,j),...,a(n,j)  contains the n samples
  ! a(n+1,j)           contains the sample mean
  ! a(n+2,j)           contains the standard deviation
  end subroutine
  end interface
end module

program main
  use calc_m
  integer, parameter :: N=20, M=10
  real a(N+2,M), b(M,M)
  real temp
  integer i, j, k

  call calc_a(N,M,a)

  !$omp parallel do collapse(2) private(k,temp)
  do i = 1, M
     do j = i, M
        temp = 0.0
        do k = 1, N
           temp = temp + (a(k,i)-a(N+1,i))*(a(k,j)-a(N+1,j))
        end do

        b(i,j) = temp / (a(N+2,i) * a(N+2,j) * (N - 1))
        b(j,i) = b(i,j)
     end do
  end do

  print *,&quot;b(1,1) = &quot;,b(1,1),&quot;, b(M,M) = &quot;,b(M,M)

end program

</pre></div>
</div>
</div>
</div>
<p>../../parallel_execution/collapse.tex</p>
</div>
<div class="section" id="linear-clause-in-loop-constructs">
<h2><code class="docutils literal notranslate"><span class="pre">linear</span></code> Clause in Loop Constructs<a class="headerlink" href="#linear-clause-in-loop-constructs" title="Permalink to this headline">¶</a></h2>
<p><strong>clauses!linear <code class="docutils literal notranslate"><span class="pre">linear</span></code></strong> <strong>linear clause <code class="docutils literal notranslate"><span class="pre">linear</span></code> clause</strong></p>
<p>The following example shows the use of the <code class="docutils literal notranslate"><span class="pre">linear</span></code> clause in a loop  construct to allow the proper parallelization of a loop that contains  an induction variable ( <em>j</em> ).  At the end of the execution of  the loop construct, the original variable  <em>j</em>  is updated with  the value  <em>N/2</em>  from the last iteration of the loop.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: linear_in_loop.1
* type: C
* version: omp_4.5
*/
#include &lt;stdio.h&gt;

#define N 100
int main(void)
{
   float a[N], b[N/2];
   int i, j;

   for ( i = 0; i &lt; N; i++ )
      a[i] = i + 1;

   j = 0;
   #pragma omp parallel
   #pragma omp for linear(j:1)
   for ( i = 0; i &lt; N; i += 2 ) {
      b[j] = a[i] * 2.0f;
      j++;
   }

   printf( &quot;%d %f %f\n&quot;, j, b[0], b[j-1] );
   /* print out: 50 2.0 198.0 */

   return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: linear_in_loop.1
! type: F-free
! version:    omp_4.5
program linear_loop
   implicit none
   integer, parameter :: N = 100
   real :: a(N), b(N/2)
   integer :: i, j

   do i = 1, N
      a(i) = i
   end do

   j = 0
   !$omp parallel
   !$omp do linear(j:1)
   do i = 1, N, 2
      j = j + 1
      b(j) = a(i) * 2.0
   end do
   !$omp end parallel

   print *, j, b(1), b(j)
   ! print out: 50 2.0 198.0

end program

</pre></div>
</div>
</div>
</div>
<p>../../parallel_execution/linear_in_loop.tex</p>
</div>
<div class="section" id="parallel-sections-construct">
<h2><code class="docutils literal notranslate"><span class="pre">parallel</span></code> <code class="docutils literal notranslate"><span class="pre">sections</span></code> Construct<a class="headerlink" href="#parallel-sections-construct" title="Permalink to this headline">¶</a></h2>
<p><strong>combined constructs!parallel sections <code class="docutils literal notranslate"><span class="pre">parallel</span></code> <code class="docutils literal notranslate"><span class="pre">sections</span></code></strong> <strong>parallel sections construct <code class="docutils literal notranslate"><span class="pre">parallel</span></code> <code class="docutils literal notranslate"><span class="pre">sections</span></code> construct</strong></p>
<p>In the following example routines <code class="docutils literal notranslate"><span class="pre">XAXIS</span></code>, <code class="docutils literal notranslate"><span class="pre">YAXIS</span></code>, and <code class="docutils literal notranslate"><span class="pre">ZAXIS</span></code> can  be executed concurrently. The first <code class="docutils literal notranslate"><span class="pre">section</span></code> directive is optional. Note  that all <code class="docutils literal notranslate"><span class="pre">section</span></code> directives need to appear in the  <code class="docutils literal notranslate"><span class="pre">parallel</span></code> <code class="docutils literal notranslate"><span class="pre">sections</span></code> construct.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: psections.1
* type: C
*/
void XAXIS();
void YAXIS();
void ZAXIS();

void sect_example()
{
  #pragma omp parallel sections
  {
    #pragma omp section
      XAXIS();

    #pragma omp section
      YAXIS();

    #pragma omp section
      ZAXIS();
  }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: psections.1
! type: F-fixed
      SUBROUTINE SECT_EXAMPLE()
!$OMP PARALLEL SECTIONS
!$OMP SECTION
        CALL XAXIS()
!$OMP SECTION
        CALL YAXIS()

!$OMP SECTION
        CALL ZAXIS()

!$OMP END PARALLEL SECTIONS
      END SUBROUTINE SECT_EXAMPLE

</pre></div>
</div>
</div>
</div>
<p>../../parallel_execution/psections.tex</p>
</div>
<div class="section" id="firstprivate-clause-and-sections-construct">
<h2><code class="docutils literal notranslate"><span class="pre">firstprivate</span></code> Clause and <code class="docutils literal notranslate"><span class="pre">sections</span></code> Construct<a class="headerlink" href="#firstprivate-clause-and-sections-construct" title="Permalink to this headline">¶</a></h2>
<p><strong>constructs!sections <code class="docutils literal notranslate"><span class="pre">sections</span></code></strong> <strong>sections construct <code class="docutils literal notranslate"><span class="pre">sections</span></code> construct</strong> <strong>constructs!section <code class="docutils literal notranslate"><span class="pre">section</span></code></strong> <strong>section construct <code class="docutils literal notranslate"><span class="pre">section</span></code> construct</strong> <strong>clauses!firstprivate <code class="docutils literal notranslate"><span class="pre">firstprivate</span></code></strong> <strong>firstprivate clause <code class="docutils literal notranslate"><span class="pre">firstprivate</span></code> clause</strong></p>
<p>In the following example of the <code class="docutils literal notranslate"><span class="pre">sections</span></code> construct  the <code class="docutils literal notranslate"><span class="pre">firstprivate</span></code>  clause is used to initialize the private copy of <code class="docutils literal notranslate"><span class="pre">section_count</span></code> of each  thread. The problem is that the <code class="docutils literal notranslate"><span class="pre">section</span></code> constructs modify <code class="docutils literal notranslate"><span class="pre">section_count</span></code>,  which breaks the independence of the <code class="docutils literal notranslate"><span class="pre">section</span></code> constructs. When different  threads execute each section, both sections will print the value 1. When the same  thread executes the two sections, one section will print the value 1 and the other  will print the value 2. Since the order of execution of the two sections in this  case is unspecified, it is unspecified which section prints which value.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: fpriv_sections.1
* type: C
*/
#include &lt;omp.h&gt;
#include &lt;stdio.h&gt;
#define NT 4
int main( ) {
    int section_count = 0;
    omp_set_dynamic(0);
    omp_set_num_threads(NT);
#pragma omp parallel
#pragma omp sections firstprivate( section_count )
{
#pragma omp section
    {
        section_count++;
        /* may print the number one or two */
        printf( &quot;section_count %d\n&quot;, section_count );
    }
#pragma omp section
    {
        section_count++;
        /* may print the number one or two */
        printf( &quot;section_count %d\n&quot;, section_count );
    }
}
    return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: fpriv_sections.1
! type: F-free
program section
    use omp_lib
    integer :: section_count = 0
    integer, parameter :: NT = 4
    call omp_set_dynamic(.false.)
    call omp_set_num_threads(NT)
!$omp parallel
!$omp sections firstprivate ( section_count )
!$omp section
    section_count = section_count + 1
! may print the number one or two
    print *, &#39;section_count&#39;, section_count
!$omp section
    section_count = section_count + 1
! may print the number one or two
    print *, &#39;section_count&#39;, section_count
!$omp end sections
!$omp end parallel
end program section

</pre></div>
</div>
</div>
</div>
<p>../../parallel_execution/fpriv_sections.tex</p>
</div>
<div class="section" id="single-construct">
<h2><code class="docutils literal notranslate"><span class="pre">single</span></code> Construct<a class="headerlink" href="#single-construct" title="Permalink to this headline">¶</a></h2>
<p><strong>constructs!single <code class="docutils literal notranslate"><span class="pre">single</span></code></strong> <strong>single construct <code class="docutils literal notranslate"><span class="pre">single</span></code> construct</strong></p>
<p>The following example demonstrates the <code class="docutils literal notranslate"><span class="pre">single</span></code> construct. In the example,  only one thread prints each of the progress messages. All other threads will skip  the <code class="docutils literal notranslate"><span class="pre">single</span></code> region and stop at the barrier at the end of the <code class="docutils literal notranslate"><span class="pre">single</span></code>  construct until all threads in the team have reached the barrier. If other threads  can proceed without waiting for the thread executing the <code class="docutils literal notranslate"><span class="pre">single</span></code> region,  a <code class="docutils literal notranslate"><span class="pre">nowait</span></code> clause can be specified, as is done in the third <code class="docutils literal notranslate"><span class="pre">single</span></code>  construct in this example. The user must not make any assumptions as to which thread  will execute a <code class="docutils literal notranslate"><span class="pre">single</span></code> region.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: single.1
* type: C
*/
#include &lt;stdio.h&gt;

void work1() {}
void work2() {}

void single_example()
{
  #pragma omp parallel
  {
    #pragma omp single
      printf(&quot;Beginning work1.\n&quot;);

    work1();

    #pragma omp single
      printf(&quot;Finishing work1.\n&quot;);

    #pragma omp single nowait
      printf(&quot;Finished work1 and beginning work2.\n&quot;);

    work2();
  }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: single.1
! type: F-fixed
      SUBROUTINE WORK1()
      END SUBROUTINE WORK1

      SUBROUTINE WORK2()
      END SUBROUTINE WORK2

      PROGRAM SINGLE_EXAMPLE
!$OMP PARALLEL

!$OMP SINGLE
        print *, &quot;Beginning work1.&quot;
!$OMP END SINGLE

        CALL WORK1()

!$OMP SINGLE
        print *, &quot;Finishing work1.&quot;
!$OMP END SINGLE

!$OMP SINGLE
        print *, &quot;Finished work1 and beginning work2.&quot;
!$OMP END SINGLE NOWAIT

        CALL WORK2()

!$OMP END PARALLEL

      END PROGRAM SINGLE_EXAMPLE

</pre></div>
</div>
</div>
</div>
<p>../../parallel_execution/single.tex</p>
</div>
<div class="section" id="workshare-construct">
<h2><code class="docutils literal notranslate"><span class="pre">workshare</span></code> Construct<a class="headerlink" href="#workshare-construct" title="Permalink to this headline">¶</a></h2>
<p><strong>constructs!workshare <code class="docutils literal notranslate"><span class="pre">workshare</span></code></strong> <strong>workshare construct <code class="docutils literal notranslate"><span class="pre">workshare</span></code> construct</strong></p>
<p>The following are examples of the <code class="docutils literal notranslate"><span class="pre">workshare</span></code> construct.</p>
<p>In the following example, <code class="docutils literal notranslate"><span class="pre">workshare</span></code> spreads work across the threads executing  the <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region, and there is a barrier after the last statement.  Implementations must enforce Fortran execution rules inside of the <code class="docutils literal notranslate"><span class="pre">workshare</span></code>  block.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: workshare.1
! type: F-fixed
      SUBROUTINE WSHARE1(AA, BB, CC, DD, EE, FF, N)
      INTEGER N
      REAL AA(N,N), BB(N,N), CC(N,N), DD(N,N), EE(N,N), FF(N,N)

!$OMP    PARALLEL
!$OMP     WORKSHARE
            AA = BB
            CC = DD
            EE = FF
!$OMP     END WORKSHARE
!$OMP   END PARALLEL

      END SUBROUTINE WSHARE1

</pre></div>
</div>
</div>
</div>
<p>In the following example, the barrier at the end of the first <code class="docutils literal notranslate"><span class="pre">workshare</span></code>  region is eliminated with a <code class="docutils literal notranslate"><span class="pre">nowait</span></code> clause. Threads doing <code class="docutils literal notranslate"><span class="pre">CC</span> <span class="pre">=</span>&#160; <span class="pre">DD</span></code> immediately begin work on <code class="docutils literal notranslate"><span class="pre">EE</span> <span class="pre">=</span> <span class="pre">FF</span></code> when they are done with <code class="docutils literal notranslate"><span class="pre">CC</span>&#160; <span class="pre">=</span> <span class="pre">DD</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: workshare.2
! type: F-fixed
      SUBROUTINE WSHARE2(AA, BB, CC, DD, EE, FF, N)
      INTEGER N
      REAL AA(N,N), BB(N,N), CC(N,N)
      REAL DD(N,N), EE(N,N), FF(N,N)

!$OMP   PARALLEL
!$OMP     WORKSHARE
            AA = BB
            CC = DD
!$OMP     END WORKSHARE NOWAIT
!$OMP     WORKSHARE
            EE = FF
!$OMP     END WORKSHARE
!$OMP   END PARALLEL
       END SUBROUTINE WSHARE2

</pre></div>
</div>
</div>
</div>
<p>The following example shows the use of an <code class="docutils literal notranslate"><span class="pre">atomic</span></code> directive inside a <code class="docutils literal notranslate"><span class="pre">workshare</span></code>  construct. The computation of <code class="docutils literal notranslate"><span class="pre">SUM(AA)</span></code> is workshared, but the update to  <code class="docutils literal notranslate"><span class="pre">R</span></code> is atomic.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: workshare.3
! type: F-fixed
      SUBROUTINE WSHARE3(AA, BB, CC, DD, N)
      INTEGER N
      REAL AA(N,N), BB(N,N), CC(N,N), DD(N,N)
      REAL R
        R=0
!$OMP   PARALLEL
!$OMP     WORKSHARE
            AA = BB
!$OMP       ATOMIC UPDATE
              R = R + SUM(AA)
            CC = DD
!$OMP     END WORKSHARE
!$OMP   END PARALLEL
      END SUBROUTINE WSHARE3

</pre></div>
</div>
</div>
</div>
<p>Fortran <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> and <code class="docutils literal notranslate"><span class="pre">FORALL</span></code> statements are <strong>compound statements</strong>,  made up of a <strong>control</strong> part and a <strong>statement</strong> part. When <code class="docutils literal notranslate"><span class="pre">workshare</span></code>  is applied to one of these compound statements, both the control and the statement  parts are workshared. The following example shows the use of a <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> statement  in a <code class="docutils literal notranslate"><span class="pre">workshare</span></code> construct.</p>
<p>Each task gets worked on in order by the threads:</p>
<p><code class="docutils literal notranslate"><span class="pre">AA</span> <span class="pre">=</span> <span class="pre">BB</span></code> then  <code class="docutils literal notranslate"><span class="pre">CC</span> <span class="pre">=</span> <span class="pre">DD</span></code> then  <code class="docutils literal notranslate"><span class="pre">EE</span> <span class="pre">.ne.</span> <span class="pre">0</span></code> then  <code class="docutils literal notranslate"><span class="pre">FF</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">/</span> <span class="pre">EE</span></code> then  <code class="docutils literal notranslate"><span class="pre">GG</span> <span class="pre">=</span> <span class="pre">HH</span></code></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: workshare.4
! type: F-fixed
      SUBROUTINE WSHARE4(AA, BB, CC, DD, EE, FF, GG, HH, N)
      INTEGER N
      REAL AA(N,N), BB(N,N), CC(N,N)
      REAL DD(N,N), EE(N,N), FF(N,N)
      REAL GG(N,N), HH(N,N)

!$OMP   PARALLEL
!$OMP     WORKSHARE
            AA = BB
            CC = DD
            WHERE (EE .ne. 0) FF = 1 / EE
            GG = HH
!$OMP     END WORKSHARE
!$OMP   END PARALLEL

      END SUBROUTINE WSHARE4

</pre></div>
</div>
</div>
</div>
<p>In the following example, an assignment to a shared scalar variable is performed  by one thread in a <code class="docutils literal notranslate"><span class="pre">workshare</span></code> while all other threads in the team wait.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: workshare.5
! type: F-fixed
      SUBROUTINE WSHARE5(AA, BB, CC, DD, N)
      INTEGER N
      REAL AA(N,N), BB(N,N), CC(N,N), DD(N,N)

        INTEGER SHR

!$OMP   PARALLEL SHARED(SHR)
!$OMP     WORKSHARE
            AA = BB
            SHR = 1
            CC = DD * SHR
!$OMP     END WORKSHARE
!$OMP   END PARALLEL

      END SUBROUTINE WSHARE5

</pre></div>
</div>
</div>
</div>
<p>The following example contains an assignment to a private scalar variable, which  is performed by one thread in a <code class="docutils literal notranslate"><span class="pre">workshare</span></code> while all other threads wait.  It is non-conforming because the private scalar variable is undefined after the  assignment statement.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: workshare.6
! type: F-fixed
      SUBROUTINE WSHARE6_WRONG(AA, BB, CC, DD, N)
      INTEGER N
      REAL AA(N,N), BB(N,N), CC(N,N), DD(N,N)

        INTEGER PRI

!$OMP   PARALLEL PRIVATE(PRI)
!$OMP     WORKSHARE
            AA = BB
            PRI = 1
            CC = DD * PRI
!$OMP     END WORKSHARE
!$OMP   END PARALLEL

      END SUBROUTINE WSHARE6_WRONG

</pre></div>
</div>
</div>
</div>
<p>Fortran execution rules must be enforced inside a <code class="docutils literal notranslate"><span class="pre">workshare</span></code> construct.  In the following example, the same result is produced in the following program  fragment regardless of whether the code is executed sequentially or inside an OpenMP  program with multiple threads:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: workshare.7
! type: F-fixed
      SUBROUTINE WSHARE7(AA, BB, CC, N)
      INTEGER N
      REAL AA(N), BB(N), CC(N)

!$OMP   PARALLEL
!$OMP     WORKSHARE
            AA(1:50)  = BB(11:60)
            CC(11:20) = AA(1:10)
!$OMP     END WORKSHARE
!$OMP   END PARALLEL

      END SUBROUTINE WSHARE7

</pre></div>
</div>
</div>
</div>
<p>../../parallel_execution/workshare.tex</p>
</div>
<div class="section" id="masked-construct">
<h2><code class="docutils literal notranslate"><span class="pre">masked</span></code> Construct<a class="headerlink" href="#masked-construct" title="Permalink to this headline">¶</a></h2>
<p><strong>constructs!masked <code class="docutils literal notranslate"><span class="pre">masked</span></code></strong> <strong>masked construct <code class="docutils literal notranslate"><span class="pre">masked</span></code> construct</strong> <strong>masked construct <code class="docutils literal notranslate"><span class="pre">masked</span></code> construct!filter clause <code class="docutils literal notranslate"><span class="pre">filter</span></code> clause</strong> <strong>clauses!filter <code class="docutils literal notranslate"><span class="pre">filter</span></code></strong> <strong>filter clause <code class="docutils literal notranslate"><span class="pre">filter</span></code> clause</strong></p>
<p>The following example demonstrates the <code class="docutils literal notranslate"><span class="pre">masked</span></code> construct.  In the example, the primary thread (thread number 0)  keeps track of how many iterations have been executed and prints out  a progress report in the iteration loop. The other threads skip the <code class="docutils literal notranslate"><span class="pre">masked</span></code> region without waiting.  The <code class="docutils literal notranslate"><span class="pre">filter</span></code> clause can be used to specify a thread number other  than the primary thread to execute a structured block, as illustrated by the second <code class="docutils literal notranslate"><span class="pre">masked</span></code> construct after the iteration loop. If the thread specified in a <code class="docutils literal notranslate"><span class="pre">filter</span></code> clause does not exist  in the team then the structured block is not executed by any thread.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: masked.1
* type: C
* version:    omp_5.1
*/
#include &lt;stdio.h&gt;

extern float average(float,float,float);

void masked_example( float* x, float* xold, int n, float tol )
{
  int c, i, toobig;
  float error, y;
  c = 0;
  #pragma omp parallel
  {
    do {
      #pragma omp for private(i)
      for( i = 1; i &lt; n-1; ++i ){
        xold[i] = x[i];
      }
      #pragma omp single
      {
        toobig = 0;
      }
      #pragma omp for private(i,y,error) reduction(+:toobig)
      for( i = 1; i &lt; n-1; ++i ){
        y = x[i];
        x[i] = average( xold[i-1], x[i], xold[i+1] );
        error = y - x[i];
        if( error &gt; tol || error &lt; -tol ) ++toobig;
      }
      #pragma omp masked          // primary thread (thread 0)
      {
        ++c;
        printf( &quot;iteration %d, toobig=%d\n&quot;, c, toobig );
      }
    } while( toobig &gt; 0 );
    #pragma omp barrier
    #pragma omp masked filter(1)  // thread 1
    {
      // The printf statement will not be executed
      // if the number of threads is less than 2.
      printf( &quot;total number of iterations = %d\n&quot;, c );
    }
  }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: masked.1
! type: F-fixed
! version:    omp_5.1
      SUBROUTINE MASKED_EXAMPLE( X, XOLD, N, TOL )
      REAL X(*), XOLD(*), TOL
      INTEGER N
      INTEGER C, I, TOOBIG
      REAL ERROR, Y, AVERAGE
      EXTERNAL AVERAGE
      C = 0
      TOOBIG = 1
!$OMP PARALLEL
        DO WHILE( TOOBIG &gt; 0 )
!$OMP     DO PRIVATE(I)
            DO I = 2, N-1
              XOLD(I) = X(I)
            ENDDO
!$OMP     SINGLE
            TOOBIG = 0
!$OMP     END SINGLE
!$OMP     DO PRIVATE(I,Y,ERROR), REDUCTION(+:TOOBIG)
            DO I = 2, N-1
              Y = X(I)
              X(I) = AVERAGE( XOLD(I-1), X(I), XOLD(I+1) )
              ERROR = Y-X(I)
              IF( ERROR &gt; TOL .OR. ERROR &lt; -TOL ) TOOBIG = TOOBIG+1
            ENDDO
!$OMP     MASKED            ! primary thread (thread 0)
            C = C + 1
            PRINT *, &#39;Iteration &#39;, C, &#39;TOOBIG=&#39;, TOOBIG
!$OMP     END MASKED
        ENDDO
!$OMP   BARRIER
!$OMP   MASKED FILTER(1)    ! thread 1
          ! The print statement will not be executed
          ! if the number of threads is less than 2.
          PRINT *, &#39;Total number of iterations =&#39;, C
!$OMP   END MASKED
!$OMP END PARALLEL
      END SUBROUTINE MASKED_EXAMPLE

</pre></div>
</div>
</div>
</div>
<p>../../parallel_execution/masked.tex</p>
</div>
<div class="section" id="loop-construct">
<h2><code class="docutils literal notranslate"><span class="pre">loop</span></code> Construct<a class="headerlink" href="#loop-construct" title="Permalink to this headline">¶</a></h2>
<p><strong>constructs!loop <code class="docutils literal notranslate"><span class="pre">loop</span></code></strong> <strong>loop construct <code class="docutils literal notranslate"><span class="pre">loop</span></code> construct</strong></p>
<p>The following example illustrates the use of the OpenMP 5.0 <code class="docutils literal notranslate"><span class="pre">loop</span></code> construct for the execution of a loop. The <code class="docutils literal notranslate"><span class="pre">loop</span></code> construct asserts to the compiler that the iterations  of the loop are free of data dependencies and may be executed concurrently. It allows the compiler to use heuristics to select the parallelization scheme and compiler-level optimizations for the concurrency.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: loop.1
* type: C
* version: omp_5.0
*/
#include  &lt;stdio.h&gt;
#define N 100
int main()
{
  float x[N], y[N];
  float a = 2.0;
  for(int i=0;i&lt;N;i++){ x[i]=i; y[i]=0;}   // initialize

  #pragma omp parallel
  {
    #pragma omp loop
    for(int i = 0; i &lt; N; ++i) y[i] = a*x[i] + y[i];
  }
  if(y[N-1] != (N-1)*2.0) printf(&quot;Error: 2*(N-1) != y[N-1]=%f&quot;,y[N-1]);
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name:       loop.1
! type:       F-free
! version:    omp_5.0

program main
  integer, parameter :: N=100
  real :: x(N), y(N)
  real :: a = 2.0e0

  x=(/ (i,i=1,N) /); y=1.0e0                    !! initialize

  !$omp parallel
    !$omp loop
       do i=1,N; y(i) = a*x(i) + y(i); enddo
  !$omp end parallel

  if(y(N) /= N*2.0e0) print*,&quot;Error: 2*N /= y(N); y(N)=&quot;,y(N)
end program

</pre></div>
</div>
</div>
</div>
<p>../../parallel_execution/loop.tex</p>
</div>
<div class="section" id="parallel-random-access-iterator-loop">
<h2>Parallel Random Access Iterator Loop<a class="headerlink" href="#parallel-random-access-iterator-loop" title="Permalink to this headline">¶</a></h2>
<p><strong>random access iterator, C++</strong></p>
<p>The following example shows a parallel random access iterator loop.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: pra_iterator.1
* type: C++
* version: omp_3.0
*/
#include &lt;vector&gt;
void iterator_example()
{
  std::vector&lt;int&gt; vec(23);
  std::vector&lt;int&gt;::iterator it;
#pragma omp parallel for default(none) shared(vec)
  for (it = vec.begin(); it &lt; vec.end(); it++)
  {
    // do work with *it //
  }
}

</pre></div>
</div>
</div>
</div>
<p>../../parallel_execution/pra_iterator.tex</p>
</div>
<div class="section" id="omp-set-dynamic-and-omp-set-num-threads-routines">
<h2><code class="docutils literal notranslate"><span class="pre">omp_set_dynamic</span></code> and  <code class="docutils literal notranslate"><span class="pre">omp_set_num_threads</span></code> Routines<a class="headerlink" href="#omp-set-dynamic-and-omp-set-num-threads-routines" title="Permalink to this headline">¶</a></h2>
<p><strong>routines!omp_set_dynamic <code class="docutils literal notranslate"><span class="pre">omp_set_dynamic</span></code></strong> <strong>omp_set_dynamic routine <code class="docutils literal notranslate"><span class="pre">omp_set_dynamic</span></code> routine</strong> <strong>routines!omp_set_num_threads <code class="docutils literal notranslate"><span class="pre">omp_set_num_threads</span></code></strong> <strong>omp_set_num_threads routine <code class="docutils literal notranslate"><span class="pre">omp_set_num_threads</span></code> routine</strong></p>
<p>Some programs rely on a fixed, prespecified number of threads to execute correctly.  Because the default setting for the dynamic adjustment of the number of threads  is implementation defined, such programs can choose to turn off the dynamic threads  capability and set the number of threads explicitly to ensure portability. The  following example shows how to do this using <code class="docutils literal notranslate"><span class="pre">omp_set_dynamic</span></code>, and <code class="docutils literal notranslate"><span class="pre">omp_set_num_threads</span></code>.</p>
<p>In this example, the program executes correctly only if it is executed by 16 threads.  If the implementation is not capable of supporting 16 threads, the behavior of  this example is implementation defined. Note that the number of threads executing  a <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region remains constant during the region, regardless of the  dynamic threads setting. The dynamic threads mechanism determines the number of  threads to use at the start of the <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region and keeps it constant  for the duration of the region.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: set_dynamic_nthrs.1
* type: C
*/
#include &lt;omp.h&gt;
#include &lt;stdlib.h&gt;

void do_by_16(float *x, int iam, int ipoints) {}

void dynthreads(float *x, int npoints)
{
  int iam, ipoints;

  omp_set_dynamic(0);
  omp_set_num_threads(16);

  #pragma omp parallel shared(x, npoints) private(iam, ipoints)
  {
    if (omp_get_num_threads() != 16)
      abort();

    iam = omp_get_thread_num();
    ipoints = npoints/16;
    do_by_16(x, iam, ipoints);
  }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: set_dynamic_nthrs.1
! type: F-fixed
      SUBROUTINE DO_BY_16(X, IAM, IPOINTS)
        REAL X(*)
        INTEGER IAM, IPOINTS
      END SUBROUTINE DO_BY_16

      SUBROUTINE DYNTHREADS(X, NPOINTS)

        INCLUDE &quot;omp_lib.h&quot;      ! or USE OMP_LIB

        INTEGER NPOINTS
        REAL X(NPOINTS)

        INTEGER IAM, IPOINTS

        CALL OMP_SET_DYNAMIC(.FALSE.)
        CALL OMP_SET_NUM_THREADS(16)

!$OMP   PARALLEL SHARED(X,NPOINTS) PRIVATE(IAM, IPOINTS)

          IF (OMP_GET_NUM_THREADS() .NE. 16) THEN
            STOP
          ENDIF

          IAM = OMP_GET_THREAD_NUM()
          IPOINTS = NPOINTS/16
          CALL DO_BY_16(X,IAM,IPOINTS)

!$OMP   END PARALLEL

      END SUBROUTINE DYNTHREADS

</pre></div>
</div>
</div>
</div>
<p>../../parallel_execution/set_dynamic_nthrs.tex</p>
</div>
<div class="section" id="omp-get-num-threads-routine">
<h2><code class="docutils literal notranslate"><span class="pre">omp_get_num_threads</span></code> Routine<a class="headerlink" href="#omp-get-num-threads-routine" title="Permalink to this headline">¶</a></h2>
<p><strong>routines!omp_get_num_threads <code class="docutils literal notranslate"><span class="pre">omp_get_num_threads</span></code></strong> <strong>omp_get_num_threads routine <code class="docutils literal notranslate"><span class="pre">omp_get_num_threads</span></code> routine</strong></p>
<p>In the following example, the <code class="docutils literal notranslate"><span class="pre">omp_get_num_threads</span></code> call returns 1 in  the sequential part of the code, so <code class="docutils literal notranslate"><span class="pre">np</span></code> will always be equal to 1. To determine  the number of threads that will be deployed for the <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region, the  call should be inside the <code class="docutils literal notranslate"><span class="pre">parallel</span></code> region.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: get_nthrs.1
* type: C
*/
#include &lt;omp.h&gt;
void work(int i);

void incorrect() {
  int np, i;

  np = omp_get_num_threads();  /* misplaced */

  #pragma omp parallel for schedule(static)
  for (i=0; i &lt; np; i++)
    work(i);
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: get_nthrs.1
! type: F-fixed
      SUBROUTINE WORK(I)
      INTEGER I
        I = I + 1
      END SUBROUTINE WORK

      SUBROUTINE INCORRECT()
        INCLUDE &quot;omp_lib.h&quot;      ! or USE OMP_LIB
        INTEGER I, NP

        NP = OMP_GET_NUM_THREADS()   !misplaced: will return 1
!$OMP   PARALLEL DO SCHEDULE(STATIC)
          DO I = 0, NP-1
            CALL WORK(I)
          ENDDO
!$OMP   END PARALLEL DO
      END SUBROUTINE INCORRECT

</pre></div>
</div>
</div>
</div>
<p>The following example shows how to rewrite this program without including a query  for the number of threads:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: get_nthrs.2
* type: C
*/
#include &lt;omp.h&gt;
void work(int i);

void correct()
{
  int i;

  #pragma omp parallel private(i)
  {
    i = omp_get_thread_num();
    work(i);
  }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: get_nthrs.2
! type: F-fixed
      SUBROUTINE WORK(I)
        INTEGER I

        I = I + 1

      END SUBROUTINE WORK

      SUBROUTINE CORRECT()
        INCLUDE &quot;omp_lib.h&quot;     ! or USE OMP_LIB
        INTEGER I

!$OMP    PARALLEL PRIVATE(I)
          I = OMP_GET_THREAD_NUM()
          CALL WORK(I)
!$OMP   END PARALLEL

      END SUBROUTINE CORRECT

</pre></div>
</div>
</div>
</div>
<p>../../parallel_execution/get_nthrs.tex</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "native"
        },
        kernelOptions: {
            kernelName: "native",
            path: "./contents"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'native'</script>

              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="Chap_directives.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">OpenMP Directive Syntax</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="Chap_affinity.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">OpenMP Affinity</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      By The OpenMP Community<br/>
    
        &copy; Copyright 2021.<br/>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>