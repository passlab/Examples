
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SIMD &#8212; OpenMP Application Programming Interface Examples</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet">
  <link href="../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script>
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="&lt;no title&gt;" href="Chap_loop_transformations.html" />
    <link rel="prev" title="&lt;no title&gt;" href="Chap_devices.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">OpenMP Application Programming Interface Examples</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../intro.html">
   Welcome to OMP Jupyter Book
  </a>
 </li>
</ul>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_directives.html">
   OpenMP Directive Syntax
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_parallel_execution.html">
   Parallel Execution
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_affinity.html">
   OpenMP Affinity
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_tasking.html">
   Tasking
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   SIMD
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_synchronization.html">
   Synchronization
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_data_environment.html">
   Data Environment
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_memory_model.html">
   Memory Model
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_program_control.html">
   Program Control
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/contents/Chap_SIMD.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
                onclick="printPdf(this)" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/passlab/Examples"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/passlab/Examples/issues/new?title=Issue%20on%20page%20%2Fcontents/Chap_SIMD.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/passlab/Examples/main?urlpath=lab/tree/notebook/contents/Chap_SIMD.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#simd-and-declare-simd-directives">
   <code class="docutils literal notranslate">
    <span class="pre">
     simd
    </span>
   </code>
   and
   <code class="docutils literal notranslate">
    <span class="pre">
     declare
    </span>
   </code>
   <code class="docutils literal notranslate">
    <span class="pre">
     simd
    </span>
   </code>
   Directives
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#inbranch-and-notinbranch-clauses">
   <code class="docutils literal notranslate">
    <span class="pre">
     inbranch
    </span>
   </code>
   and
   <code class="docutils literal notranslate">
    <span class="pre">
     notinbranch
    </span>
   </code>
   Clauses
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#loop-carried-lexical-forward-dependence">
   Loop-Carried Lexical Forward Dependence
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#ref-val-uval-modifiers-for-linear-clause">
   <code class="docutils literal notranslate">
    <span class="pre">
     ref
    </span>
   </code>
   ,
   <code class="docutils literal notranslate">
    <span class="pre">
     val
    </span>
   </code>
   ,
   <code class="docutils literal notranslate">
    <span class="pre">
     uval
    </span>
   </code>
   Modifiers for
   <code class="docutils literal notranslate">
    <span class="pre">
     linear
    </span>
   </code>
   Clause
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>SIMD</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#simd-and-declare-simd-directives">
   <code class="docutils literal notranslate">
    <span class="pre">
     simd
    </span>
   </code>
   and
   <code class="docutils literal notranslate">
    <span class="pre">
     declare
    </span>
   </code>
   <code class="docutils literal notranslate">
    <span class="pre">
     simd
    </span>
   </code>
   Directives
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#inbranch-and-notinbranch-clauses">
   <code class="docutils literal notranslate">
    <span class="pre">
     inbranch
    </span>
   </code>
   and
   <code class="docutils literal notranslate">
    <span class="pre">
     notinbranch
    </span>
   </code>
   Clauses
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#loop-carried-lexical-forward-dependence">
   Loop-Carried Lexical Forward Dependence
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#ref-val-uval-modifiers-for-linear-clause">
   <code class="docutils literal notranslate">
    <span class="pre">
     ref
    </span>
   </code>
   ,
   <code class="docutils literal notranslate">
    <span class="pre">
     val
    </span>
   </code>
   ,
   <code class="docutils literal notranslate">
    <span class="pre">
     uval
    </span>
   </code>
   Modifiers for
   <code class="docutils literal notranslate">
    <span class="pre">
     linear
    </span>
   </code>
   Clause
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="simd">
<h1>SIMD<a class="headerlink" href="#simd" title="Permalink to this headline">¶</a></h1>
<p>{SIMD}</p>
<p>Single instruction, multiple data (SIMD) is a form of parallel execution  in which the same operation is performed on multiple data elements  independently in hardware vector processing units (VPU), also called SIMD units. The addition of two vectors to form a third vector is a SIMD operation. Many processors have SIMD (vector) units that can perform simultaneously  2, 4, 8 or more executions of the same operation (by a single SIMD unit).</p>
<p>Loops without loop-carried backward dependency (or with dependency preserved using  ordered simd) are candidates for vectorization by the compiler for  execution with SIMD units. In addition, with state-of-the-art vectorization  technology and <code class="docutils literal notranslate"><span class="pre">declare</span> <span class="pre">simd</span></code> directive extensions for function vectorization in the OpenMP 4.5 specification, loops with function calls can be vectorized as well.  The basic idea is that a scalar function call in a loop can be replaced by a vector version  of the function, and the loop can be vectorized simultaneously by combining a loop  vectorization (<code class="docutils literal notranslate"><span class="pre">simd</span></code> directive on the loop) and a function  vectorization (<code class="docutils literal notranslate"><span class="pre">declare</span> <span class="pre">simd</span></code> directive on the function).</p>
<p>A <code class="docutils literal notranslate"><span class="pre">simd</span></code> construct states that SIMD operations be performed on the data within the loop.  A number of clauses are available to provide data-sharing attributes (<code class="docutils literal notranslate"><span class="pre">private</span></code>, <code class="docutils literal notranslate"><span class="pre">linear</span></code>, <code class="docutils literal notranslate"><span class="pre">reduction</span></code> and  <code class="docutils literal notranslate"><span class="pre">lastprivate</span></code>).  Other clauses provide vector length preference/restrictions  (<code class="docutils literal notranslate"><span class="pre">simdlen</span></code> / <code class="docutils literal notranslate"><span class="pre">safelen</span></code>), loop fusion (<code class="docutils literal notranslate"><span class="pre">collapse</span></code>), and data  alignment (<code class="docutils literal notranslate"><span class="pre">aligned</span></code>).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">declare</span> <span class="pre">simd</span></code> directive designates that a vector version of the function should also be constructed for  execution within loops that contain the function and have a <code class="docutils literal notranslate"><span class="pre">simd</span></code>  directive.  Clauses provide argument specifications (<code class="docutils literal notranslate"><span class="pre">linear</span></code>, <code class="docutils literal notranslate"><span class="pre">uniform</span></code>, and <code class="docutils literal notranslate"><span class="pre">aligned</span></code>), a requested vector length  (<code class="docutils literal notranslate"><span class="pre">simdlen</span></code>), and designate whether the function is always/never  called conditionally in a loop (<code class="docutils literal notranslate"><span class="pre">notinbranch</span></code>/<code class="docutils literal notranslate"><span class="pre">inbranch</span></code>).  The latter is for optimizing performance.</p>
<p>Also, the <code class="docutils literal notranslate"><span class="pre">simd</span></code> construct has been combined with the worksharing loop  constructs (<code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">simd</span></code> and <code class="docutils literal notranslate"><span class="pre">do</span> <span class="pre">simd</span></code>) to enable simultaneous thread  execution in different SIMD units.</p>
<div class="section" id="simd-and-declare-simd-directives">
<h2><code class="docutils literal notranslate"><span class="pre">simd</span></code> and <code class="docutils literal notranslate"><span class="pre">declare</span></code> <code class="docutils literal notranslate"><span class="pre">simd</span></code> Directives<a class="headerlink" href="#simd-and-declare-simd-directives" title="Permalink to this headline">¶</a></h2>
<p><strong>constructs!simd <code class="docutils literal notranslate"><span class="pre">simd</span></code></strong> <strong>simd construct <code class="docutils literal notranslate"><span class="pre">simd</span></code> construct</strong> The following example illustrates the basic use of the <code class="docutils literal notranslate"><span class="pre">simd</span></code> construct  to assure the compiler that the loop can be vectorized.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: SIMD.1
* type: C
* version: omp_4.0
*/
void star( double *a, double *b, double *c, int n, int *ioff )
{
   int i;
   #pragma omp simd
   for ( i = 0; i &lt; n; i++ )
      a[i] *= b[i] * c[i+ *ioff];
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: SIMD.1
! type: F-free
! version: omp_4.0
subroutine star(a,b,c,n,ioff_ptr)
   implicit none
   double precision :: a(*),b(*),c(*)
   integer          :: n, i
   integer, pointer :: ioff_ptr

   !$omp simd
   do i = 1,n
      a(i) = a(i) * b(i) * c(i+ioff_ptr)
   end do

end subroutine

</pre></div>
</div>
</div>
</div>
<p><strong>directives!declare simd <code class="docutils literal notranslate"><span class="pre">declare</span></code> <code class="docutils literal notranslate"><span class="pre">simd</span></code></strong> <strong>declare simd directive <code class="docutils literal notranslate"><span class="pre">declare</span></code> <code class="docutils literal notranslate"><span class="pre">simd</span></code> directive</strong> <strong>clauses!uniform <code class="docutils literal notranslate"><span class="pre">uniform</span></code></strong> <strong>uniform clause <code class="docutils literal notranslate"><span class="pre">uniform</span></code> clause</strong> <strong>clauses!linear <code class="docutils literal notranslate"><span class="pre">linear</span></code></strong> <strong>linear clause <code class="docutils literal notranslate"><span class="pre">linear</span></code> clause</strong> When a function can be inlined within a loop the compiler has an opportunity to  vectorize the loop. By guaranteeing SIMD behavior of a function’s operations,  characterizing the arguments of the function and privatizing temporary  variables of the loop, the compiler can often create faster, vector code for  the loop. In the examples below the <code class="docutils literal notranslate"><span class="pre">declare</span></code> <code class="docutils literal notranslate"><span class="pre">simd</span></code> directive is  used on the  <em>add1</em>  and  <em>add2</em>  functions to enable creation of their  corresponding SIMD function versions for execution within the associated SIMD  loop. The functions characterize two different approaches of accessing data  within the function: by a single variable and as an element in a data array,  respectively. The  <em>add3</em>  C function uses dereferencing.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">declare</span></code> <code class="docutils literal notranslate"><span class="pre">simd</span></code> directives also illustrate the use of  <code class="docutils literal notranslate"><span class="pre">uniform</span></code> and <code class="docutils literal notranslate"><span class="pre">linear</span></code> clauses.  The <code class="docutils literal notranslate"><span class="pre">uniform(fact)</span></code> clause  indicates that the variable  <em>fact</em>  is invariant across the SIMD lanes. In  the  <em>add2</em>  function  <em>a</em>  and  <em>b</em>  are included in the <code class="docutils literal notranslate"><span class="pre">uniform</span></code>  list because the C pointer and the Fortran array references are constant.  The   <em>i</em>  index used in the  <em>add2</em>  function is included in a <code class="docutils literal notranslate"><span class="pre">linear</span></code>  clause with a constant-linear-step of 1, to guarantee a unity increment of the  associated loop. In the <code class="docutils literal notranslate"><span class="pre">declare</span></code> <code class="docutils literal notranslate"><span class="pre">simd</span></code> directive for the  <em>add3</em>   C function the  <code class="docutils literal notranslate"><span class="pre">linear(a,b:1)</span></code> clause instructs the compiler to generate  unit-stride loads across the SIMD lanes; otherwise,  costly <strong>gather</strong>  instructions would be generated for the unknown sequence of access of the  pointer dereferences.</p>
<p>In the <code class="docutils literal notranslate"><span class="pre">simd</span></code> constructs for the loops the <code class="docutils literal notranslate"><span class="pre">private(tmp)</span></code> clause is  necessary to assure that the each vector operation has its own  <em>tmp</em>   variable.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: SIMD.2
* type: C
* version: omp_4.0
*/
#include &lt;stdio.h&gt;

#pragma omp declare simd uniform(fact)
double add1(double a, double b, double fact)
{
   double c;
   c = a + b + fact;
   return c;
}

#pragma omp declare simd uniform(a,b,fact) linear(i:1)
double add2(double *a, double *b, int i, double fact)
{
   double c;
   c = a[i] + b[i] + fact;
   return c;
}

#pragma omp declare simd uniform(fact) linear(a,b:1)
double add3(double *a, double *b, double fact)
{
   double c;
   c = *a + *b + fact;
   return c;
}

void work( double *a, double *b, int n )
{
   int i;
   double tmp;
   #pragma omp simd private(tmp)
   for ( i = 0; i &lt; n; i++ ) {
      tmp  = add1( a[i],  b[i], 1.0);
      a[i] = add2( a,     b, i, 1.0) + tmp;
      a[i] = add3(&amp;a[i], &amp;b[i], 1.0);
   }
}

int main(){
   int i;
   const int N=32;
   double a[N], b[N];

   for ( i=0; i&lt;N; i++ ) {
      a[i] = i; b[i] = N-i;
   }

   work(a, b, N );

   for ( i=0; i&lt;N; i++ ) {
      printf(&quot;%d %f\n&quot;, i, a[i]);
   }

   return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: SIMD.2
! type: F-free
! version: omp_4.0
program main
   implicit none
   integer, parameter :: N=32
   integer :: i
   double precision   :: a(N), b(N)
   do i = 1,N
      a(i) = i-1
      b(i) = N-(i-1)
   end do
   call work(a, b, N )
   do i = 1,N
      print*, i,a(i)
   end do
end program

function add1(a,b,fact) result(c)
   implicit none
!$omp declare simd(add1) uniform(fact)
   double precision :: a,b,fact, c
   c = a + b + fact
end function

function add2(a,b,i, fact) result(c)
   implicit none
!$omp declare simd(add2) uniform(a,b,fact) linear(i:1)
   integer          :: i
   double precision :: a(*),b(*),fact, c
   c = a(i) + b(i) + fact
end function

subroutine work(a, b, n )
   implicit none
   double precision           :: a(n),b(n), tmp
   integer                    :: n, i
   double precision, external :: add1, add2

   !$omp simd private(tmp)
   do i = 1,n
      tmp  = add1(a(i), b(i), 1.0d0)
      a(i) = add2(a,    b, i, 1.0d0) + tmp
      a(i) = a(i) + b(i) + 1.0d0
   end do
end subroutine

</pre></div>
</div>
</div>
</div>
<p><strong>clauses!private <code class="docutils literal notranslate"><span class="pre">private</span></code></strong> <strong>private clause <code class="docutils literal notranslate"><span class="pre">private</span></code> clause</strong> <strong>clauses!reduction <code class="docutils literal notranslate"><span class="pre">reduction</span></code></strong> <strong>reduction clause <code class="docutils literal notranslate"><span class="pre">reduction</span></code> clause</strong> <strong>reductions!reduction clause <code class="docutils literal notranslate"><span class="pre">reduction</span></code> clause</strong> A thread that encounters a SIMD construct executes a vectorized code of the  iterations. Similar to the concerns of a worksharing loop a loop vectorized  with a SIMD construct must assure that temporary and reduction variables are  privatized and declared as reductions with clauses.  The example below  illustrates the use of <code class="docutils literal notranslate"><span class="pre">private</span></code> and <code class="docutils literal notranslate"><span class="pre">reduction</span></code> clauses in a SIMD  construct.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: SIMD.3
* type: C
* version: omp_4.0
*/
double work( double *a, double *b, int n )
{
   int i;
   double tmp, sum;
   sum = 0.0;
   #pragma omp simd private(tmp) reduction(+:sum)
   for (i = 0; i &lt; n; i++) {
      tmp = a[i] + b[i];
      sum += tmp;
   }
   return sum;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: SIMD.3
! type: F-free
! version: omp_4.0
subroutine work( a, b, n, sum )
   implicit none
   integer :: i, n
   double precision :: a(n), b(n), sum, tmp

   sum = 0.0d0
   !$omp simd private(tmp) reduction(+:sum)
   do i = 1,n
      tmp = a(i) + b(i)
      sum = sum + tmp
   end do

end subroutine work

</pre></div>
</div>
</div>
</div>
<p><strong>clauses!safelen <code class="docutils literal notranslate"><span class="pre">safelen</span></code></strong> <strong>safelen clause <code class="docutils literal notranslate"><span class="pre">safelen</span></code> clause</strong> A <code class="docutils literal notranslate"><span class="pre">safelen(N)</span></code> clause in a <code class="docutils literal notranslate"><span class="pre">simd</span></code> construct assures the compiler that  there are no loop-carried dependencies for vectors of size  <em>N</em>  or below. If  the <code class="docutils literal notranslate"><span class="pre">safelen</span></code> clause is not specified, then the default safelen value is  the number of loop iterations.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">safelen(16)</span></code> clause in the example below guarantees that the vector  code is safe for vectors up to and including size 16.  In the loop,  <em>m</em>  can  be 16 or greater, for correct code execution.  If the value of  <em>m</em>  is less  than 16, the behavior is undefined.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: SIMD.4
* type: C
* version: omp_4.0
*/
void work( float *b, int n, int m )
{
   int i;
   #pragma omp simd safelen(16)
   for (i = m; i &lt; n; i++)
      b[i] = b[i-m] - 1.0f;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: SIMD.4
! type: F-free
! version: omp_4.0
subroutine work( b, n, m )
   implicit none
   real       :: b(n)
   integer    :: i,n,m

   !$omp simd safelen(16)
   do i = m+1, n
      b(i) = b(i-m) - 1.0
   end do
end subroutine work

</pre></div>
</div>
</div>
</div>
<p><strong>clauses!collapse <code class="docutils literal notranslate"><span class="pre">collapse</span></code></strong> <strong>collapse clause <code class="docutils literal notranslate"><span class="pre">collapse</span></code> clause</strong> The following SIMD construct instructs the compiler to collapse the  <em>i</em>  and   <em>j</em>  loops into a single SIMD loop in which SIMD chunks are executed by  threads of the team. Within the workshared loop chunks of a thread, the SIMD  chunks are executed in the lanes of the vector units.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: SIMD.5
* type: C
* version: omp_4.0
*/
void work( double **a, double **b, double **c, int n )
{
   int i, j;
   double tmp;
   #pragma omp for simd collapse(2) private(tmp)
   for (i = 0; i &lt; n; i++) {
      for (j = 0; j &lt; n; j++) {
         tmp = a[i][j] + b[i][j];
         c[i][j] = tmp;
      }
   }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: SIMD.5
! type: F-free
! version: omp_4.0
subroutine work( a, b, c,  n )
   implicit none
   integer :: i,j,n
   double precision :: a(n,n), b(n,n), c(n,n), tmp

   !$omp do simd collapse(2) private(tmp)
   do j = 1,n
      do i = 1,n
         tmp = a(i,j) + b(i,j)
         c(i,j) = tmp
      end do
   end do

end subroutine work

</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="inbranch-and-notinbranch-clauses">
<h2><code class="docutils literal notranslate"><span class="pre">inbranch</span></code> and <code class="docutils literal notranslate"><span class="pre">notinbranch</span></code> Clauses<a class="headerlink" href="#inbranch-and-notinbranch-clauses" title="Permalink to this headline">¶</a></h2>
<p><strong>clauses!inbranch <code class="docutils literal notranslate"><span class="pre">inbranch</span></code></strong> <strong>inbranch clause <code class="docutils literal notranslate"><span class="pre">inbranch</span></code> clause</strong> <strong>clauses!notinbranch <code class="docutils literal notranslate"><span class="pre">notinbranch</span></code></strong> <strong>notinbranch clause <code class="docutils literal notranslate"><span class="pre">notinbranch</span></code> clause</strong></p>
<p>The following examples illustrate the use of the <code class="docutils literal notranslate"><span class="pre">declare</span></code> <code class="docutils literal notranslate"><span class="pre">simd</span></code>  directive with the <code class="docutils literal notranslate"><span class="pre">inbranch</span></code> and <code class="docutils literal notranslate"><span class="pre">notinbranch</span></code> clauses. The  <code class="docutils literal notranslate"><span class="pre">notinbranch</span></code> clause informs the compiler that the function  <em>foo</em>  is  never called conditionally in the SIMD loop of the function  <em>myaddint</em> . On  the other hand, the <code class="docutils literal notranslate"><span class="pre">inbranch</span></code> clause for the function goo indicates that  the function is always called conditionally in the SIMD loop inside  the function  <em>myaddfloat</em> .</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: SIMD.6
* type: C
* version: omp_4.0
*/
#pragma omp declare simd linear(p:1) notinbranch
int foo(int *p){
  *p = *p + 10;
  return *p;
}

int myaddint(int *a, int *b, int n)
{
#pragma omp simd
  for (int i=0; i&lt;n; i++){
      a[i]  = foo(&amp;b[i]);  /* foo is not called under a condition */
  }
  return a[n-1];
}

#pragma omp declare simd linear(p:1) inbranch
float goo(float *p){
  *p = *p + 18.5f;
  return *p;
}

int myaddfloat(float *x, float *y, int n)
{
#pragma omp simd
  for (int i=0; i&lt;n; i++){
     x[i] = (x[i] &gt; y[i]) ? goo(&amp;y[i]) : y[i];
       /* goo is called under the condition (or within a branch) */
  }
  return x[n-1];
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: SIMD.6
! type: F-free
! version: omp_4.0
function foo(p) result(r)
  implicit none
!$omp declare simd(foo) notinbranch
  integer :: p, r
  p = p + 10
  r = p
end function foo

function myaddint(a, b,  n) result(r)
  implicit none
  integer :: a(*), b(*), n, r
  integer :: i
  integer, external :: foo

  !$omp simd
  do i=1, n
      a(i) = foo(b(i))  ! foo is not called under a condition
  end do
  r = a(n)

end function myaddint

function goo(p) result(r)
  implicit none
!$omp declare simd(goo) inbranch
  real :: p, r
  p = p + 18.5
  r = p
end function goo

function myaddfloat(x, y, n) result(r)
  implicit none
  real :: x(*), y(*), r
  integer :: n
  integer :: i
  real, external :: goo

  !$omp simd
  do i=1, n
     if (x(i) &gt; y(i)) then
        x(i) = goo(y(i))
        ! goo is called under the condition (or within a branch)
     else
        x(i) = y(i)
     endif
  end do

  r = x(n)
end function myaddfloat

</pre></div>
</div>
</div>
</div>
<p>In the code below, the function  <em>fib()</em>  is called in the main program and  also recursively called in the function  <em>fib()</em>  within an <code class="docutils literal notranslate"><span class="pre">if</span></code>  condition. The compiler creates a masked vector version and a non-masked vector  version for the function  <em>fib()</em>  while retaining the original scalar  version of the  <em>fib()</em>  function.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: SIMD.7
* type: C
* version: omp_4.0
*/
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define N 45
int a[N], b[N], c[N];

#pragma omp declare simd inbranch
int fib( int n )
{
   if (n &lt;= 1)
      return n;
   else {
      return fib(n-1) + fib(n-2);
   }
}

int main(void)
{
   int i;

   #pragma omp simd
   for (i=0; i &lt; N; i++) b[i] = i;

   #pragma omp simd
   for (i=0; i &lt; N; i++) {
      a[i] = fib(b[i]);
   }
   printf(&quot;Done a[%d] = %d\n&quot;, N-1, a[N-1]);
   return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: SIMD.7
! type: F-free
! version: omp_4.0
program fibonacci
   implicit none
   integer,parameter :: N=45
   integer           :: a(0:N-1), b(0:N-1)
   integer           :: i
   integer, external :: fib

   !$omp simd
   do i = 0,N-1
      b(i) = i
   end do

   !$omp simd
   do i=0,N-1
      a(i) = fib(b(i))
   end do

   write(*,*) &quot;Done a(&quot;, N-1, &quot;) = &quot;, a(N-1)
                        ! 44  701408733
end program

recursive function fib(n) result(r)
   implicit none
!$omp declare simd(fib) inbranch
   integer  :: n, r

   if (n &lt;= 1) then
      r = n
   else
      r = fib(n-1) + fib(n-2)
   endif

end function fib

</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="loop-carried-lexical-forward-dependence">
<h2>Loop-Carried Lexical Forward Dependence<a class="headerlink" href="#loop-carried-lexical-forward-dependence" title="Permalink to this headline">¶</a></h2>
<p><strong>dependences!loop-carried lexical forward</strong></p>
<p>The following example tests the restriction on an SIMD loop with the loop-carried lexical forward-dependence. This dependence must be preserved for the correct execution of SIMD loops.</p>
<p>A loop can be vectorized even though the iterations are not completely independent when it has loop-carried dependences that are forward lexical dependences, indicated in the code below by the read of  <em>A[j+1]</em>  and the write to  <em>A[j]</em>  in C/C++ code (or  <em>A(j+1)</em>  and  <em>A(j)</em>  in Fortran). That is, the read of  <em>A[j+1]</em>  (or  <em>A(j+1)</em>  in Fortran) before the write to  <em>A[j]</em>  (or  <em>A(j)</em>  in Fortran) ordering must be preserved for each iteration in  <em>j</em>  for valid SIMD code generation.</p>
<p>This test assures that the compiler preserves the loop carried lexical forward-dependence for generating a correct SIMD code.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: SIMD.8
* type: C
* version: omp_4.0
*/
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int   P[1000];
float A[1000];

float do_work(float *arr)
{
  float pri;
  int i;
#pragma omp simd lastprivate(pri)
  for (i = 0; i &lt; 999; ++i) {
    int j = P[i];

    pri = 0.5f;
    if (j % 2 == 0) {
      pri = A[j+1] + arr[i];
    }
    A[j] = pri * 1.5f;
    pri = pri + A[j];
  }
  return pri;
}

int main(void)
{
  float pri, arr[1000];
  int i;

  for (i = 0; i &lt; 1000; ++i) {
     P[i]   = i;
     A[i]   = i * 1.5f;
     arr[i] = i * 1.8f;
  }
  pri = do_work(&amp;arr[0]);
  if (pri == 8237.25) {
    printf(&quot;passed: result pri = %7.2f (8237.25) \n&quot;, pri);
  }
  else {
    printf(&quot;failed: result pri = %7.2f (8237.25) \n&quot;, pri);
  }
  return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: SIMD.8
! type: F-free
! version: omp_4.0
module work

integer :: P(1000)
real    :: A(1000)

contains
function do_work(arr) result(pri)
  implicit none
  real, dimension(*) :: arr

  real :: pri
  integer :: i, j

  !$omp simd private(j) lastprivate(pri)
  do i = 1, 999
    j = P(i)

    pri = 0.5
    if (mod(j-1, 2) == 0) then
      pri = A(j+1) + arr(i)
    endif
    A(j) = pri * 1.5
    pri = pri + A(j)
  end do

end function do_work

end module work

program simd_8f
  use work
  implicit none
  real :: pri, arr(1000)
  integer :: i

  do i = 1, 1000
     P(i)   = i
     A(i)   = (i-1) * 1.5
     arr(i) = (i-1) * 1.8
  end do
  pri = do_work(arr)
  if (pri == 8237.25) then
    print 2, &quot;passed&quot;, pri
  else
    print 2, &quot;failed&quot;, pri
  endif
2 format(a, &quot;: result pri = &quot;, f7.2, &quot; (8237.25)&quot;)

end program

</pre></div>
</div>
</div>
</div>
<p>../../SIMD/SIMD.tex</p>
</div>
<div class="section" id="ref-val-uval-modifiers-for-linear-clause">
<h2><code class="docutils literal notranslate"><span class="pre">ref</span></code>, <code class="docutils literal notranslate"><span class="pre">val</span></code>, <code class="docutils literal notranslate"><span class="pre">uval</span></code> Modifiers for <code class="docutils literal notranslate"><span class="pre">linear</span></code> Clause<a class="headerlink" href="#ref-val-uval-modifiers-for-linear-clause" title="Permalink to this headline">¶</a></h2>
<p><strong>modifiers, linear modifiers, <code class="docutils literal notranslate"><span class="pre">linear</span></code>!ref <code class="docutils literal notranslate"><span class="pre">ref</span></code></strong> <strong>modifiers, linear modifiers, <code class="docutils literal notranslate"><span class="pre">linear</span></code>!val <code class="docutils literal notranslate"><span class="pre">val</span></code></strong> <strong>modifiers, linear modifiers, <code class="docutils literal notranslate"><span class="pre">linear</span></code>!uval <code class="docutils literal notranslate"><span class="pre">uval</span></code></strong> <strong>clauses!linear <code class="docutils literal notranslate"><span class="pre">linear</span></code></strong> <strong>linear clause <code class="docutils literal notranslate"><span class="pre">linear</span></code> clause</strong></p>
<p>When generating vector functions from <code class="docutils literal notranslate"><span class="pre">declare</span></code> <code class="docutils literal notranslate"><span class="pre">simd</span></code> directives,  it is important for a compiler to know the proper types of function arguments in order to generate efficient codes. This is especially true for C++ reference types and Fortran arguments.</p>
<p>In the following example, the function  <em>add_one2</em>  has a C++ reference parameter (or Fortran argument)  <em>p</em> .  Variable  <em>p</em>  gets incremented by 1 in the function. The caller loop  <em>i</em>  in the main program passes  a variable  <em>k</em>  as a reference to the function  <em>add_one2</em>  call.    The <code class="docutils literal notranslate"><span class="pre">ref</span></code> modifier for the <code class="docutils literal notranslate"><span class="pre">linear</span></code> clause on the  <code class="docutils literal notranslate"><span class="pre">declare</span></code> <code class="docutils literal notranslate"><span class="pre">simd</span></code> directive specifies that the  reference-type parameter  <em>p</em>  is to match the property of the variable   <em>k</em>  in the loop.   This use of reference type is equivalent to the second call to   <em>add_one2</em>  with a direct passing of the array element  <em>a[i]</em> .   In the example, the preferred vector  length 8 is specified for both the caller loop and the callee function.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">linear(p:</span> <span class="pre">ref)</span></code> is applied to an argument passed by reference,  it tells the compiler that the addresses in its vector argument are consecutive, and so the compiler can generate a single vector load or store instead of  a gather or scatter. This allows more efficient SIMD code to be generated with  less source changes.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: linear_modifier.1
* type: C++
* version: omp_5.1
*/
#include &lt;stdio.h&gt;

#define NN 1023
int a[NN];

#pragma omp declare simd linear(p: ref) simdlen(8)
void add_one2(int&amp; p)
{
   p += 1;
}

int main(void)
{
   int i;
   int* p = a;

   for (i = 0; i &lt; NN; i++) {
      a[i] = i;
   }

#pragma omp simd linear(p) simdlen(8)
   for (i = 0; i &lt; NN; i++) {
      int&amp; k = *p;
      add_one2(k);
      add_one2(a[i]);
      p++;
   }

   for (i = 0; i &lt; NN; i++) {
      if (a[i] != i+2) {
         printf(&quot;failed\n&quot;);
         return 1;
      }
   }
   printf(&quot;passed\n&quot;);
   return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: linear_modifier.1
! type: F-free
! version: omp_5.2
module m
   integer, parameter :: NN = 1023
   integer :: a(NN)

 contains
   subroutine add_one2(p)
   !$omp declare simd(add_one2) linear(p: ref) simdlen(8)
   implicit none
   integer :: p

   p = p + 1
   end subroutine
end module

program main
   use m
   implicit none
   integer :: i, p

   do i = 1, NN
      a(i) = i
   end do

   p = 1
   !$omp simd linear(p) simdlen(8)
   do i = 1, NN
      associate(k =&gt; a(p))
         call add_one2(k)
      end associate
      call add_one2(a(i))
      p = p + 1
   end do

   do i = 1, NN
      if (a(i) /= i+2) then
         print *, &quot;failed&quot;
         stop
      endif
   end do
   print *, &quot;passed&quot;
end program


</pre></div>
</div>
</div>
</div>
<p>The following example is a variant of the above example. The function  <em>add_one2</em>   in the C++ code includes an additional C++ reference parameter  <em>i</em> .  The loop index  <em>i</em>  of the caller loop  <em>i</em>  in the main program  is passed as a reference to the function  <em>add_one2</em>  call.    The loop index  <em>i</em>  has a uniform address with linear value of step 1 across SIMD lanes.  Thus, the <code class="docutils literal notranslate"><span class="pre">uval</span></code> modifier is used for the <code class="docutils literal notranslate"><span class="pre">linear</span></code> clause  to specify that the C++ reference-type parameter  <em>i</em>  is to match  the property of loop index  <em>i</em> .</p>
<p>In the corresponding Fortran code the arguments  <em>p</em>  and  <em>i</em>  in the routine  <em>add_on2</em>  are passed by references.  Similar modifiers are used for these variables in the <code class="docutils literal notranslate"><span class="pre">linear</span></code> clauses to match with the property at the caller loop in the main program.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">linear(i:</span> <span class="pre">uval)</span></code> is applied to an argument passed by reference, it  tells the compiler that its addresses in the vector argument are uniform  so that the compiler can generate a scalar load or scalar store and create  linear values. This allows more efficient SIMD code to be generated with  less source changes.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: linear_modifier.2
* type: C++
* version: omp_5.2
*/
#include &lt;stdio.h&gt;

#define NN 1023
int a[NN];

#pragma omp declare simd linear(p: ref) linear(i: uval)
void add_one2(int&amp; p, const int&amp; i)
{
   p += i;
}

int main(void)
{
   int i;
   int* p = a;

   for (i = 0; i &lt; NN; i++) {
      a[i] = i;
   }

   #pragma omp simd linear(p)
   for (i = 0; i &lt; NN; i++) {
      int&amp; k = *p;
      add_one2(k, i);
      p++;
   }

   for (i = 0; i &lt; NN; i++) {
      if (a[i] != i*2) {
         printf(&quot;failed\n&quot;);
         return 1;
      }
   }
   printf(&quot;passed\n&quot;);
   return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: linear_modifier.2
! type: F-free
! version: omp_5.2
module m
   integer, parameter :: NN = 1023
   integer :: a(NN)

 contains
   subroutine add_one2(p, i)
   !$omp declare simd(add_one2) linear(p: ref) linear(i: uval)
   implicit none
   integer :: p
   integer, intent(in) :: i

   p = p + i
   end subroutine
end module

program main
   use m
   implicit none
   integer :: i, p

   do i = 1, NN
      a(i) = i
   end do

   p = 1
   !$omp simd linear(p)
   do i = 1, NN
      call add_one2(a(p), i)
      p = p + 1
   end do

   do i = 1, NN
      if (a(i) /= i*2) then
         print *, &quot;failed&quot;
         stop
      endif
   end do
   print *, &quot;passed&quot;
end program

</pre></div>
</div>
</div>
</div>
<p>In the following example, the function  <em>func</em>  takes arrays  <em>x</em>  and  <em>y</em>   as arguments, and accesses the array elements referenced by the index  <em>i</em> . The caller loop  <em>i</em>  in the main program passes a linear copy of the variable  <em>k</em>  to the function  <em>func</em> . The <code class="docutils literal notranslate"><span class="pre">val</span></code> modifier is used for the <code class="docutils literal notranslate"><span class="pre">linear</span></code> clause  in the <code class="docutils literal notranslate"><span class="pre">declare</span></code> <code class="docutils literal notranslate"><span class="pre">simd</span></code> directive for the function  <em>func</em>  to specify that the argument  <em>i</em>  is to match the property of  the actual argument  <em>k</em>  passed in the SIMD loop. Arrays  <em>x</em>  and  <em>y</em>  have uniform addresses across SIMD lanes.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">linear(i:</span> <span class="pre">val,step(1))</span></code> is applied to an argument,  it tells the compiler that its addresses in the vector argument may not be  consecutive, however, their values are linear (with stride 1 here). When the value of  <em>i</em>  is used  in subscript of array references (e.g.,  <em>x[i]</em> ), the compiler can generate  a vector load or store instead of a gather or scatter. This allows more  efficient SIMD code to be generated with less source changes.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: linear_modifier.3
* type: C
* version: omp_5.2
*/
#include &lt;stdio.h&gt;

#define N 128

#pragma omp declare simd simdlen(4) uniform(x, y) linear(i:val,step(1))
double func(double x[], double y[], int i)
{
   return (x[i] + y[i]);
}

int main(void)
{
   double x[N], y[N], z1[N], z2;
   int i, k;

   for (i = 0; i &lt; N; i++) {
      x[i] = (double)i;
      y[i] = (double)i*2;
   }

   k = 0;
#pragma omp simd linear(k)
   for (i = 0; i &lt; N; i++) {
      z1[i] = func(x, y, k);
      k++;
   }

   for (i = 0; i &lt; N; i++) {
      z2 = (double)(i + i*2);
      if (z1[i] != z2) {
         printf(&quot;failed\n&quot;);
         return 1;
      }
   }
   printf(&quot;passed\n&quot;);
   return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: linear_modifier.3
! type: F-free
! version: omp_5.2
module func_mod
contains
   real(8) function func(x, y, i)
!$omp declare simd(func) simdlen(4) uniform(x, y) linear(i:val,step(1))
      implicit none
      real(8), intent(in) :: x(*), y(*)
      integer, intent(in) :: i

      func = x(i) + y(i)

   end function func
end module func_mod

program main
   use func_mod
   implicit none
   integer, parameter :: n = 128
   real(8) :: x(n), y(n), z1(n), z2
   integer :: i, k

   do i=1, n
      x(i) = real(i, kind=8)
      y(i) = real(i*2, kind=8)
   enddo

   k = 1
!$omp simd linear(k)
   do i=1, n
      z1(i) = func(x, y, k)
      k = k + 1
   enddo

   do i=1, n
      z2 = real(i+i*2, kind=8)
      if (z1(i) /= z2) then
         print *, &#39;failed&#39;
         stop
      endif
   enddo
   print *, &#39;passed&#39;
end program main

</pre></div>
</div>
</div>
</div>
<p>../../SIMD/linear_modifier.tex</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "native"
        },
        kernelOptions: {
            kernelName: "native",
            path: "./contents"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'native'</script>

              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="Chap_devices.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">&lt;no title&gt;</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="Chap_loop_transformations.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">&lt;no title&gt;</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      By The OpenMP Community<br/>
    
        &copy; Copyright 2021.<br/>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>